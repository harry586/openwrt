# firmware-build-fix.yml
name: 🔧 自动修复系统

on:
  push:
    paths:
      - 'fix.txt'
  
  workflow_dispatch:

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: 🛎️ 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔍 检查修复文件
        run: |
          echo "=== 检查修复文件 ==="
          
          if [ ! -f "fix.txt" ]; then
            echo "❌ 没有找到修复文件 fix.txt"
            exit 1
          fi
          
          echo "✅ 找到修复文件 fix.txt"
          echo "修复文件大小: $(wc -l < fix.txt) 行"
          echo "修复文件内容预览:"
          head -3 fix.txt
          
          # 检查是否有系统性标识
          if grep -q "#【" fix.txt; then
            echo "🔧 检测到系统性标识"
            echo "找到的标识:"
            grep -o "#【[^】]*】" fix.txt
          else
            echo "⚠️ 没有检测到系统性标识"
          fi
      
      - name: 📝 解析并应用修复
        run: |
          echo "=== 解析并应用修复 ==="
          
          # 1. 查找目标文件
          TARGET_FILE=""
          
          # 首先尝试在常见位置查找 build_firmware_main.sh
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="firmware-config/scripts/build_firmware_main.sh"
          elif [ -f "scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="scripts/build_firmware_main.sh"
          elif [ -f "build_firmware_main.sh" ]; then
            TARGET_FILE="build_firmware_main.sh"
          else
            # 使用find命令搜索
            echo "🔍 开始全目录搜索 build_firmware_main.sh..."
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "❌ 错误: 未找到 build_firmware_main.sh 文件"
            echo "请确保文件存在于以下位置之一:"
            echo "- firmware-config/scripts/build_firmware_main.sh"
            echo "- scripts/build_firmware_main.sh" 
            echo "- build_firmware_main.sh"
            exit 1
          fi
          
          echo "✅ 找到目标文件: $TARGET_FILE"
          
          # 2. 备份原文件
          BACKUP_FILE="${TARGET_FILE}.backup.$(date +%Y%m%d_%H%M%S)"
          cp "$TARGET_FILE" "$BACKUP_FILE"
          echo "✅ 已备份原文件到: $BACKUP_FILE"
          
          # 3. 读取修复内容
          echo "📖 读取修复内容..."
          FIX_CONTENT=$(cat fix.txt)
          
          # 4. 提取所有函数并替换
          echo "🔧 开始应用函数修复..."
          
          # 查找所有函数标识
          FUNCTION_LINES=$(grep -n "#【build_firmware_main.sh-" fix.txt || true)
          
          if [ -z "$FUNCTION_LINES" ]; then
            echo "⚠️ 修复文件中没有找到函数标识"
            echo "💡 尝试将整个文件追加到目标文件末尾"
            echo "" >> "$TARGET_FILE"
            echo "# ============ 自动修复内容 ============" >> "$TARGET_FILE"
            echo "# 修复时间: $(date)" >> "$TARGET_FILE"
            echo "# 来源: fix.txt" >> "$TARGET_FILE"
            cat fix.txt >> "$TARGET_FILE"
            echo "# ============ 修复结束 ============" >> "$TARGET_FILE"
          else
            echo "📋 找到的函数标识:"
            echo "$FUNCTION_LINES"
            
            # 处理每个函数
            echo "$FUNCTION_LINES" | while IFS= read -r line_info; do
              # 提取行号
              LINE_NUM=$(echo "$line_info" | cut -d: -f1)
              
              # 提取完整标识
              IDENTIFIER=$(echo "$line_info" | cut -d: -f2-)
              
              # 提取函数名（从标识后的行获取）
              NEXT_LINE=$((LINE_NUM + 1))
              FUNC_LINE=$(sed -n "${NEXT_LINE}p" fix.txt)
              
              # 从函数行提取函数名（例如 "download_openwrt_sdk() {"）
              FUNC_NAME=$(echo "$FUNC_LINE" | sed 's/(.*//' | sed 's/[[:space:]]*$//')
              
              if [ -n "$FUNC_NAME" ]; then
                echo "🔨 处理函数: $FUNC_NAME (标识: $IDENTIFIER)"
                
                # 提取函数的开始和结束位置
                FUNC_START=$LINE_NUM
                FUNC_END=""
                
                # 从函数开始行查找函数结束（遇到下一个标识或文件结束）
                TOTAL_LINES=$(wc -l < fix.txt)
                CURRENT_LINE=$FUNC_START
                
                while [ $CURRENT_LINE -le $TOTAL_LINES ]; do
                  # 如果是下一个函数标识（但不是当前这个）
                  if [ $CURRENT_LINE -gt $FUNC_START ]; then
                    LINE_CONTENT=$(sed -n "${CURRENT_LINE}p" fix.txt)
                    if [[ "$LINE_CONTENT" =~ "#【build_firmware_main.sh-" ]]; then
                      FUNC_END=$((CURRENT_LINE - 1))
                      break
                    fi
                  fi
                  ((CURRENT_LINE++))
                done
                
                if [ -z "$FUNC_END" ]; then
                  FUNC_END=$TOTAL_LINES
                fi
                
                echo "📌 函数范围: 第 $FUNC_START 行到第 $FUNC_END 行"
                
                # 提取函数内容
                FUNC_CONTENT=$(sed -n "${FUNC_START},${FUNC_END}p" fix.txt)
                
                # 在原文件中查找该函数
                echo "🔍 在原文件中查找函数 $FUNC_NAME..."
                ORIG_FUNC_LINE=$(grep -n "^${FUNC_NAME}()" "$TARGET_FILE" | head -1 | cut -d: -f1)
                
                if [ -n "$ORIG_FUNC_LINE" ]; then
                  echo "✅ 找到原函数，开始行: $ORIG_FUNC_LINE"
                  
                  # 查找原函数的结束位置
                  ORIG_FILE_LINES=$(wc -l < "$TARGET_FILE")
                  ORIG_FUNC_END=$ORIG_FUNC_LINE
                  ORIG_CURRENT_LINE=$((ORIG_FUNC_LINE + 1))
                  
                  while [ $ORIG_CURRENT_LINE -le $ORIG_FILE_LINES ]; do
                    ORIG_LINE_CONTENT=$(sed -n "${ORIG_CURRENT_LINE}p" "$TARGET_FILE")
                    
                    # 如果找到下一个函数定义或文件结束
                    if [[ "$ORIG_LINE_CONTENT" =~ ^[a-zA-Z_][a-zA-Z0-9_]*\(\) ]] || [ $ORIG_CURRENT_LINE -eq $ORIG_FILE_LINES ]; then
                      ORIG_FUNC_END=$((ORIG_CURRENT_LINE - 1))
                      break
                    fi
                    ((ORIG_CURRENT_LINE++))
                  done
                  
                  if [ $ORIG_FUNC_END -eq $ORIG_FUNC_LINE ]; then
                    ORIG_FUNC_END=$ORIG_FILE_LINES
                  fi
                  
                  echo "📌 原函数范围: 第 $ORIG_FUNC_LINE 行到第 $ORIG_FUNC_END 行"
                  
                  # 创建临时文件进行替换
                  TEMP_FILE="${TARGET_FILE}.temp"
                  
                  # 原文件前部分 + 新函数内容 + 原文件后部分
                  head -n $((ORIG_FUNC_LINE - 1)) "$TARGET_FILE" > "$TEMP_FILE"
                  echo "$FUNC_CONTENT" >> "$TEMP_FILE"
                  tail -n +$((ORIG_FUNC_END + 1)) "$TARGET_FILE" >> "$TEMP_FILE"
                  
                  # 验证替换结果
                  if [ $(wc -l < "$TEMP_FILE") -gt 10 ]; then
                    mv "$TEMP_FILE" "$TARGET_FILE"
                    echo "✅ 函数 $FUNC_NAME 替换成功"
                  else
                    echo "⚠️ 替换后文件太小，可能有错误，跳过此函数"
                    rm -f "$TEMP_FILE"
                  fi
                  
                else
                  echo "⚠️ 在原文件中未找到函数 $FUNC_NAME，追加到文件末尾"
                  echo "" >> "$TARGET_FILE"
                  echo "# ============ 自动修复追加函数: $FUNC_NAME ============" >> "$TARGET_FILE"
                  echo "$FUNC_CONTENT" >> "$TARGET_FILE"
                  echo "✅ 函数 $FUNC_NAME 已追加"
                fi
                
              else
                echo "⚠️ 无法提取函数名，跳过此行: $IDENTIFIER"
              fi
            done
          fi
          
          echo "✅ 所有修复处理完成"
          
          # 5. 创建修复日志
          LOG_FILE="auto-fix-log-$(date +%Y%m%d_%H%M%S).txt"
          echo "# 自动修复日志" > "$LOG_FILE"
          echo "时间: $(date)" >> "$LOG_FILE"
          echo "目标文件: $TARGET_FILE" >> "$LOG_FILE"
          echo "备份文件: $BACKUP_FILE" >> "$LOG_FILE"
          echo "修复文件: fix.txt" >> "$LOG_FILE"
          
          if [ -n "$FUNCTION_LINES" ]; then
            echo "" >> "$LOG_FILE"
            echo "# 修复的函数:" >> "$LOG_FILE"
            echo "$FUNCTION_LINES" | while IFS= read -r line; do
              ID=$(echo "$line" | cut -d: -f2-)
              echo "- $ID" >> "$LOG_FILE"
            done
          fi
      
      - name: 📤 提交并推送修改
        run: |
          echo "=== 提交并推送修改 ==="
          
          # 配置Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # 检查是否有更改
          if git diff --quiet; then
            echo "⚠️ 没有检测到文件更改"
            # 为了确保有提交，创建一个标记文件
            MARKER="auto-fix-marker-$(date +%s).txt"
            echo "# 自动修复标记" > "$MARKER"
            echo "# 时间: $(date)" >> "$MARKER"
            echo "# 文件: fix.txt 已处理" >> "$MARKER"
            git add "$MARKER"
          else
            echo "💾 检测到文件更改，准备提交..."
            git add -A
          fi
          
          # 提交
          COMMIT_MSG="🔧 自动修复"
          COMMIT_MSG+="\n\n来源: fix.txt"
          COMMIT_MSG+="\n时间: $(date)"
          COMMIT_MSG+="\n事件: ${{ github.event_name }}"
          
          # 添加修复的函数列表
          if [ -f "fix.txt" ] && grep -q "#【build_firmware_main.sh-" fix.txt; then
            COMMIT_MSG+="\n\n修复的函数:"
            grep "#【build_firmware_main.sh-" fix.txt | while IFS= read -r identifier; do
              # 提取函数名
              LINE_NUM=$(grep -n "$identifier" fix.txt | cut -d: -f1)
              NEXT_LINE=$((LINE_NUM + 1))
              FUNC_LINE=$(sed -n "${NEXT_LINE}p" fix.txt 2>/dev/null || true)
              FUNC_NAME=$(echo "$FUNC_LINE" | sed 's/(.*//' | sed 's/[[:space:]]*$//' 2>/dev/null || true)
              
              if [ -n "$FUNC_NAME" ]; then
                COMMIT_MSG+="\n- $FUNC_NAME"
              else
                COMMIT_MSG+="\n- $(echo "$identifier" | sed 's/#【//' | sed 's/】//')"
              fi
            done
          fi
          
          echo -e "$COMMIT_MSG" | git commit -F -
          
          # 推送
          echo "🚀 推送到主分支..."
          git push origin HEAD:main
          
          echo "✅ 修复已应用并推送到主分支"
          
          # 清理fix.txt文件
          echo "🧹 清理fix.txt文件..."
          > fix.txt
          git add fix.txt
          git commit -m "🧹 清理修复文件 [skip ci]" || true
          git push origin HEAD:main
      
      - name: 📋 生成报告
        if: always()
        run: |
          echo "### 🔧 自动修复完成" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "**状态:** ✅ 成功" >> $GITHUB_STEP_SUMMARY
          else
            echo "**状态:** ❌ 失败" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "**时间:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**触发:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 显示修复的函数信息
          if [ -f "fix.txt" ]; then
            echo "**修复文件:** fix.txt ($(wc -l < fix.txt) 行)" >> $GITHUB_STEP_SUMMARY
            
            # 显示找到的函数标识
            if grep -q "#【" fix.txt; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**修复的函数:**" >> $GITHUB_STEP_SUMMARY
              grep "#【build_firmware_main.sh-" fix.txt | while IFS= read -r identifier; do
                # 清理标识格式
                CLEAN_ID=$(echo "$identifier" | sed 's/#【//' | sed 's/】//')
                echo "- $CLEAN_ID" >> $GITHUB_STEP_SUMMARY
              done
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**处理流程:**" >> $GITHUB_STEP_SUMMARY
          echo "1. ✅ 检查修复文件" >> $GITHUB_STEP_SUMMARY
          echo "2. ✅ 解析系统性标识" >> $GITHUB_STEP_SUMMARY
          echo "3. ✅ 查找并修改目标文件" >> $GITHUB_STEP_SUMMARY
          echo "4. ✅ 提交并推送更改" >> $GITHUB_STEP_SUMMARY
          echo "5. ✅ 清理修复文件" >> $GITHUB_STEP_SUMMARY

# firmware-build-fix.yml
name: 🔧 自动修复系统

on:
  push:
    paths:
      - '**/fix.txt'  # 匹配任意位置的fix.txt
      - 'fix.txt'     # 根目录的fix.txt
  
  workflow_dispatch:
    inputs:
      fix_file_path:
        description: '修复文件路径（可选，默认搜索fix.txt）'
        required: false
        default: ''

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: 🛎️ 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔍 查找修复文件
        run: |
          echo "=== 查找修复文件 ==="
          
          # 确定要查找的文件路径
          if [ -n "${{ github.event.inputs.fix_file_path }}" ]; then
            # 使用手动输入的路径
            FIX_FILE="${{ github.event.inputs.fix_file_path }}"
            echo "📁 使用手动指定的修复文件: $FIX_FILE"
          else
            # 搜索所有fix.txt文件
            echo "🔍 搜索修复文件..."
            FIX_FILES=$(find . -name "fix.txt" -type f | grep -v ".git" | head -5)
            
            if [ -z "$FIX_FILES" ]; then
              echo "❌ 没有找到任何fix.txt文件"
              exit 1
            fi
            
            # 选择第一个找到的文件（可以按需调整策略）
            FIX_FILE=$(echo "$FIX_FILES" | head -1)
            echo "📁 找到修复文件: $FIX_FILE"
            
            if [ $(echo "$FIX_FILES" | wc -l) -gt 1 ]; then
              echo "⚠️  找到多个修复文件，使用第一个: $FIX_FILE"
              echo "其他文件:"
              echo "$FIX_FILES" | tail -n +2 | while IFS= read -r file; do
                echo "  - $file"
              done
            fi
          fi
          
          # 验证文件存在
          if [ ! -f "$FIX_FILE" ]; then
            echo "❌ 修复文件不存在: $FIX_FILE"
            exit 1
          fi
          
          echo "✅ 使用修复文件: $FIX_FILE"
          echo "文件路径: $(realpath "$FIX_FILE")"
          
          # 设置环境变量供后续步骤使用
          echo "FIX_FILE_PATH=$FIX_FILE" >> $GITHUB_ENV
      
      - name: 📝 应用修复并推送
        env:
          FIX_FILE: ${{ env.FIX_FILE_PATH }}
        run: |
          echo "=== 应用修复并推送 ==="
          echo "修复文件: $FIX_FILE"
          
          # 1. 读取修复指令
          echo "📖 读取修复指令..."
          FIX_CONTENT=$(cat "$FIX_FILE")
          
          if [ -z "$FIX_CONTENT" ]; then
            echo "⚠️ 修复文件为空，跳过修复"
            
            # 配置Git
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "GitHub Actions"
            
            # 清空修复文件
            > "$FIX_FILE"
            git add "$FIX_FILE"
            git commit -m "🧹 清理空修复文件 [skip ci]" || true
            git push origin HEAD:main
            exit 0
          fi
          
          # 2. 解析修复指令（简化版，避免复杂的正则表达式）
          echo "🔧 解析修复指令..."
          
          # 存储修改过的文件列表
          MODIFIED_FILES=""
          
          # 使用更简单的解析方法
          CURRENT_FILE=""
          SKIP_NEXT_LINES=0
          APPEND_CONTENT=""
          CREATE_FILE=""
          FILE_CONTENT=""
          
          # 逐行处理修复指令
          LINE_NUM=0
          while IFS= read -r LINE || [ -n "$LINE" ]; do
            ((LINE_NUM++))
            
            # 跳过空行和注释
            if [[ -z "$LINE" ]] || [[ "$LINE" =~ ^[[:space:]]*# ]]; then
              continue
            fi
          
            echo "  指令 $LINE_NUM: $LINE"
            
            # 处理之前积累的内容
            if [ $SKIP_NEXT_LINES -gt 0 ]; then
              SKIP_NEXT_LINES=$((SKIP_NEXT_LINES-1))
              continue
            fi
            
            # 处理append积累的内容
            if [ -n "$APPEND_CONTENT" ]; then
              APPEND_CONTENT="${APPEND_CONTENT}${LINE}"$'\n'
              continue
            fi
            
            # 处理create积累的内容
            if [ -n "$CREATE_FILE" ]; then
              FILE_CONTENT="${FILE_CONTENT}${LINE}"$'\n'
              continue
            fi
            
            # 支持的命令格式:
            # file:path/to/file => 要修改的文件
            # replace:pattern##replacement => 文本替换
            # append:path/to/file => 追加内容
            # delete:path/to/file => 删除文件
            # create:path/to/file => 创建文件
            
            # 检查是否以file:开头
            if [[ "$LINE" =~ ^file:[[:space:]]*(.+) ]]; then
              # 设置当前操作的文件
              CURRENT_FILE="${BASH_REMATCH[1]}"
              echo "    目标文件: $CURRENT_FILE"
              
            # 检查是否以replace:开头 - 使用##作为分隔符
            elif [[ "$LINE" =~ ^replace:[[:space:]]*(.+)[[:space:]]*##[[:space:]]*(.+) ]] && [ -n "$CURRENT_FILE" ]; then
              # 文本替换 - 使用##作为分隔符
              PATTERN="${BASH_REMATCH[1]}"
              REPLACEMENT="${BASH_REMATCH[2]}"
              
              if [ -f "$CURRENT_FILE" ]; then
                echo "    替换: '$PATTERN' => '$REPLACEMENT'"
                # 直接替换，不生成临时文件
                sed -i "s|$PATTERN|$REPLACEMENT|g" "$CURRENT_FILE"
                
                # 记录修改
                if [[ ! " $MODIFIED_FILES " =~ " $CURRENT_FILE " ]]; then
                  MODIFIED_FILES="$MODIFIED_FILES $CURRENT_FILE"
                fi
              else
                echo "    ⚠️ 文件不存在: $CURRENT_FILE"
              fi
              
            # 检查是否以append:开头
            elif [[ "$LINE" =~ ^append:[[:space:]]*(.+) ]] && [ -n "$CURRENT_FILE" ]; then
              # 追加内容
              APPEND_FILE="${BASH_REMATCH[1]}"
              if [ -n "$APPEND_FILE" ]; then
                CURRENT_FILE="$APPEND_FILE"
              fi
              
              if [ -f "$CURRENT_FILE" ]; then
                echo "    准备追加内容到: $CURRENT_FILE"
                APPEND_CONTENT=""
                SKIP_NEXT_LINES=0
              fi
              
            # 检查是否以create:开头
            elif [[ "$LINE" =~ ^create:[[:space:]]*(.+) ]]; then
              # 创建文件
              CREATE_FILE="${BASH_REMATCH[1]}"
              echo "    准备创建文件: $CREATE_FILE"
              FILE_CONTENT=""
              SKIP_NEXT_LINES=0
              
            # 检查是否以delete:开头
            elif [[ "$LINE" =~ ^delete:[[:space:]]*(.+) ]]; then
              # 删除文件
              DELETE_FILE="${BASH_REMATCH[1]}"
              echo "    删除文件: $DELETE_FILE"
              
              if [ -f "$DELETE_FILE" ]; then
                rm -f "$DELETE_FILE"
                if [[ ! " $MODIFIED_FILES " =~ " $DELETE_FILE " ]]; then
                  MODIFIED_FILES="$MODIFIED_FILES $DELETE_FILE"
                fi
              fi
              
            # 处理累积的append内容
            elif [ -n "$APPEND_CONTENT" ]; then
              # 检查是否是新的命令
              if [[ "$LINE" =~ ^[a-z]+: ]]; then
                # 是新的命令，处理之前的append内容
                echo "    追加内容到: $CURRENT_FILE"
                echo -n "$APPEND_CONTENT" >> "$CURRENT_FILE"
                
                if [[ ! " $MODIFIED_FILES " =~ " $CURRENT_FILE " ]]; then
                  MODIFIED_FILES="$MODIFIED_FILES $CURRENT_FILE"
                fi
                
                # 重置状态
                APPEND_CONTENT=""
                
                # 重新处理当前行
                ((LINE_NUM--))
                continue
              else
                # 继续积累内容
                APPEND_CONTENT="${APPEND_CONTENT}${LINE}"$'\n'
              fi
              
            # 处理累积的create内容
            elif [ -n "$CREATE_FILE" ]; then
              # 检查是否是新的命令
              if [[ "$LINE" =~ ^[a-z]+: ]]; then
                # 是新的命令，处理之前的create内容
                echo "    创建文件: $CREATE_FILE"
                
                # 创建目录
                mkdir -p "$(dirname "$CREATE_FILE")"
                echo -n "$FILE_CONTENT" > "$CREATE_FILE"
                
                if [[ ! " $MODIFIED_FILES " =~ " $CREATE_FILE " ]]; then
                  MODIFIED_FILES="$MODIFIED_FILES $CREATE_FILE"
                fi
                
                # 重置状态
                CREATE_FILE=""
                FILE_CONTENT=""
                
                # 重新处理当前行
                ((LINE_NUM--))
                continue
              else
                # 继续积累内容
                FILE_CONTENT="${FILE_CONTENT}${LINE}"$'\n'
              fi
            fi
            
          done < "$FIX_FILE"
          
          # 处理最后可能累积的内容
          if [ -n "$APPEND_CONTENT" ] && [ -n "$CURRENT_FILE" ] && [ -f "$CURRENT_FILE" ]; then
            echo "    追加内容到: $CURRENT_FILE"
            echo -n "$APPEND_CONTENT" >> "$CURRENT_FILE"
            
            if [[ ! " $MODIFIED_FILES " =~ " $CURRENT_FILE " ]]; then
              MODIFIED_FILES="$MODIFIED_FILES $CURRENT_FILE"
            fi
          fi
          
          if [ -n "$CREATE_FILE" ] && [ -n "$FILE_CONTENT" ]; then
            echo "    创建文件: $CREATE_FILE"
            
            # 创建目录
            mkdir -p "$(dirname "$CREATE_FILE")"
            echo -n "$FILE_CONTENT" > "$CREATE_FILE"
            
            if [[ ! " $MODIFIED_FILES " =~ " $CREATE_FILE " ]]; then
              MODIFIED_FILES="$MODIFIED_FILES $CREATE_FILE"
            fi
          fi
          
          # 3. 如果有修改，提交并推送
          if [ -n "$MODIFIED_FILES" ]; then
            echo "💾 检测到修改，准备提交..."
            echo "修改的文件:"
            for file in $MODIFIED_FILES; do
              echo "  - $file"
            done
            
            # 配置Git
            git config --local user.email "github-actions[bot]@users.noreply.github.com"
            git config --local user.name "GitHub Actions"
            
            # 构建提交信息
            COMMIT_MSG="🔧 自动修复"
            COMMIT_MSG+="\n\n来源: $FIX_FILE"
            COMMIT_MSG+="\n时间: $(date)"
            COMMIT_MSG+="\n触发: ${{ github.event_name }}"
            
            # 添加修改的文件列表
            if [ -n "$MODIFIED_FILES" ]; then
              COMMIT_MSG+="\n\n修改的文件:"
              for file in $MODIFIED_FILES; do
                COMMIT_MSG+="\n- $file"
              done
            fi
            
            # 添加修复文件内容预览
            COMMIT_MSG+="\n\n修复指令预览:"
            head -10 "$FIX_FILE" | while IFS= read -r line; do
              COMMIT_MSG+="\n  $line"
            done
            if [ $(wc -l < "$FIX_FILE") -gt 10 ]; then
              COMMIT_MSG+="\n  ...（还有更多）"
            fi
            
            # 提交所有修改
            echo -e "$COMMIT_MSG" | git commit -a -F -
            
            # 4. 推送更改
            echo "🚀 推送到主分支..."
            git push origin HEAD:main
            
            echo "✅ 修复已应用并推送"
          else
            echo "⚠️ 没有检测到有效的修改"
          fi
          
          # 5. 清理修复文件
          echo "🧹 清理修复文件..."
          > "$FIX_FILE"
          git add "$FIX_FILE"
          git commit -m "🧹 清理修复文件: $(basename "$FIX_FILE") [skip ci]" || true
          git push origin HEAD:main
      
      - name: 📋 生成报告
        if: always()
        run: |
          echo "## 🔧 自动修复完成" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "**状态:** ✅ 成功" >> $GITHUB_STEP_SUMMARY
          else
            echo "**状态:** ❌ 失败" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "**时间:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**修复文件:** ${{ env.FIX_FILE_PATH }}" >> $GITHUB_STEP_SUMMARY
          echo "**触发方式:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 显示最后的状态
          if [ -n "${{ env.FIX_FILE_PATH }}" ]; then
            echo "### 📊 执行结果" >> $GITHUB_STEP_SUMMARY
            echo "1. ✅ 查找修复文件: ${{ env.FIX_FILE_PATH }}" >> $GITHUB_STEP_SUMMARY
            echo "2. ✅ 解析修复指令: 完成" >> $GITHUB_STEP_SUMMARY
            echo "3. ✅ 应用修复: 完成" >> $GITHUB_STEP_SUMMARY
            echo "4. ✅ 提交更改: 完成" >> $GITHUB_STEP_SUMMARY
            echo "5. ✅ 清理工作: 完成" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # 显示修复文件位置信息
            echo "### 📁 文件位置" >> $GITHUB_STEP_SUMMARY
            echo "- **修复文件:** \`${{ env.FIX_FILE_PATH }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- **仓库根目录:** \`$(pwd)\`" >> $GITHUB_STEP_SUMMARY
            echo "- **相对路径:** \`${{ env.FIX_FILE_PATH }}\`" >> $GITHUB_STEP_SUMMARY
          fi

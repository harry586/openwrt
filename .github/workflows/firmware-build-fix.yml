name: 🔧 全自动修复系统

on:
  push:
    paths:
      - '**/fix.txt'
      - '**/fix.md'
      - '**/fixes/**'
      - '.github/workflows/auto-fix.yml'
      - '.github/workflows/*-fix.yml'
  workflow_dispatch:
    inputs:
      force_run:
        description: '强制运行（即使没有检测到更改）'
        required: false
        default: false
        type: boolean
      dry_run:
        description: '试运行（只显示计划，不实际修改）'
        required: false
        default: false
        type: boolean

jobs:
  auto-fix-and-commit:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: 🛎️ 检出代码仓库
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔍 分析修复文件（正确解析格式）
        id: analyze_fixes
        run: |
          echo "=== 🔍 分析修复文件（正确解析格式）==="
          
          # 查找修复文件
          FIX_FILE=$(find . -name "fix.txt" -not -path "./.git/*" | head -1)
          if [ -z "$FIX_FILE" ]; then
            FIX_FILE=$(find . -name "fix.md" -not -path "./.git/*" | head -1)
          fi
          
          if [ -z "$FIX_FILE" ]; then
            echo "❌ 未找到修复文件"
            exit 1
          fi
          
          echo "✅ 找到修复文件: $FIX_FILE"
          
          # 显示修复文件内容
          echo "📄 修复文件内容:"
          echo "---"
          cat "$FIX_FILE"
          echo "---"
          
          # 正确解析修复格式
          echo ""
          echo "🔎 解析修复格式..."
          
          # 提取所有修复标识
          IDENTIFIERS=$(grep -n "^#【" "$FIX_FILE" | sed 's/:/#SEP#/')
          
          if [ -z "$IDENTIFIERS" ]; then
            echo "❌ 未找到修复标识"
            exit 1
          fi
          
          echo "✅ 找到修复标识:"
          echo "$IDENTIFIERS"
          
          # 统计不同类型的修复
          WORKFLOW_FIXES=0
          SCRIPT_FIXES=0
          WORKFLOW_FILES=""
          SCRIPT_FILES=""
          
          while IFS= read -r identifier_line; do
            # 提取行号和标识内容
            line_num=$(echo "$identifier_line" | cut -d'#' -f1)
            identifier=$(echo "$identifier_line" | sed 's/.*#SEP#//')
            
            echo "标识 [$line_num]: $identifier"
            
            # 解析标识格式
            if [[ "$identifier" =~ ^#【([^】]+)】 ]]; then
              target="${BASH_REMATCH[1]}"
              echo "目标: $target"
              
              # 判断修复类型
              if [[ "$target" == *.yml* ]]; then
                WORKFLOW_FIXES=$((WORKFLOW_FIXES + 1))
                if ! echo "$WORKFLOW_FILES" | grep -q "firmware-build.yml"; then
                  WORKFLOW_FILES="$WORKFLOW_FILES firmware-build.yml"
                fi
                echo "类型: 工作流修复"
              elif [[ "$target" == *.sh* ]]; then
                SCRIPT_FIXES=$((SCRIPT_FIXES + 1))
                if ! echo "$SCRIPT_FILES" | grep -q "build_firmware_main.sh"; then
                  SCRIPT_FILES="$SCRIPT_FILES build_firmware_main.sh"
                fi
                echo "类型: 脚本修复"
              else
                echo "类型: 其他"
              fi
            fi
          done <<< "$IDENTIFIERS"
          
          echo ""
          echo "📊 修复统计:"
          echo "- 总修复标识: $(echo "$IDENTIFIERS" | wc -l)"
          echo "- 工作流修复: $WORKFLOW_FIXES"
          echo "- 脚本修复: $SCRIPT_FIXES"
          echo "- 需要修改的工作流文件: $WORKFLOW_FILES"
          echo "- 需要修改的脚本文件: $SCRIPT_FILES"
          
          # 输出到环境变量
          echo "fix_file=$FIX_FILE" >> $GITHUB_OUTPUT
          echo "identifiers_count=$((WORKFLOW_FIXES + SCRIPT_FIXES))" >> $GITHUB_OUTPUT
          echo "workflow_fixes_count=$WORKFLOW_FIXES" >> $GITHUB_OUTPUT
          echo "script_fixes_count=$SCRIPT_FIXES" >> $GITHUB_OUTPUT
          echo "workflow_files=${WORKFLOW_FILES# }" >> $GITHUB_OUTPUT
          echo "script_files=${SCRIPT_FILES# }" >> $GITHUB_OUTPUT
          echo "has_fix_file=true" >> $GITHUB_OUTPUT
      
      - name: 🛠️ 应用工作流修复（正确实现）
        id: apply_workflow_fixes
        if: steps.analyze_fixes.outputs.workflow_fixes_count != '0'
        run: |
          echo "=== 🛠️ 应用工作流修复 ==="
          
          FIX_FILE="${{ steps.analyze_fixes.outputs.fix_file }}"
          DRY_RUN="${{ inputs.dry_run }}"
          MODIFIED_WORKFLOWS=""
          
          echo "修复文件: $FIX_FILE"
          echo "需要修改的工作流文件: ${{ steps.analyze_fixes.outputs.workflow_files }}"
          
          # 获取工作流文件路径
          WORKFLOW_FILE=".github/workflows/firmware-build.yml"
          if [ ! -f "$WORKFLOW_FILE" ]; then
            echo "❌ 找不到工作流文件: $WORKFLOW_FILE"
            exit 1
          fi
          
          echo "✅ 找到工作流文件: $WORKFLOW_FILE"
          echo ""
          echo "📄 工作流文件原始内容（前10行）:"
          head -10 "$WORKFLOW_FILE"
          echo "..."
          echo ""
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "🟡 DRY RUN 模式：只显示修改计划"
            echo ""
            
            # 分析所有工作流相关的修复
            echo "🔍 分析工作流修复计划:"
            grep -n "^#【firmware-build.yml" "$FIX_FILE" | while read -r line; do
              line_num=$(echo "$line" | cut -d: -f1)
              identifier=$(echo "$line" | cut -d: -f2-)
              
              echo ""
              echo "标识 [$line_num]: $identifier"
              
              # 提取步骤号
              if [[ "$identifier" =~ firmware-build.yml-([0-9]+) ]]; then
                step_num="${BASH_REMATCH[1]}"
                echo "目标步骤: $step_num"
                
                # 查找步骤在文件中的位置
                echo "🔎 在当前工作流文件中查找步骤 $step_num..."
                
                # 查找步骤名包含步骤号的行
                step_line=$(grep -n "name:.*$step_num\." "$WORKFLOW_FILE" | head -1 | cut -d: -f1)
                if [ -n "$step_line" ]; then
                  echo "✅ 找到步骤 $step_num 在第 $step_line 行"
                  echo "当前步骤内容:"
                  sed -n "${step_line},+5p" "$WORKFLOW_FILE"
                else
                  echo "⚠️ 未找到步骤 $step_num，可能是新步骤"
                fi
              fi
            done
            
            echo ""
            echo "📋 DRY RUN 完成 - 无实际修改"
            echo "modified_workflows=dry-run" >> $GITHUB_OUTPUT
            
          else
            echo "🟢 实际修复模式：将修改工作流文件"
            echo ""
            
            # 创建备份
            BACKUP_FILE="${WORKFLOW_FILE}.backup.$(date +%s)"
            cp "$WORKFLOW_FILE" "$BACKUP_FILE"
            echo "📦 创建备份: $BACKUP_FILE"
            
            # 提取所有工作流修复内容
            echo "🔍 提取工作流修复内容..."
            
            # 读取修复文件，处理每个修复块
            TEMP_FILE="${WORKFLOW_FILE}.temp"
            cp "$WORKFLOW_FILE" "$TEMP_FILE"
            
            CURRENT_LINE=0
            IN_WORKFLOW_FIX=false
            CURRENT_STEP=""
            FIX_CONTENT=""
            
            while IFS= read -r line; do
              CURRENT_LINE=$((CURRENT_LINE + 1))
              
              # 检查是否是工作流修复标识
              if [[ "$line" =~ ^#【(firmware-build.yml-[0-9]+)】 ]]; then
                IN_WORKFLOW_FIX=true
                CURRENT_STEP="${BASH_REMATCH[1]}"
                FIX_CONTENT=""
                echo "🎯 开始处理修复: $CURRENT_STEP (第 $CURRENT_LINE 行)"
                
              elif [[ "$line" =~ ^#【end】 ]] || [[ "$line" =~ ^#【结束】 ]]; then
                # 修复块结束，应用修复
                if [ "$IN_WORKFLOW_FIX" = true ] && [ -n "$CURRENT_STEP" ] && [ -n "$FIX_CONTENT" ]; then
                  echo "🔄 应用修复块: $CURRENT_STEP"
                  echo "修复内容大小: ${#FIX_CONTENT} 字符"
                  
                  # 提取步骤号
                  if [[ "$CURRENT_STEP" =~ firmware-build.yml-([0-9]+) ]]; then
                    STEP_NUM="${BASH_REMATCH[1]}"
                    echo "目标步骤号: $STEP_NUM"
                    
                    # 在工作流文件中查找该步骤
                    echo "🔍 在工作流文件中查找步骤 $STEP_NUM..."
                    
                    # 先查找步骤开始行
                    STEP_START_LINE=$(grep -n "name:.*$STEP_NUM\." "$TEMP_FILE" | head -1 | cut -d: -f1)
                    
                    if [ -n "$STEP_START_LINE" ]; then
                      echo "✅ 找到步骤 $STEP_NUM 在第 $STEP_START_LINE 行"
                      
                      # 查找步骤结束（下一个步骤开始或文件结束）
                      TOTAL_LINES=$(wc -l < "$TEMP_FILE")
                      STEP_END_LINE=$TOTAL_LINES
                      
                      for ((i=STEP_START_LINE+1; i<=TOTAL_LINES; i++)); do
                        line_content=$(sed -n "${i}p" "$TEMP_FILE")
                        if [[ "$line_content" =~ ^[[:space:]]*-[[:space:]]*name: ]] && [ "$i" -gt "$STEP_START_LINE" ]; then
                          STEP_END_LINE=$((i-1))
                          break
                        fi
                      done
                      
                      echo "步骤范围: $STEP_START_LINE - $STEP_END_LINE"
                      
                      # 创建新版本的文件
                      NEW_TEMP_FILE="${TEMP_FILE}.new"
                      
                      # 复制步骤前的部分
                      head -n $((STEP_START_LINE-1)) "$TEMP_FILE" > "$NEW_TEMP_FILE"
                      
                      # 添加修复内容
                      echo "# ===== 自动修复开始 =====" >> "$NEW_TEMP_FILE"
                      echo "# 修复时间: $(date)" >> "$NEW_TEMP_FILE"
                      echo "# 来源: $FIX_FILE" >> "$NEW_TEMP_FILE"
                      echo "$FIX_CONTENT" >> "$NEW_TEMP_FILE"
                      echo "# ===== 自动修复结束 =====" >> "$NEW_TEMP_FILE"
                      
                      # 复制步骤后的部分
                      tail -n +$((STEP_END_LINE+1)) "$TEMP_FILE" >> "$NEW_TEMP_FILE"
                      
                      # 替换临时文件
                      mv "$NEW_TEMP_FILE" "$TEMP_FILE"
                      
                      echo "✅ 已替换步骤 $STEP_NUM"
                      MODIFIED_WORKFLOWS="$WORKFLOW_FILE"
                    else
                      echo "⚠️ 未找到步骤 $STEP_NUM，尝试作为新步骤添加"
                      
                      # 在文件末尾添加新步骤
                      echo "" >> "$TEMP_FILE"
                      echo "# ===== 自动添加新步骤 =====" >> "$TEMP_FILE"
                      echo "# 添加时间: $(date)" >> "$TEMP_FILE"
                      echo "# 来源: $FIX_FILE" >> "$TEMP_FILE"
                      echo "$FIX_CONTENT" >> "$TEMP_FILE"
                      echo "# ===== 新步骤结束 =====" >> "$TEMP_FILE"
                      
                      echo "✅ 已添加新步骤 $STEP_NUM"
                      MODIFIED_WORKFLOWS="$WORKFLOW_FILE"
                    fi
                  fi
                fi
                
                IN_WORKFLOW_FIX=false
                CURRENT_STEP=""
                FIX_CONTENT=""
                
              elif [ "$IN_WORKFLOW_FIX" = true ]; then
                # 累积修复内容
                FIX_CONTENT="${FIX_CONTENT}${line}"$'\n'
              fi
              
            done < "$FIX_FILE"
            
            # 如果有修改，替换原文件
            if [ -n "$MODIFIED_WORKFLOWS" ]; then
              echo ""
              echo "📝 检查修改差异..."
              if diff -u "$BACKUP_FILE" "$TEMP_FILE"; then
                echo "⚠️ 实际上没有差异，不替换文件"
              else
                echo "✅ 发现差异，替换工作流文件"
                mv "$TEMP_FILE" "$WORKFLOW_FILE"
                echo "✅ 工作流文件已更新"
              fi
            else
              echo "📭 没有工作流文件被修改"
            fi
            
            # 清理临时文件
            rm -f "$TEMP_FILE" "${TEMP_FILE}.new" 2>/dev/null || true
            
            echo "modified_workflows=${MODIFIED_WORKFLOWS}" >> $GITHUB_OUTPUT
          fi
      
      - name: 🛠️ 应用脚本修复（正确实现）
        id: apply_script_fixes
        if: steps.analyze_fixes.outputs.script_fixes_count != '0'
        run: |
          echo "=== 🛠️ 应用脚本修复 ==="
          
          FIX_FILE="${{ steps.analyze_fixes.outputs.fix_file }}"
          DRY_RUN="${{ inputs.dry_run }}"
          MODIFIED_SCRIPTS=""
          
          echo "修复文件: $FIX_FILE"
          echo "需要修改的脚本文件: ${{ steps.analyze_fixes.outputs.script_files }}"
          
          # 获取脚本文件路径
          SCRIPT_FILE="firmware-config/scripts/build_firmware_main.sh"
          if [ ! -f "$SCRIPT_FILE" ]; then
            echo "❌ 找不到脚本文件: $SCRIPT_FILE"
            exit 1
          fi
          
          echo "✅ 找到脚本文件: $SCRIPT_FILE"
          echo ""
          echo "📄 脚本文件原始内容（前10行）:"
          head -10 "$SCRIPT_FILE"
          echo "..."
          echo ""
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "🟡 DRY RUN 模式：只显示修改计划"
            echo ""
            
            # 分析所有脚本相关的修复
            echo "🔍 分析脚本修复计划:"
            grep -n "^#【build_firmware_main.sh" "$FIX_FILE" | while read -r line; do
              line_num=$(echo "$line" | cut -d: -f1)
              identifier=$(echo "$line" | cut -d: -f2-)
              
              echo ""
              echo "标识 [$line_num]: $identifier"
              
              # 提取函数号
              if [[ "$identifier" =~ build_firmware_main.sh-([0-9]+) ]]; then
                func_num="${BASH_REMATCH[1]}"
                echo "目标函数编号: $func_num"
                
                # 查找函数在文件中的位置
                echo "🔎 在当前脚本文件中查找相关函数..."
                
                # 尝试查找对应的函数
                case $func_num in
                  03)
                    echo "目标: save_env 函数"
                    func_line=$(grep -n "^save_env()" "$SCRIPT_FILE" | head -1 | cut -d: -f1)
                    ;;
                  14)
                    echo "目标: initialize_compiler_env 函数"
                    func_line=$(grep -n "^initialize_compiler_env()" "$SCRIPT_FILE" | head -1 | cut -d: -f1)
                    ;;
                  *)
                    echo "未知函数编号: $func_num"
                    continue
                    ;;
                esac
                
                if [ -n "$func_line" ]; then
                  echo "✅ 找到函数在第 $func_line 行"
                  echo "当前函数内容（前10行）:"
                  sed -n "${func_line},+10p" "$SCRIPT_FILE"
                else
                  echo "⚠️ 未找到函数，可能是新函数"
                fi
              fi
            done
            
            echo ""
            echo "📋 DRY RUN 完成 - 无实际修改"
            echo "modified_scripts=dry-run" >> $GITHUB_OUTPUT
            
          else
            echo "🟢 实际修复模式：将修改脚本文件"
            echo ""
            
            # 创建备份
            BACKUP_FILE="${SCRIPT_FILE}.backup.$(date +%s)"
            cp "$SCRIPT_FILE" "$BACKUP_FILE"
            echo "📦 创建备份: $BACKUP_FILE"
            
            # 提取所有脚本修复内容
            echo "🔍 提取脚本修复内容..."
            
            # 读取修复文件，处理每个修复块
            TEMP_FILE="${SCRIPT_FILE}.temp"
            cp "$SCRIPT_FILE" "$TEMP_FILE"
            
            CURRENT_LINE=0
            IN_SCRIPT_FIX=false
            CURRENT_FUNC=""
            FIX_CONTENT=""
            
            while IFS= read -r line; do
              CURRENT_LINE=$((CURRENT_LINE + 1))
              
              # 检查是否是脚本修复标识
              if [[ "$line" =~ ^#【(build_firmware_main.sh-[0-9]+)】 ]]; then
                IN_SCRIPT_FIX=true
                CURRENT_FUNC="${BASH_REMATCH[1]}"
                FIX_CONTENT=""
                echo "🎯 开始处理修复: $CURRENT_FUNC (第 $CURRENT_LINE 行)"
                
              elif [[ "$line" =~ ^#【end】 ]] || [[ "$line" =~ ^#【结束】 ]]; then
                # 修复块结束，应用修复
                if [ "$IN_SCRIPT_FIX" = true ] && [ -n "$CURRENT_FUNC" ] && [ -n "$FIX_CONTENT" ]; then
                  echo "🔄 应用修复块: $CURRENT_FUNC"
                  echo "修复内容大小: ${#FIX_CONTENT} 字符"
                  
                  # 提取函数号
                  if [[ "$CURRENT_FUNC" =~ build_firmware_main.sh-([0-9]+) ]]; then
                    FUNC_NUM="${BASH_REMATCH[1]}"
                    echo "目标函数编号: $FUNC_NUM"
                    
                    # 确定目标函数名
                    case $FUNC_NUM in
                      03)
                        TARGET_FUNC="save_env()"
                        ;;
                      14)
                        TARGET_FUNC="initialize_compiler_env()"
                        ;;
                      *)
                        echo "⚠️ 未知函数编号: $FUNC_NUM，跳过"
                        continue
                        ;;
                    esac
                    
                    echo "目标函数: $TARGET_FUNC"
                    
                    # 在脚本文件中查找该函数
                    echo "🔍 在脚本文件中查找函数 $TARGET_FUNC..."
                    
                    # 查找函数开始行
                    FUNC_START_LINE=$(grep -n "^$TARGET_FUNC" "$TEMP_FILE" | head -1 | cut -d: -f1)
                    
                    if [ -n "$FUNC_START_LINE" ]; then
                      echo "✅ 找到函数 $TARGET_FUNC 在第 $FUNC_START_LINE 行"
                      
                      # 查找函数结束（下一个函数开始或文件结束）
                      TOTAL_LINES=$(wc -l < "$TEMP_FILE")
                      FUNC_END_LINE=$TOTAL_LINES
                      
                      for ((i=FUNC_START_LINE+1; i<=TOTAL_LINES; i++)); do
                        line_content=$(sed -n "${i}p" "$TEMP_FILE")
                        if [[ "$line_content" =~ ^[a-zA-Z_][a-zA-Z0-9_]*\(\) ]]; then
                          FUNC_END_LINE=$((i-1))
                          break
                        fi
                      done
                      
                      echo "函数范围: $FUNC_START_LINE - $FUNC_END_LINE"
                      
                      # 创建新版本的文件
                      NEW_TEMP_FILE="${TEMP_FILE}.new"
                      
                      # 复制函数前的部分
                      head -n $((FUNC_START_LINE-1)) "$TEMP_FILE" > "$NEW_TEMP_FILE"
                      
                      # 添加修复内容
                      echo "# ===== 自动修复开始 =====" >> "$NEW_TEMP_FILE"
                      echo "# 修复时间: $(date)" >> "$NEW_TEMP_FILE"
                      echo "# 来源: $FIX_FILE" >> "$NEW_TEMP_FILE"
                      echo "$FIX_CONTENT" >> "$NEW_TEMP_FILE"
                      echo "# ===== 自动修复结束 =====" >> "$NEW_TEMP_FILE"
                      
                      # 复制函数后的部分
                      tail -n +$((FUNC_END_LINE+1)) "$TEMP_FILE" >> "$NEW_TEMP_FILE"
                      
                      # 替换临时文件
                      mv "$NEW_TEMP_FILE" "$TEMP_FILE"
                      
                      echo "✅ 已替换函数 $TARGET_FUNC"
                      MODIFIED_SCRIPTS="$SCRIPT_FILE"
                    else
                      echo "⚠️ 未找到函数 $TARGET_FUNC，尝试作为新函数添加"
                      
                      # 在文件末尾添加新函数
                      echo "" >> "$TEMP_FILE"
                      echo "# ===== 自动添加新函数 =====" >> "$TEMP_FILE"
                      echo "# 添加时间: $(date)" >> "$TEMP_FILE"
                      echo "# 来源: $FIX_FILE" >> "$TEMP_FILE"
                      echo "$FIX_CONTENT" >> "$TEMP_FILE"
                      echo "# ===== 新函数结束 =====" >> "$TEMP_FILE"
                      
                      echo "✅ 已添加新函数 $TARGET_FUNC"
                      MODIFIED_SCRIPTS="$SCRIPT_FILE"
                    fi
                  fi
                fi
                
                IN_SCRIPT_FIX=false
                CURRENT_FUNC=""
                FIX_CONTENT=""
                
              elif [ "$IN_SCRIPT_FIX" = true ]; then
                # 累积修复内容
                FIX_CONTENT="${FIX_CONTENT}${line}"$'\n'
              fi
              
            done < "$FIX_FILE"
            
            # 如果有修改，替换原文件
            if [ -n "$MODIFIED_SCRIPTS" ]; then
              echo ""
              echo "📝 检查修改差异..."
              if diff -u "$BACKUP_FILE" "$TEMP_FILE"; then
                echo "⚠️ 实际上没有差异，不替换文件"
              else
                echo "✅ 发现差异，替换脚本文件"
                mv "$TEMP_FILE" "$SCRIPT_FILE"
                echo "✅ 脚本文件已更新"
              fi
            else
              echo "📭 没有脚本文件被修改"
            fi
            
            # 清理临时文件
            rm -f "$TEMP_FILE" "${TEMP_FILE}.new" 2>/dev/null || true
            
            echo "modified_scripts=${MODIFIED_SCRIPTS}" >> $GITHUB_OUTPUT
          fi
      
      - name: 📊 显示修复结果详情
        if: always()
        run: |
          echo "=== 📊 修复结果详情 ==="
          echo ""
          
          echo "📋 修复统计:"
          echo "- 修复文件: ${{ steps.analyze_fixes.outputs.fix_file }}"
          echo "- 总修复标识: ${{ steps.analyze_fixes.outputs.identifiers_count }}"
          echo "- 工作流修复: ${{ steps.analyze_fixes.outputs.workflow_fixes_count }}"
          echo "- 脚本修复: ${{ steps.analyze_fixes.outputs.script_fixes_count }}"
          echo ""
          
          echo "🛠️ 修复执行状态:"
          echo "- 工作流修复结果: ${{ steps.apply_workflow_fixes.outputs.modified_workflows }}"
          echo "- 脚本修复结果: ${{ steps.apply_script_fixes.outputs.modified_scripts }}"
          echo ""
          
          # 显示修改的文件
          echo "📝 实际修改的文件:"
          if [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" != "" ] && [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" != "dry-run" ]; then
            echo "- 工作流文件: ${{ steps.apply_workflow_fixes.outputs.modified_workflows }}"
          fi
          
          if [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" != "" ] && [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" != "dry-run" ]; then
            echo "- 脚本文件: ${{ steps.apply_script_fixes.outputs.modified_scripts }}"
          fi
          
          if [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" == "" ] && [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" == "" ]; then
            echo "- 无文件被修改"
          fi
          echo ""
          
          # 显示当前Git状态
          echo "🔍 Git 状态:"
          git status --short || echo "无法获取Git状态"
          echo ""
          
          echo "📄 检测到的更改:"
          git diff --name-only 2>/dev/null || echo "无更改"
      
      - name: 💾 自动提交更改
        id: commit_changes
        if: |
          (steps.apply_workflow_fixes.outputs.modified_workflows != '' && 
           steps.apply_workflow_fixes.outputs.modified_workflows != 'dry-run') ||
          (steps.apply_script_fixes.outputs.modified_scripts != '' && 
           steps.apply_script_fixes.outputs.modified_scripts != 'dry-run')
        run: |
          echo "=== 💾 自动提交更改 ==="
          
          # 配置Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # 显示状态
          echo "📊 Git 状态:"
          git status
          echo ""
          
          # 添加修改的文件
          echo "➕ 添加修改的文件..."
          
          if [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" != "" ] && [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" != "dry-run" ]; then
            git add "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}"
            echo "✅ 添加工作流文件"
          fi
          
          if [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" != "" ] && [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" != "dry-run" ]; then
            git add "${{ steps.apply_script_fixes.outputs.modified_scripts }}"
            echo "✅ 添加脚本文件"
          fi
          
          # 生成提交信息
          COMMIT_MSG="🔧 自动修复: "
          
          if [ "${{ steps.analyze_fixes.outputs.workflow_fixes_count }}" != "0" ]; then
            COMMIT_MSG="${COMMIT_MSG}工作流(${{ steps.analyze_fixes.outputs.workflow_fixes_count }})"
          fi
          
          if [ "${{ steps.analyze_fixes.outputs.script_fixes_count }}" != "0" ]; then
            if [ "${{ steps.analyze_fixes.outputs.workflow_fixes_count }}" != "0" ]; then
              COMMIT_MSG="${COMMIT_MSG} + "
            fi
            COMMIT_MSG="${COMMIT_MSG}脚本(${{ steps.analyze_fixes.outputs.script_fixes_count }})"
          fi
          
          COMMIT_MSG="${COMMIT_MSG} [skip ci]"
          
          echo "📋 提交信息: $COMMIT_MSG"
          
          # 提交
          git commit -m "$COMMIT_MSG"
          
          # 显示提交详情
          echo "📄 提交详情:"
          git log -1 --pretty=fuller
          echo ""
          
          # 推送
          echo "🚀 推送到仓库..."
          git push
          
          echo "✅ 更改已提交并推送"
      
      - name: 📋 生成详细报告
        if: always()
        run: |
          echo "### 📋 全自动修复系统详细报告" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 基本信息
          echo "#### 📅 基本信息" >> $GITHUB_STEP_SUMMARY
          echo "- **执行时间:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "- **触发方式:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **触发分支:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **工作流ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 修复分析
          echo "#### 📊 修复分析" >> $GITHUB_STEP_SUMMARY
          echo "- **修复文件:** \`${{ steps.analyze_fixes.outputs.fix_file }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **修复标识总数:** ${{ steps.analyze_fixes.outputs.identifiers_count }} 个" >> $GITHUB_STEP_SUMMARY
          echo "- **工作流修复数量:** ${{ steps.analyze_fixes.outputs.workflow_fixes_count }} 个" >> $GITHUB_STEP_SUMMARY
          echo "- **脚本修复数量:** ${{ steps.analyze_fixes.outputs.script_fixes_count }} 个" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 操作模式
          echo "#### 🔧 操作模式" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "🟡 **DRY RUN (试运行)**" >> $GITHUB_STEP_SUMMARY
            echo "> 只显示修改计划，不实际修改文件" >> $GITHUB_STEP_SUMMARY
          else
            echo "🟢 **实际修复**" >> $GITHUB_STEP_SUMMARY
            echo "> 文件已被实际修改" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 修复结果
          echo "#### 📝 修复结果" >> $GITHUB_STEP_SUMMARY
          
          MODIFIED_FILES=""
          
          if [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" != "" ] && [ "${{ steps.apply_workflow_fixes.outputs.modified_workflows }}" != "dry-run" ]; then
            MODIFIED_FILES="$MODIFIED_FILES ${{ steps.apply_workflow_fixes.outputs.modified_workflows }}"
          fi
          
          if [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" != "" ] && [ "${{ steps.apply_script_fixes.outputs.modified_scripts }}" != "dry-run" ]; then
            MODIFIED_FILES="$MODIFIED_FILES ${{ steps.apply_script_fixes.outputs.modified_scripts }}"
          fi
          
          if [ -n "$MODIFIED_FILES" ]; then
            echo "✅ **以下文件已被修改:**" >> $GITHUB_STEP_SUMMARY
            for file in $MODIFIED_FILES; do
              echo "- \`$file\`" >> $GITHUB_STEP_SUMMARY
              
              # 显示文件修改时间
              if [ -f "$file" ]; then
                MTIME=$(stat -c %y "$file" 2>/dev/null || stat -f %Sm "$file" 2>/dev/null || echo "未知")
                echo "  📅 修改时间: $MTIME" >> $GITHUB_STEP_SUMMARY
              fi
            done
          else
            echo "📭 **无文件被修改**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 提交状态
          echo "#### 📤 提交状态" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ inputs.dry_run }}" == "true" ]]; then
            echo "🟡 **试运行模式，无提交**" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.commit_changes.outcome }}" == "skipped" ]]; then
            echo "📭 **无修改或不需要提交**" >> $GITHUB_STEP_SUMMARY
          else
            echo "✅ **已自动提交并推送**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**提交信息:**" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "🔧 自动修复: " >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.analyze_fixes.outputs.workflow_fixes_count }}" != "0" ]; then
              echo "工作流(${{ steps.analyze_fixes.outputs.workflow_fixes_count }})" >> $GITHUB_STEP_SUMMARY
            fi
            if [ "${{ steps.analyze_fixes.outputs.script_fixes_count }}" != "0" ]; then
              if [ "${{ steps.analyze_fixes.outputs.workflow_fixes_count }}" != "0" ]; then
                echo " + " >> $GITHUB_STEP_SUMMARY
              fi
              echo "脚本(${{ steps.analyze_fixes.outputs.script_fixes_count }})" >> $GITHUB_STEP_SUMMARY
            fi
            echo " [skip ci]" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 详细日志链接
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "#### 🔗 详细日志" >> $GITHUB_STEP_SUMMARY
          echo "查看完整的执行日志和调试信息：" >> $GITHUB_STEP_SUMMARY
          echo "- [工作流运行详情](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

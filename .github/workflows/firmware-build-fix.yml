# firmware-build-fix.yml
name: 🔧 系统性标识修复系统

on:
  push:
    paths:
      - 'fix.txt'
  workflow_dispatch:
    inputs:
      action:
        description: "🔧 选择操作类型"
        required: false
        default: "apply"
        type: choice
        options:
          - "apply"
          - "restore"

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: 🛎️ 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔧 设置操作类型
        id: set_action
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.action }}" = "restore" ]; then
            echo "ACTION_TYPE=restore" >> $GITHUB_ENV
          else
            echo "ACTION_TYPE=apply" >> $GITHUB_ENV
          fi
          
      - name: 📁 查找目标文件
        run: |
          echo "=== 查找目标文件 ==="
          
          # 定义可能的文件位置
          POSSIBLE_PATHS=(
            "firmware-config/scripts/build_firmware_main.sh"
            "scripts/build_firmware_main.sh"
            "build_firmware_main.sh"
          )
          
          TARGET_FILE=""
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              TARGET_FILE="$path"
              break
            fi
          done
          
          # 如果没找到，使用find搜索
          if [ -z "$TARGET_FILE" ]; then
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "❌ 未找到 build_firmware_main.sh 文件"
            exit 1
          fi
          
          echo "✅ 目标文件: $TARGET_FILE"
          echo "TARGET_FILE=$TARGET_FILE" >> $GITHUB_ENV
          
      # ============ 修复操作 ============
      - name: 🔍 验证修复文件
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 验证修复文件 ==="
          
          if [ ! -f "fix.txt" ]; then
            echo "❌ 没有找到修复文件 fix.txt"
            exit 1
          fi
          
          # 验证系统性标识格式
          if ! grep -q "#【build_firmware_main.sh-" fix.txt; then
            echo "❌ 修复文件中未找到正确的系统性标识格式"
            echo "💡 标识格式应为: #【build_firmware_main.sh-序号】"
            exit 1
          fi
          
          echo "✅ 修复文件验证通过"
          echo "📊 文件大小: $(wc -l < fix.txt) 行"
          
      - name: 💾 备份原始文件
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 备份原始文件 ==="
          
          # 创建备份目录
          mkdir -p ".github/backups"
          
          # 备份文件路径
          BACKUP_FILE=".github/backups/build_firmware_main.sh.$(date +%Y%m%d_%H%M%S).backup"
          
          # 备份原始文件
          cp "$TARGET_FILE" "$BACKUP_FILE"
          
          echo "✅ 原始文件已备份到: $BACKUP_FILE"
          echo "BACKUP_FILE=$BACKUP_FILE" >> $GITHUB_ENV
          
      - name: 🛠️ 基于标识进行整体替换
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 基于标识进行整体替换 ==="
          
          # 读取原始文件内容
          ORIGINAL_CONTENT=$(cat "$TARGET_FILE")
          FIX_CONTENT=$(cat "fix.txt")
          
          # 提取fix.txt中的所有标识
          IDENTIFIERS=()
          while IFS= read -r line; do
            if [[ "$line" =~ ^#【build_firmware_main.sh-[0-9]+】 ]]; then
              IDENTIFIERS+=("$line")
            fi
          done < "fix.txt"
          
          echo "📋 找到的标识:"
          printf '%s\n' "${IDENTIFIERS[@]}"
          
          # 处理每个标识
          RESULT_CONTENT="$ORIGINAL_CONTENT"
          
          for IDENTIFIER in "${IDENTIFIERS[@]}"; do
            echo "🔨 处理标识: $IDENTIFIER"
            
            # 转义标识用于正则表达式
            ESCAPED_IDENTIFIER=$(echo "$IDENTIFIER" | sed 's/[][\\.*^$]/\\&/g')
            
            # 提取fix.txt中该标识对应的代码块
            # 从当前标识开始，到下一个标识或文件结束
            BLOCK_CONTENT=$(awk -v id="$IDENTIFIER" '
              BEGIN {found=0; block=""}
              $0 == id {found=1}
              found && /^#【build_firmware_main.sh-[0-9]+】/ && !first_match {first_match=1; next}
              found && first_match && /^#【build_firmware_main.sh-[0-9]+】/ {exit}
              found && first_match {block=block $0 "\n"}
              END {print block}
            ' fix.txt)
            
            # 检查原始文件中是否有该标识
            if echo "$ORIGINAL_CONTENT" | grep -q "^$ESCAPED_IDENTIFIER"; then
              echo "✅ 在原始文件中找到标识，执行替换"
              
              # 使用更简单的方法：读取整个文件，替换标识行
              awk -v id="$IDENTIFIER" -v new_block="$BLOCK_CONTENT" '
                BEGIN {in_block=0; printed=0}
                
                # 如果找到标识行，开始输出新内容
                $0 == id {
                  print id
                  print new_block
                  in_block=1
                  printed=1
                  next
                }
                
                # 如果在上一个标识块中，跳过原始内容直到下一个标识
                in_block && /^#【build_firmware_main.sh-[0-9]+】/ {
                  in_block=0
                }
                
                in_block { next }
                
                !printed { print }
              ' "$TARGET_FILE" > "$TARGET_FILE.tmp"
              
              mv "$TARGET_FILE.tmp" "$TARGET_FILE"
              
            else
              echo "⚠️ 在原始文件中未找到标识，追加到文件末尾"
              echo "" >> "$TARGET_FILE"
              echo "$IDENTIFIER" >> "$TARGET_FILE"
              echo "$BLOCK_CONTENT" >> "$TARGET_FILE"
            fi
            
            echo "---"
          done
          
          echo "✅ 所有标识处理完成"
          
      # ============ 恢复操作 ============
      - name: 🔄 恢复备份
        if: env.ACTION_TYPE == 'restore'
        run: |
          echo "=== 恢复备份 ==="
          
          # 查找最新的备份文件
          BACKUP_FILE=$(ls -t .github/backups/build_firmware_main.sh.*.backup 2>/dev/null | head -1)
          
          if [ -z "$BACKUP_FILE" ]; then
            echo "❌ 未找到备份文件"
            echo "💡 请先执行一次修复操作以创建备份"
            exit 1
          fi
          
          echo "✅ 找到备份文件: $BACKUP_FILE"
          
          # 恢复备份
          cp "$BACKUP_FILE" "$TARGET_FILE"
          
          echo "✅ 已恢复备份"
          echo "🕒 备份时间: $(stat -c %y "$BACKUP_FILE")"
          
      # ============ 通用步骤 ============
      - name: 🧹 清理修复文件
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 清理修复文件 ==="
          
          # 清空fix.txt，防止重复执行
          if [ -f "fix.txt" ]; then
            > "fix.txt"
            echo "✅ 已清空fix.txt文件"
          fi
          
      - name: 📤 提交并推送
        run: |
          echo "=== 提交并推送 ==="
          
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          if [ "$ACTION_TYPE" = "restore" ]; then
            COMMIT_MSG="🔄 恢复备份"
            BACKUP_FILE=$(ls -t .github/backups/build_firmware_main.sh.*.backup 2>/dev/null | head -1)
            COMMIT_MSG+="\n备份文件: $(basename "$BACKUP_FILE")"
          else
            COMMIT_MSG="🔧 系统性标识修复"
            
            # 如果有标识，添加到提交信息
            if [ -f "fix.txt.bak" ]; then
              IDENTIFIERS=$(grep -o "^#【build_firmware_main.sh-[0-9]+】" fix.txt.bak || true)
              if [ -n "$IDENTIFIERS" ]; then
                COMMIT_MSG+="\n\n修复的标识:"
                echo "$IDENTIFIERS" | while read -r id; do
                  COMMIT_MSG+="\n- $id"
                done
              fi
            fi
          fi
          
          COMMIT_MSG+="\n时间: $(date)"
          
          # 添加所有更改
          git add -A
          
          # 提交
          if git diff-index --quiet HEAD --; then
            echo "⚠️ 没有更改可提交"
          else
            echo -e "$COMMIT_MSG" | git commit -F -
            git push origin HEAD:main
            echo "✅ 已提交并推送"
          fi
          
      - name: 📋 生成报告
        if: always()
        run: |
          echo "### 🔧 系统性标识修复报告" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**状态:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**操作类型:** $ACTION_TYPE" >> $GITHUB_STEP_SUMMARY
          echo "**目标文件:** $TARGET_FILE" >> $GITHUB_STEP_SUMMARY
          
          if [ "$ACTION_TYPE" = "restore" ]; then
            BACKUP_FILE=$(ls -t .github/backups/build_firmware_main.sh.*.backup 2>/dev/null | head -1 || echo "无")
            echo "**恢复的备份:** $(basename "$BACKUP_FILE")" >> $GITHUB_STEP_SUMMARY
          else
            echo "**备份文件:** $(basename "$BACKUP_FILE" 2>/dev/null || echo '未创建')" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**工作原理:**" >> $GITHUB_STEP_SUMMARY
          echo "1. 读取 fix.txt 中的系统性标识 (#【build_firmware_main.sh-序号】)" >> $GITHUB_STEP_SUMMARY
          echo "2. 在目标文件中找到对应标识" >> $GITHUB_STEP_SUMMARY
          echo "3. 用 fix.txt 中的完整代码块替换原标识下的内容" >> $GITHUB_STEP_SUMMARY
          echo "4. 如果找不到标识，则追加到文件末尾" >> $GITHUB_STEP_SUMMARY

# firmware-build-fix.yml
name: 🔧 自动修复系统

on:
  push:
    paths:
      - 'fix.txt'
      - '.github/workflows/firmware-build-fix.yml'
  
  workflow_dispatch:
    inputs:
      action:
        description: "🔧 选择操作类型"
        required: false
        default: "apply"
        type: choice
        options:
          - "apply"
          - "restore"

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: 🛎️ 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔍 检查操作类型
        run: |
          echo "=== 检查操作类型 ==="
          echo "触发事件: ${{ github.event_name }}"
          echo "操作类型: ${{ github.event.inputs.action || 'apply' }}"
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ github.event.inputs.action }}" = "restore" ]; then
              echo "🔄 执行恢复操作"
              echo "ACTION_TYPE=restore" >> $GITHUB_ENV
            else
              echo "🔧 执行修复操作"
              echo "ACTION_TYPE=apply" >> $GITHUB_ENV
            fi
          else
            echo "🔧 执行修复操作（push触发）"
            echo "ACTION_TYPE=apply" >> $GITHUB_ENV
          fi
      
      - name: 🔍 检查修复文件
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 检查修复文件 ==="
          
          if [ ! -f "fix.txt" ]; then
            echo "❌ 没有找到修复文件 fix.txt"
            exit 1
          fi
          
          echo "✅ 找到修复文件 fix.txt"
          echo "修复文件大小: $(wc -l < fix.txt) 行"
          
          # 检查是否有系统性标识
          if grep -q "#【" fix.txt; then
            echo "🔧 检测到系统性标识"
            echo "找到的标识:"
            grep -o "#【[^】]*】" fix.txt
          else
            echo "⚠️ 没有检测到系统性标识"
          fi
      
      - name: 📁 备份目标文件
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 备份目标文件 ==="
          
          # 查找目标文件
          TARGET_FILE=""
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="firmware-config/scripts/build_firmware_main.sh"
          elif [ -f "scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="scripts/build_firmware_main.sh"
          elif [ -f "build_firmware_main.sh" ]; then
            TARGET_FILE="build_firmware_main.sh"
          else
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "❌ 未找到目标文件"
            exit 1
          fi
          
          echo "✅ 目标文件: $TARGET_FILE"
          
          # 备份文件路径
          BACKUP_DIR=".github/backups"
          BACKUP_FILE="$BACKUP_DIR/build_firmware_main.sh.back"
          
          # 创建备份目录
          mkdir -p "$BACKUP_DIR"
          
          # 备份当前文件（覆盖旧的备份）
          cp "$TARGET_FILE" "$BACKUP_FILE"
          
          echo "✅ 已备份到: $BACKUP_FILE"
          echo "📊 备份文件大小: $(wc -l < "$BACKUP_FILE") 行"
          echo "📝 备份说明: 有且仅有一个备份文件，每次修复前自动覆盖"
      
      - name: 🔄 恢复备份文件
        if: env.ACTION_TYPE == 'restore'
        run: |
          echo "=== 恢复备份文件 ==="
          
          # 备份文件路径
          BACKUP_FILE=".github/backups/build_firmware_main.sh.back"
          
          if [ ! -f "$BACKUP_FILE" ]; then
            echo "❌ 未找到备份文件: $BACKUP_FILE"
            echo "💡 请先执行一次修复操作以创建备份"
            exit 1
          fi
          
          echo "✅ 找到备份文件: $BACKUP_FILE"
          echo "📊 备份文件大小: $(wc -l < "$BACKUP_FILE") 行"
          
          # 查找目标文件
          TARGET_FILE=""
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="firmware-config/scripts/build_firmware_main.sh"
          elif [ -f "scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="scripts/build_firmware_main.sh"
          elif [ -f "build_firmware_main.sh" ]; then
            TARGET_FILE="build_firmware_main.sh"
          else
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "❌ 未找到目标文件"
            exit 1
          fi
          
          echo "✅ 目标文件: $TARGET_FILE"
          
          # 备份当前文件（以防万一）
          cp "$TARGET_FILE" "/tmp/build_firmware_main.sh.pre_restore"
          
          # 恢复备份
          cp "$BACKUP_FILE" "$TARGET_FILE"
          
          echo "✅ 已恢复备份"
          echo "🔄 恢复说明: 已将 $BACKUP_FILE 恢复到 $TARGET_FILE"
          
          # 显示恢复前后差异
          echo "📋 恢复前后差异:"
          diff -u "/tmp/build_firmware_main.sh.pre_restore" "$TARGET_FILE" | head -20 || true
      
      - name: 📝 解析并应用修复
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 解析并应用修复 ==="
          
          # 1. 先查找目标文件
          echo "🔍 步骤1: 查找目标文件"
          TARGET_FILE=""
          
          # 首先尝试在常见位置查找 build_firmware_main.sh
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="firmware-config/scripts/build_firmware_main.sh"
          elif [ -f "scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="scripts/build_firmware_main.sh"
          elif [ -f "build_firmware_main.sh" ]; then
            TARGET_FILE="build_firmware_main.sh"
          else
            # 使用find命令搜索
            echo "🔍 开始全目录搜索 build_firmware_main.sh..."
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "❌ 错误: 未找到 build_firmware_main.sh 文件"
            echo "请确保文件存在于以下位置之一:"
            echo "- firmware-config/scripts/build_firmware_main.sh"
            echo "- scripts/build_firmware_main.sh" 
            echo "- build_firmware_main.sh"
            exit 1
          fi
          
          echo "✅ 找到目标文件: $TARGET_FILE"
          
          # 2. 修复目标文件的格式问题
          echo "🔧 步骤2: 修复目标文件格式（换行符问题）"
          cp "$TARGET_FILE" "/tmp/$(basename "$TARGET_FILE").original"
          
          # 修复 Windows 换行符 (^M)
          sed -i 's/\r$//' "$TARGET_FILE"
          
          # 检查是否有变化
          if diff -q "$TARGET_FILE" "/tmp/$(basename "$TARGET_FILE").original" >/dev/null; then
            echo "✅ 文件格式正常，无需修复"
          else
            echo "✅ 已修复文件格式（清除 Windows 换行符）"
          fi
          
          rm -f "/tmp/$(basename "$TARGET_FILE").original"
          
          # 3. 备份原文件到临时目录
          echo "📁 步骤3: 创建临时备份"
          TEMP_BACKUP="/tmp/$(basename "$TARGET_FILE").temp_backup.$(date +%Y%m%d_%H%M%S)"
          cp "$TARGET_FILE" "$TEMP_BACKUP"
          echo "✅ 临时备份: $TEMP_BACKUP"
          
          # 4. 读取修复内容
          echo "📖 步骤4: 读取修复内容..."
          FIX_CONTENT=$(cat fix.txt)
          
          # 5. 提取所有系统性标识及其对应的内容块
          echo "🔧 步骤5: 解析系统性标识..."
          
          # 查找所有系统性标识行号 - 提取纯标识部分
          IDENTIFIER_LINES=$(grep -n "#【[^】]*】" fix.txt | sed 's/:.*#【/:#【/' || true)
          
          if [ -z "$IDENTIFIER_LINES" ]; then
            echo "⚠️ 修复文件中没有找到系统性标识"
            echo "💡 尝试将整个文件追加到目标文件末尾"
            echo "" >> "$TARGET_FILE"
            echo "# ============ 自动修复内容 ============" >> "$TARGET_FILE"
            echo "# 修复时间: $(date)" >> "$TARGET_FILE"
            echo "# 来源: fix.txt" >> "$TARGET_FILE"
            cat fix.txt >> "$TARGET_FILE"
            echo "# ============ 修复结束 ============" >> "$TARGET_FILE"
            echo "✅ 已将整个修复文件追加到目标文件"
            exit 0
          fi
          
          echo "📋 找到的系统性标识:"
          echo "$IDENTIFIER_LINES"
          
          # 处理每个系统性标识
          TOTAL_FIX_LINES=$(wc -l < fix.txt)
          
          # 将标识行号转换为数组
          IFS=$'\n' read -d '' -r -a IDENTIFIER_ARRAY <<< "$IDENTIFIER_LINES" || true
          
          for i in "${!IDENTIFIER_ARRAY[@]}"; do
            CURRENT_LINE_INFO="${IDENTIFIER_ARRAY[$i]}"
            LINE_NUM=$(echo "$CURRENT_LINE_INFO" | cut -d: -f1)
            FULL_IDENTIFIER=$(echo "$CURRENT_LINE_INFO" | cut -d: -f2-)
            
            # 提取纯标识（到第一个空格或行尾）
            PURE_IDENTIFIER=$(echo "$FULL_IDENTIFIER" | grep -o "#【[^ 】]*】" | head -1)
            
            if [ -z "$PURE_IDENTIFIER" ]; then
              echo "⚠️ 无法提取纯标识: $FULL_IDENTIFIER"
              continue
            fi
            
            echo "🔨 处理标识: $PURE_IDENTIFIER (第 $LINE_NUM 行)"
            
            # 提取标识名称（去掉 #【】）
            ID_NAME=$(echo "$PURE_IDENTIFIER" | sed 's/#【//' | sed 's/】//')
            
            # 提取该标识对应的内容块范围
            BLOCK_START=$LINE_NUM
            
            # 确定内容块结束位置（下一个标识的开始，或者文件结束）
            if [ $((i + 1)) -lt ${#IDENTIFIER_ARRAY[@]} ]; then
              # 有下一个标识
              NEXT_LINE_INFO="${IDENTIFIER_ARRAY[$((i + 1))]}"
              NEXT_LINE_NUM=$(echo "$NEXT_LINE_INFO" | cut -d: -f1)
              BLOCK_END=$((NEXT_LINE_NUM - 1))
            else
              # 最后一个标识，到文件结束
              BLOCK_END=$TOTAL_FIX_LINES
            fi
            
            echo "📌 内容块范围: 第 $BLOCK_START 行到第 $BLOCK_END 行"
            
            # 提取整个内容块（包含标识行）
            BLOCK_CONTENT=$(sed -n "${BLOCK_START},${BLOCK_END}p" fix.txt)
            
            # 在目标文件中查找该标识
            echo "🔍 在目标文件中查找标识: $PURE_IDENTIFIER"
            
            # 转义标识中的特殊字符
            ESCAPED_IDENTIFIER=$(echo "$PURE_IDENTIFIER" | sed 's/[][\.*^$]/\\&/g')
            
            # 搜索标识
            TARGET_LINE_NUM=$(grep -n "^\s*$ESCAPED_IDENTIFIER" "$TARGET_FILE" | head -1 | cut -d: -f1)
            
            if [ -n "$TARGET_LINE_NUM" ]; then
              echo "✅ 在目标文件第 $TARGET_LINE_NUM 行找到标识"
              
              # 创建临时文件进行替换
              TEMP_FILE="/tmp/$(basename "$TARGET_FILE").temp.$$"
              
              # 先备份替换前的行
              sed -n "${TARGET_LINE_NUM}p" "$TARGET_FILE" > "/tmp/original_line.txt"
              
              # 执行替换：找到该行，替换为整个内容块
              awk -v line_num="$TARGET_LINE_NUM" -v block_content="$BLOCK_CONTENT" '
                NR == line_num {
                  print block_content
                  next
                }
                NR != line_num {
                  print
                }
              ' "$TARGET_FILE" > "$TEMP_FILE"
              
              # 验证替换结果
              if [ $(wc -l < "$TEMP_FILE") -gt 10 ]; then
                mv "$TEMP_FILE" "$TARGET_FILE"
                echo "✅ 内容块替换成功 (标识: $ID_NAME)"
              else
                echo "⚠️ 替换后文件太小，可能有错误，跳过此内容块"
                rm -f "$TEMP_FILE"
              fi
              
            else
              echo "⚠️ 在目标文件中未找到标识 $PURE_IDENTIFIER"
              echo "💡 尝试追加到文件末尾"
              
              # 检查是否整个文件追加过
              if ! tail -n 5 "$TARGET_FILE" | grep -q "# ============ 自动修复内容 ============"; then
                echo "" >> "$TARGET_FILE"
                echo "# ============ 自动修复内容 ============" >> "$TARGET_FILE"
                echo "# 修复时间: $(date)" >> "$TARGET_FILE"
                echo "# 来源: fix.txt" >> "$TARGET_FILE"
              fi
              
              echo "$BLOCK_CONTENT" >> "$TARGET_FILE"
              echo "✅ 内容块已追加到文件末尾 (标识: $ID_NAME)"
            fi
            
            echo "---"
          done
          
          # 如果文件末尾有自动修复标记，添加结束标记
          if tail -n 1 "$TARGET_FILE" | grep -q "#【"; then
            echo "" >> "$TARGET_FILE"
            echo "# ============ 修复结束 ============" >> "$TARGET_FILE"
          fi
          
          echo "✅ 所有修复处理完成"
      
      - name: 🔧 提交前再次修复文件格式
        if: env.ACTION_TYPE == 'apply'
        run: |
          echo "=== 提交前再次修复文件格式 ==="
          
          # 查找目标文件
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="firmware-config/scripts/build_firmware_main.sh"
          elif [ -f "scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="scripts/build_firmware_main.sh"
          elif [ -f "build_firmware_main.sh" ]; then
            TARGET_FILE="build_firmware_main.sh"
          else
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "ℹ️ 没有需要修复格式的文件"
            exit 0
          fi
          
          echo "🔧 修复文件格式: $TARGET_FILE"
          
          # 修复换行符
          sed -i 's/\r$//' "$TARGET_FILE"
          
          # 确保文件以换行符结尾
          if [ -s "$TARGET_FILE" ] && ! tail -c1 "$TARGET_FILE" | read -r _; then
            echo "" >> "$TARGET_FILE"
            echo "✅ 添加文件结束换行符"
          fi
          
          echo "✅ 文件格式修复完成"
      
      - name: 📤 提交并推送修改
        run: |
          echo "=== 提交并推送修改 ==="
          
          # 配置Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # 根据操作类型设置提交信息
          if [ "$ACTION_TYPE" = "restore" ]; then
            COMMIT_MSG="🔄 恢复备份"
            COMMIT_MSG+="\n\n来源: .github/backups/build_firmware_main.sh.back"
            COMMIT_MSG+="\n时间: $(date)"
            COMMIT_MSG+="\n操作: 手动恢复"
          else
            # 检查是否有更改
            if git diff --quiet; then
              echo "⚠️ 没有检测到文件更改"
              echo "💡 已应用修复但文件内容无变化，仅清理修复文件"
            else
              echo "💾 检测到文件更改，准备提交..."
              
              # 显示更改的文件
              echo "📋 更改的文件:"
              git status --short
              
              # 添加更改
              git add -A
            fi
            
            COMMIT_MSG="🔧 自动修复"
            COMMIT_MSG+="\n\n来源: fix.txt"
            COMMIT_MSG+="\n时间: $(date)"
            COMMIT_MSG+="\n事件: ${{ github.event_name }}"
            
            # 添加修复的标识列表
            if [ -f "fix.txt" ] && grep -q "#【" fix.txt; then
              COMMIT_MSG+="\n\n修复的内容块:"
              grep -o "#【[^】]*】" fix.txt | while IFS= read -r identifier; do
                ID_NAME=$(echo "$identifier" | sed 's/#【//' | sed 's/】//')
                COMMIT_MSG+="\n- $ID_NAME"
              done
            fi
          fi
          
          echo -e "$COMMIT_MSG" | git commit -F - || {
            echo "⚠️ 提交失败，可能没有更改"
            # 如果没有更改但需要清理 fix.txt
            if [ -f "fix.txt" ] && [ $(wc -l < fix.txt) -gt 0 ]; then
              echo "🧹 清理 fix.txt 文件..."
              > fix.txt
              git add fix.txt
              git commit -m "🧹 清理修复文件 [skip ci]"
            fi
          }
          
          # 推送
          echo "🚀 推送到主分支..."
          git push origin HEAD:main || {
            echo "⚠️ 推送失败，尝试拉取最新更改后重试"
            git pull --rebase origin main
            git push origin HEAD:main
          }
          
          echo "✅ 操作完成并推送到主分支"
      
      - name: 📋 生成报告
        if: always()
        run: |
          echo "### 🔧 自动修复系统报告" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "**状态:** ✅ 成功" >> $GITHUB_STEP_SUMMARY
          else
            echo "**状态:** ❌ 失败" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "**操作类型:** $ACTION_TYPE" >> $GITHUB_STEP_SUMMARY
          echo "**时间:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**触发:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$ACTION_TYPE" = "restore" ]; then
            echo "**操作详情:**" >> $GITHUB_STEP_SUMMARY
            echo "- 🔄 恢复备份文件" >> $GITHUB_STEP_SUMMARY
            echo "- 📁 备份位置: .github/backups/build_firmware_main.sh.back" >> $GITHUB_STEP_SUMMARY
            echo "- 💡 下次修复时会覆盖此备份" >> $GITHUB_STEP_SUMMARY
          else
            echo "**操作详情:**" >> $GITHUB_STEP_SUMMARY
            echo "- 🔧 应用修复" >> $GITHUB_STEP_SUMMARY
            echo "- 📁 已创建备份: .github/backups/build_firmware_main.sh.back" >> $GITHUB_STEP_SUMMARY
            echo "- 💡 如需恢复，请点击「🔄 恢复备份」按钮" >> $GITHUB_STEP_SUMMARY
            
            # 显示修复的标识信息
            if [ -f "fix.txt" ] && grep -q "#【" fix.txt; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**修复的内容块:**" >> $GITHUB_STEP_SUMMARY
              grep -o "#【[^】]*】" fix.txt | while IFS= read -r identifier; do
                ID_NAME=$(echo "$identifier" | sed 's/#【//' | sed 's/】//')
                echo "- $ID_NAME" >> $GITHUB_STEP_SUMMARY
              done
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**使用说明:**" >> $GITHUB_STEP_SUMMARY
          echo "1. **🔧 应用修复**: 将 fix.txt 中的修复应用到 build_firmware_main.sh" >> $GITHUB_STEP_SUMMARY
          echo "2. **🔄 恢复备份**: 恢复上次修复前的状态" >> $GITHUB_STEP_SUMMARY
          echo "3. **💾 备份策略**: 有且仅有一个备份文件，每次修复前自动覆盖" >> $GITHUB_STEP_SUMMARY

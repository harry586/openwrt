# firmware-build-fix.yml
name: 🔧 自动修复系统

on:
  push:
    paths:
      - 'fix.txt'
  
  workflow_dispatch:

jobs:
  auto-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: 🛎️ 检出代码
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔍 检查修复文件
        run: |
          echo "=== 检查修复文件 ==="
          
          if [ ! -f "fix.txt" ]; then
            echo "❌ 没有找到修复文件 fix.txt"
            exit 1
          fi
          
          echo "✅ 找到修复文件 fix.txt"
          echo "修复文件大小: $(wc -l < fix.txt) 行"
          
          # 检查是否有系统性标识
          if grep -q "#【" fix.txt; then
            echo "🔧 检测到系统性标识"
            echo "找到的标识:"
            grep -o "#【[^】]*】" fix.txt
          else
            echo "⚠️ 没有检测到系统性标识"
          fi
      
      - name: 📝 解析并应用修复
        run: |
          echo "=== 解析并应用修复 ==="
          
          # 0. 先修复可能的文件格式问题
          echo "🔧 步骤0: 修复文件格式（换行符问题）"
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "🔍 找到 build_firmware_main.sh，检查并修复格式..."
            # 备份原文件（仅用于对比）
            cp "firmware-config/scripts/build_firmware_main.sh" "/tmp/build_firmware_main.sh.original"
            
            # 修复 Windows 换行符 (^M)
            sed -i 's/\r$//' "firmware-config/scripts/build_firmware_main.sh"
            
            # 检查是否有变化
            if diff -q "firmware-config/scripts/build_firmware_main.sh" "/tmp/build_firmware_main.sh.original" >/dev/null; then
              echo "✅ 文件格式正常，无需修复"
            else
              echo "✅ 已修复文件格式（清除 Windows 换行符）"
            fi
            
            rm -f "/tmp/build_firmware_main.sh.original"
          fi
          
          # 1. 查找目标文件
          TARGET_FILE=""
          
          # 首先尝试在常见位置查找 build_firmware_main.sh
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="firmware-config/scripts/build_firmware_main.sh"
          elif [ -f "scripts/build_firmware_main.sh" ]; then
            TARGET_FILE="scripts/build_firmware_main.sh"
          elif [ -f "build_firmware_main.sh" ]; then
            TARGET_FILE="build_firmware_main.sh"
          else
            # 使用find命令搜索
            echo "🔍 开始全目录搜索 build_firmware_main.sh..."
            TARGET_FILE=$(find . -name "build_firmware_main.sh" -type f ! -path "./.git/*" | head -1)
          fi
          
          if [ -z "$TARGET_FILE" ]; then
            echo "❌ 错误: 未找到 build_firmware_main.sh 文件"
            echo "请确保文件存在于以下位置之一:"
            echo "- firmware-config/scripts/build_firmware_main.sh"
            echo "- scripts/build_firmware_main.sh" 
            echo "- build_firmware_main.sh"
            exit 1
          fi
          
          echo "✅ 找到目标文件: $TARGET_FILE"
          
          # 2. 备份原文件（仅保留在临时目录，不提交）
          BACKUP_FILE="/tmp/$(basename "$TARGET_FILE").backup.$(date +%Y%m%d_%H%M%S)"
          cp "$TARGET_FILE" "$BACKUP_FILE"
          echo "✅ 已在临时目录备份原文件: $BACKUP_FILE"
          
          # 3. 读取修复内容
          echo "📖 读取修复内容..."
          FIX_CONTENT=$(cat fix.txt)
          
          # 4. 提取所有系统性标识及其对应的内容块
          echo "🔧 开始解析系统性标识..."
          
          # 查找所有系统性标识行号
          IDENTIFIER_LINES=$(grep -n "#【" fix.txt || true)
          
          if [ -z "$IDENTIFIER_LINES" ]; then
            echo "⚠️ 修复文件中没有找到系统性标识"
            echo "💡 尝试将整个文件追加到目标文件末尾"
            echo "" >> "$TARGET_FILE"
            echo "# ============ 自动修复内容 ============" >> "$TARGET_FILE"
            echo "# 修复时间: $(date)" >> "$TARGET_FILE"
            echo "# 来源: fix.txt" >> "$TARGET_FILE"
            cat fix.txt >> "$TARGET_FILE"
            echo "# ============ 修复结束 ============" >> "$TARGET_FILE"
            echo "✅ 已将整个修复文件追加到目标文件"
            exit 0
          fi
          
          echo "📋 找到的系统性标识:"
          echo "$IDENTIFIER_LINES"
          
          # 处理每个系统性标识
          TOTAL_FIX_LINES=$(wc -l < fix.txt)
          
          # 将标识行号转换为数组
          IFS=$'\n' read -d '' -r -a IDENTIFIER_ARRAY <<< "$IDENTIFIER_LINES"
          
          for i in "${!IDENTIFIER_ARRAY[@]}"; do
            CURRENT_LINE_INFO="${IDENTIFIER_ARRAY[$i]}"
            LINE_NUM=$(echo "$CURRENT_LINE_INFO" | cut -d: -f1)
            IDENTIFIER=$(echo "$CURRENT_LINE_INFO" | cut -d: -f2- | sed 's/^[[:space:]]*//')
            
            echo "🔨 处理标识: $IDENTIFIER (第 $LINE_NUM 行)"
            
            # 提取标识名称（去掉 #【】）
            ID_NAME=$(echo "$IDENTIFIER" | sed 's/#【//' | sed 's/】//')
            
            # 提取该标识对应的内容块范围
            BLOCK_START=$LINE_NUM
            
            # 确定内容块结束位置（下一个标识的开始，或者文件结束）
            if [ $((i + 1)) -lt ${#IDENTIFIER_ARRAY[@]} ]; then
              # 有下一个标识
              NEXT_LINE_INFO="${IDENTIFIER_ARRAY[$((i + 1))]}"
              NEXT_LINE_NUM=$(echo "$NEXT_LINE_INFO" | cut -d: -f1)
              BLOCK_END=$((NEXT_LINE_NUM - 1))
            else
              # 最后一个标识，到文件结束
              BLOCK_END=$TOTAL_FIX_LINES
            fi
            
            echo "📌 内容块范围: 第 $BLOCK_START 行到第 $BLOCK_END 行"
            
            # 提取整个内容块（包含标识行）
            BLOCK_CONTENT=$(sed -n "${BLOCK_START},${BLOCK_END}p" fix.txt)
            
            # 在目标文件中查找该标识
            echo "🔍 在目标文件中查找标识: $IDENTIFIER"
            
            # 搜索标识，支持标识行前后可能有空格的情况
            TARGET_LINE_NUM=$(grep -n "^\s*${IDENTIFIER}" "$TARGET_FILE" | head -1 | cut -d: -f1)
            
            if [ -n "$TARGET_LINE_NUM" ]; then
              echo "✅ 在目标文件第 $TARGET_LINE_NUM 行找到标识"
              
              # 在目标文件中找到标识对应的内容块范围
              TARGET_TOTAL_LINES=$(wc -l < "$TARGET_FILE")
              TARGET_BLOCK_START=$TARGET_LINE_NUM
              TARGET_BLOCK_END=""
              
              # 从标识行开始查找，直到下一个标识或文件结束
              CURRENT_SEARCH=$((TARGET_LINE_NUM + 1))
              
              while [ $CURRENT_SEARCH -le $TARGET_TOTAL_LINES ]; do
                LINE_CONTENT=$(sed -n "${CURRENT_SEARCH}p" "$TARGET_FILE")
                
                # 如果遇到下一个系统性标识（以 #【 开头）
                if [[ "$LINE_CONTENT" =~ ^[[:space:]]*#【 ]]; then
                  TARGET_BLOCK_END=$((CURRENT_SEARCH - 1))
                  break
                fi
                
                # 如果到达文件末尾
                if [ $CURRENT_SEARCH -eq $TARGET_TOTAL_LINES ]; then
                  TARGET_BLOCK_END=$CURRENT_SEARCH
                  break
                fi
                
                ((CURRENT_SEARCH++))
              done
              
              if [ -z "$TARGET_BLOCK_END" ]; then
                TARGET_BLOCK_END=$TARGET_TOTAL_LINES
              fi
              
              echo "📌 目标文件中原内容块范围: 第 $TARGET_BLOCK_START 行到第 $TARGET_BLOCK_END 行"
              
              # 创建临时文件进行替换
              TEMP_FILE="/tmp/$(basename "$TARGET_FILE").temp.$$"
              
              # 替换内容块：原文件前部分 + 新内容块 + 原文件后部分
              head -n $((TARGET_BLOCK_START - 1)) "$TARGET_FILE" > "$TEMP_FILE"
              echo "$BLOCK_CONTENT" >> "$TEMP_FILE"
              tail -n +$((TARGET_BLOCK_END + 1)) "$TARGET_FILE" >> "$TEMP_FILE"
              
              # 验证替换结果
              if [ $(wc -l < "$TEMP_FILE") -gt 10 ]; then
                mv "$TEMP_FILE" "$TARGET_FILE"
                echo "✅ 内容块替换成功 (标识: $ID_NAME)"
              else
                echo "⚠️ 替换后文件太小，可能有错误，跳过此内容块"
                rm -f "$TEMP_FILE"
              fi
              
            else
              echo "⚠️ 在目标文件中未找到标识 $IDENTIFIER"
              echo "💡 尝试追加到文件末尾"
              
              # 检查是否整个文件追加过
              if ! tail -n 5 "$TARGET_FILE" | grep -q "# ============ 自动修复内容 ============"; then
                echo "" >> "$TARGET_FILE"
                echo "# ============ 自动修复内容 ============" >> "$TARGET_FILE"
                echo "# 修复时间: $(date)" >> "$TARGET_FILE"
                echo "# 来源: fix.txt" >> "$TARGET_FILE"
              fi
              
              echo "$BLOCK_CONTENT" >> "$TARGET_FILE"
              echo "✅ 内容块已追加到文件末尾 (标识: $ID_NAME)"
            fi
            
            echo "---"
          done
          
          # 如果文件末尾有自动修复标记，添加结束标记
          if tail -n 1 "$TARGET_FILE" | grep -q "#【"; then
            echo "" >> "$TARGET_FILE"
            echo "# ============ 修复结束 ============" >> "$TARGET_FILE"
          fi
          
          echo "✅ 所有修复处理完成"
      
      - name: 🔧 提交前再次修复文件格式（双重保险）
        run: |
          echo "=== 提交前再次修复文件格式（双重保险）==="
          
          # 查找所有可能的目标文件
          FILES_TO_FIX=()
          
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            FILES_TO_FIX+=("firmware-config/scripts/build_firmware_main.sh")
          fi
          
          if [ -f "fix.txt" ]; then
            FILES_TO_FIX+=("fix.txt")
          fi
          
          if [ ${#FILES_TO_FIX[@]} -eq 0 ]; then
            echo "ℹ️ 没有需要修复格式的文件"
            exit 0
          fi
          
          echo "🔧 将修复以下文件的格式:"
          for file in "${FILES_TO_FIX[@]}"; do
            echo "  - $file"
          done
          
          # 修复每个文件的格式
          for file in "${FILES_TO_FIX[@]}"; do
            echo ""
            echo "🔄 修复文件: $file"
            
            # 备份原文件
            BACKUP_FILE="/tmp/$(basename "$file").pre_commit_backup"
            cp "$file" "$BACKUP_FILE"
            
            # 执行格式修复
            if command -v dos2unix >/dev/null 2>&1; then
              # 使用 dos2unix 工具（如果有）
              dos2unix "$file" 2>/dev/null || true
            else
              # 使用 sed 修复换行符
              sed -i 's/\r$//' "$file"
            fi
            
            # 确保文件以换行符结尾
            if [ -s "$file" ] && ! tail -c1 "$file" | read -r _; then
              echo "" >> "$file"
              echo "✅ 添加文件结束换行符"
            fi
            
            # 检查是否有变化
            if diff -q "$file" "$BACKUP_FILE" >/dev/null; then
              echo "✅ 文件格式正常，无需修复"
            else
              echo "✅ 已修复文件格式（清除 Windows 换行符）"
            fi
            
            # 显示文件信息
            echo "📊 文件信息:"
            echo "  大小: $(wc -l < "$file") 行"
            
            # 检查是否有 ^M 字符
            if grep -q $'\r' "$file" 2>/dev/null; then
              echo "⚠️ 警告: 文件中仍包含 Windows 换行符"
              # 强制修复
              tr -d '\r' < "$file" > "${file}.fixed"
              mv "${file}.fixed" "$file"
              echo "🔧 已强制修复"
            fi
            
            rm -f "$BACKUP_FILE"
          done
          
          echo ""
          echo "✅ 所有文件格式修复完成"
      
      - name: 📤 提交并推送修改
        run: |
          echo "=== 提交并推送修改 ==="
          
          # 配置Git
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          
          # 检查是否有更改
          if git diff --quiet; then
            echo "⚠️ 没有检测到文件更改"
            echo "💡 已应用修复但文件内容无变化，仅清理修复文件"
          else
            echo "💾 检测到文件更改，准备提交..."
            
            # 显示更改的文件
            echo "📋 更改的文件:"
            git status --short
            
            # 添加更改
            git add -A
            
            # 显示具体差异
            echo "📝 具体差异:"
            git diff --stat
          fi
          
          # 提交
          COMMIT_MSG="🔧 自动修复"
          COMMIT_MSG+="\n\n来源: fix.txt"
          COMMIT_MSG+="\n时间: $(date)"
          COMMIT_MSG+="\n事件: ${{ github.event_name }}"
          
          # 添加修复的标识列表
          if [ -f "fix.txt" ] && grep -q "#【" fix.txt; then
            COMMIT_MSG+="\n\n修复的内容块:"
            grep "#【" fix.txt | while IFS= read -r identifier; do
              ID_NAME=$(echo "$identifier" | sed 's/#【//' | sed 's/】//')
              COMMIT_MSG+="\n- $ID_NAME"
            done
          fi
          
          # 添加格式修复信息
          if ls -1 /tmp/*.pre_commit_backup 2>/dev/null | grep -q .; then
            COMMIT_MSG+="\n\n格式修复: ✅ 已修复 Windows 换行符问题"
          fi
          
          echo -e "$COMMIT_MSG" | git commit -F - || {
            echo "⚠️ 提交失败，可能没有更改"
            # 如果没有更改但需要清理 fix.txt
            if [ -f "fix.txt" ] && [ $(wc -l < fix.txt) -gt 0 ]; then
              echo "🧹 清理 fix.txt 文件..."
              > fix.txt
              git add fix.txt
              git commit -m "🧹 清理修复文件 [skip ci]"
            fi
          }
          
          # 推送
          echo "🚀 推送到主分支..."
          git push origin HEAD:main || {
            echo "⚠️ 推送失败，尝试拉取最新更改后重试"
            git pull --rebase origin main
            git push origin HEAD:main
          }
          
          echo "✅ 修复已应用并推送到主分支"
          
          # 清理fix.txt文件（无论是否有更改都执行）
          echo "🧹 清理fix.txt文件..."
          if [ -f "fix.txt" ]; then
            > fix.txt
            git add fix.txt
            git commit -m "🧹 清理修复文件 [skip ci]" || true
            git push origin HEAD:main
          fi
      
      - name: 📋 生成报告
        if: always()
        run: |
          echo "### 🔧 自动修复完成" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "**状态:** ✅ 成功" >> $GITHUB_STEP_SUMMARY
          else
            echo "**状态:** ❌ 失败" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "**时间:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**触发:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 显示修复的标识信息
          if [ -f "fix.txt" ] && grep -q "#【" fix.txt; then
            echo "**修复的内容块:**" >> $GITHUB_STEP_SUMMARY
            grep "#【" fix.txt | while IFS= read -r identifier; do
              ID_NAME=$(echo "$identifier" | sed 's/#【//' | sed 's/】//')
              echo "- $ID_NAME" >> $GITHUB_STEP_SUMMARY
            done
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**处理流程:**" >> $GITHUB_STEP_SUMMARY
          echo "1. ✅ 检查修复文件" >> $GITHUB_STEP_SUMMARY
          echo "2. ✅ 修复文件格式（首次）" >> $GITHUB_STEP_SUMMARY
          echo "3. ✅ 解析系统性标识" >> $GITHUB_STEP_SUMMARY
          echo "4. ✅ 查找并替换内容块" >> $GITHUB_STEP_SUMMARY
          echo "5. ✅ 提交前再次修复文件格式（双重保险）" >> $GITHUB_STEP_SUMMARY
          echo "6. ✅ 提交并推送更改" >> $GITHUB_STEP_SUMMARY
          echo "7. ✅ 清理修复文件" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**文件格式修复:**" >> $GITHUB_STEP_SUMMARY
          echo "- 已修复 Windows 换行符 (^M)" >> $GITHUB_STEP_SUMMARY
          echo "- 双重保险机制确保格式正确" >> $GITHUB_STEP_SUMMARY

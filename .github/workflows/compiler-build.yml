# .github/workflows/compiler-matrix-build.yml
name: 🔧 交叉编译器构建

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构（IPQ40xx选择arm_cortex-a7）'
        required: true
        default: 'arm_cortex-a7'
        type: choice
        options:
          - aarch64        # ARM 64位（树莓派4/RK3399/电视盒子）
          - x86_64         # x86 64位（PC/服务器/虚拟机）
          - mips           # MIPS 32位大端（MT7621/老路由器）
          - mipsel         # MIPS 32位小端（MT7620/MT7621）
          - arm_cortex-a7  # ARM Cortex-A7（IPQ40xx/MT7623/全志H3）
          - arm_cortex-a53 # ARM Cortex-A53（MT7622/部分64位设备）
          - riscv64        # RISC-V 64位（新架构开发板）
      libc:
        description: 'C库类型（嵌入式推荐musl）'
        required: true
        default: 'musl'
        type: choice
        options:
          - musl   # 轻量级，嵌入式推荐
          - glibc  # 功能完整
      gcc_version:
        description: 'GCC版本（输入版本号如12.3.0，或auto自动检测）'
        required: true
        default: 'auto'
        type: string
      clean_build:
        description: '清理之前的构建缓存'
        required: true
        default: false
        type: boolean
      force_rebuild:
        description: '强制重新构建（即使已存在）'
        required: true
        default: false
        type: boolean

env:
  OPENWRT_VERSION: "23.05.2"
  COMPILER_BASE_DIR: "${{ github.workspace }}/firmware-config/build-Compiler-file/compilers"

jobs:
  show-device-info:
    runs-on: ubuntu-latest
    steps:
      - name: 📱 显示架构对应设备
        run: |
          echo "================================================"
          echo "          🎯 目标架构设备对应表                 "
          echo "================================================"
          echo ""
          echo "1️⃣ aarch64 (ARM 64位)"
          echo "   ├─ 📱 树莓派系列"
          echo "   │  ├─ 树莓派 4B (Raspberry Pi 4)"
          echo "   │  ├─ 树莓派 CM4 (Compute Module 4)"
          echo "   │  └─ 树莓派 400"
          echo "   ├─ 🖥️ 瑞芯微系列"
          echo "   │  ├─ RK3399 (ROCK Pi 4/NanoPi M4)"
          echo "   │  ├─ RK3568 (FriendlyELEC NanoPi R5S)"
          echo "   │  └─ RK3588 (高端开发板)"
          echo "   ├─ 📺 电视盒子"
          echo "   │  ├─ 晶晨 S905 (X96 Max/Beelink GT King)"
          echo "   │  ├─ 晶晨 S912 (H96 Pro/Beelink GT1)"
          echo "   │  └─ 晶晨 S922X (Odroid N2+)"
          echo "   └─ 🖥️ 其他ARM64设备"
          echo "      ├─ Orange Pi 5"
          echo "      ├─ Banana Pi BPI-M5"
          echo "      └─ 各种ARM服务器"
          echo ""
          echo "2️⃣ x86_64 (x86 64位)"
          echo "   ├─ 💻 个人电脑"
          echo "   │  ├─ Intel Core i3/i5/i7/i9"
          echo "   │  ├─ AMD Ryzen 3/5/7/9"
          echo "   │  └─ 各种x86笔记本"
          echo "   ├─ 🖥️ 服务器"
          echo "   │  ├─ 戴尔PowerEdge"
          echo "   │  ├─ 惠普ProLiant"
          echo "   │  └─ 超微服务器"
          echo "   └─ ☁️ 虚拟机/容器"
          echo "      ├─ VMware/VirtualBox虚拟机"
          echo "      ├─ Docker容器"
          echo "      └─ 云服务器实例"
          echo ""
          echo "3️⃣ mips (MIPS 32位大端)"
          echo "   ├─ 🛜 华硕路由器"
          echo "   │  ├─ RT-ACRH17"
          echo "   │  ├─ RT-AC85P"
          echo "   │  └─ RT-N56U"
          echo "   ├─ 🛜 网件路由器"
          echo "   │  ├─ R7800"
          echo "   │  ├─ R9000"
          echo "   │  └─ XR500"
          echo "   └─ 🛜 其他MIPS设备"
          echo "      ├─ 中兴路由器"
          echo "      ├─ 华为旧款路由器"
          echo "      └─ 早期智能家居设备"
          echo ""
          echo "4️⃣ mipsel (MIPS 32位小端)"
          echo "   ├─ 🛜 联发科MT7621"
          echo "   │  ├─ 斐讯 K2P (Phicomm K2P)"
          echo "   │  ├─ Newifi 3 (新路由3)"
          echo "   │  ├─ 小米路由器 3G"
          echo "   │  ├─ 红米路由器 AC2100"
          echo "   │  └─ 极路由 B70"
          echo "   ├─ 🛜 联发科MT7620"
          echo "   │  ├─ 小米路由器 Mini"
          echo "   │  ├─ 极路由 1S"
          echo "   │  ├─ 斐讯 K1/K2"
          echo "   │  └─ 联想 Newifi Mini"
          echo "   └─ 🛜 其他MTK设备"
          echo "      ├─ MT7628 (低端路由)"
          echo "      ├─ MT7688 (物联网设备)"
          echo "      └─ 各种WiFi模块"
          echo ""
          echo "5️⃣ arm_cortex-a7 (ARM Cortex-A7)"
          echo "   ├─ 🛜 高通IPQ40xx系列 (你的设备！)"
          echo "   │  ├─ 小米路由器 4A千兆版"
          echo "   │  ├─ 红米路由器 AC2100 (部分版本)"
          echo "   │  ├─ GL.iNet MT1300"
          echo "   │  ├─ 360家庭防火墙 5Pro"
          echo "   │  ├─ Linksys EA6350 v3"
          echo "   │  └─ Netgear R6900P"
          echo "   ├─ 🛜 联发科MT7623/MT7629"
          echo "   │  ├─ 小米路由器 3G (部分版本)"
          echo "   │  ├─ 斐讯 K3C"
          echo "   │  └─ 部分企业路由器"
          echo "   ├─ 🍊 全志H3/H2+系列"
          echo "   │  ├─ Orange Pi PC (香橙派PC)"
          echo "   │  ├─ Orange Pi Plus"
          echo "   │  ├─ Banana Pi M2+"
          echo "   │  └─ NanoPi NEO"
          echo "   └─ 🔧 其他Cortex-A7设备"
          echo "      ├─ 某些智能摄像头"
          echo "      ├─ 工业控制设备"
          echo "      └─ 低功耗嵌入式设备"
          echo ""
          echo "6️⃣ arm_cortex-a53 (ARM Cortex-A53)"
          echo "   ├─ 🛜 联发科MT7622"
          echo "   │  ├─ 小米路由器 AX3600"
          echo "   │  ├─ 红米路由器 AX6"
          echo "   │  └─ 部分WiFi6路由器"
          echo "   ├─ 📱 64位设备32位模式"
          echo "   │  ├─ 树莓派 3 (32位模式)"
          echo "   │  ├─ 某些电视盒子"
          echo "   │  └─ 低端平板电脑"
          echo "   └─ 🔧 其他A53设备"
          echo "      ├─ 某些智能音箱"
          echo "      ├─ 物联网网关"
          echo "      ├─ 边缘计算设备"
          echo ""
          echo "7️⃣ riscv64 (RISC-V 64位)"
          echo "   ├─ 🔬 开发板"
          echo "   │  ├─ HiFive Unmatched"
          echo "   │  ├─ VisionFive 2"
          echo "   │  ├─ BeagleV"
          echo "   │  └─ SiFive开发板"
          echo "   ├─ 🖥️ 新兴设备"
          echo "   │  ├─ 某些AI加速器"
          echo "   │  ├─ 定制芯片设备"
          echo "   │  └─ 学术研究设备"
          echo "   └─ 🚀 未来设备"
          echo "      ├─ RISC-V笔记本电脑"
          echo "      ├─ RISC-V服务器"
          echo "      └─ 各种创新硬件"
          echo ""
          echo "================================================"
          echo "选择建议："
          echo "1. 路由器设备 → 根据芯片型号选择"
          echo "2. 开发板 → 根据CPU架构选择"
          echo "3. PC/服务器 → 选择x86_64"
          echo "4. 不确定 → 查看设备规格书或CPU信息"
          echo "================================================"

  setup:
    runs-on: ubuntu-22.04
    outputs:
      gcc_version: ${{ steps.version-detection.outputs.gcc_version }}
      binutils_version: ${{ steps.version-detection.outputs.binutils_version }}
      linux_version: ${{ steps.version-detection.outputs.linux_version }}
      musl_version: ${{ steps.version-detection.outputs.musl_version }}
      glibc_version: ${{ steps.version-detection.outputs.glibc_version }}
      need_build: ${{ steps.check-existing.outputs.need_build }}
    steps:
      - name: 📥 检出仓库（用于检查现有编译器）
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            firmware-config/build-Compiler-file/compilers
          sparse-checkout-cone-mode: false

      - name: 🏗️ 初始化
        run: |
          echo "=== 交叉编译器构建系统 ==="
          mkdir -p "${{ env.COMPILER_BASE_DIR }}"
          echo "基础目录: ${{ env.COMPILER_BASE_DIR }}"
          echo "开始时间: $(date)"
          
          echo "当前工作区内容:"
          ls -la "${{ github.workspace }}/firmware-config/build-Compiler-file/compilers" 2>/dev/null || echo "编译器目录不存在"

      - name: 🔍 智能版本检测与选择
        id: version-detection
        run: |
          echo "=== 智能版本检测与选择 ==="
          USER_VERSION="${{ github.event.inputs.gcc_version }}"
          TARGET_ARCH="${{ github.event.inputs.target_arch }}"
          LIBC_TYPE="${{ github.event.inputs.libc }}"
          
          echo "输入参数:"
          echo "- 目标架构: $TARGET_ARCH"
          echo "- C库类型: $LIBC_TYPE"
          echo "- 用户指定GCC版本: $USER_VERSION"
          
          # 获取OpenWrt版本对应的最佳工具链版本
          OPENWRT_VERSION="${{ env.OPENWRT_VERSION }}"
          echo "OpenWrt版本: $OPENWRT_VERSION"
          
          # 根据OpenWrt版本选择默认版本
          case "$OPENWRT_VERSION" in
            "23.05.2"|"23.05.*")
              DEFAULT_GCC="12.3.0"
              DEFAULT_BINUTILS="2.40"
              DEFAULT_LINUX="5.15.133"
              DEFAULT_MUSL="1.2.4"
              DEFAULT_GLIBC="2.37"
              ;;
            "22.03.*")
              DEFAULT_GCC="11.3.0"
              DEFAULT_BINUTILS="2.38"
              DEFAULT_LINUX="5.10.179"
              DEFAULT_MUSL="1.2.3"
              DEFAULT_GLIBC="2.35"
              ;;
            "21.02.*")
              DEFAULT_GCC="10.3.0"
              DEFAULT_BINUTILS="2.36.1"
              DEFAULT_LINUX="5.4.188"
              DEFAULT_MUSL="1.2.2"
              DEFAULT_GLIBC="2.33"
              ;;
            *)
              DEFAULT_GCC="12.3.0"
              DEFAULT_BINUTILS="2.40"
              DEFAULT_LINUX="5.15.133"
              DEFAULT_MUSL="1.2.4"
              DEFAULT_GLIBC="2.37"
              ;;
          esac
          
          # 根据架构调整版本（某些架构需要特定的GCC版本）
          case "$TARGET_ARCH" in
            "riscv64")
              # RISC-V需要较新的GCC版本
              ARCH_GCC="13.2.0"
              ARCH_BINUTILS="2.41"
              echo "RISC-V架构，使用较新工具链版本"
              ;;
            "aarch64"|"arm_cortex-a53")
              # ARM64架构
              ARCH_GCC="12.3.0"
              ARCH_BINUTILS="2.40"
              ;;
            "arm_cortex-a7")
              # ARM32架构，兼容性较好
              ARCH_GCC="11.3.0"
              ARCH_BINUTILS="2.38"
              ;;
            "mips"|"mipsel")
              # MIPS架构，需要较老的版本
              ARCH_GCC="10.3.0"
              ARCH_BINUTILS="2.36.1"
              echo "MIPS架构，使用较老工具链版本以保证兼容性"
              ;;
            *)
              # 默认架构
              ARCH_GCC="$DEFAULT_GCC"
              ARCH_BINUTILS="$DEFAULT_BINUTILS"
              ;;
          esac
          
          # 根据C库类型调整
          if [ "$LIBC_TYPE" = "musl" ]; then
            # Musl通常需要较新的GCC
            LIBC_GCC="$ARCH_GCC"
          else
            # Glibc可以稍旧一些
            LIBC_GCC="$ARCH_GCC"
          fi
          
          # 最终版本选择逻辑
          if [ "$USER_VERSION" = "auto" ] || [ -z "$USER_VERSION" ]; then
            echo "使用智能版本选择..."
            GCC_VERSION="$LIBC_GCC"
            
            # 验证版本是否存在
            echo "验证GCC版本 $GCC_VERSION 是否存在..."
            if curl -s --head "https://ftp.gnu.org/gnu/gcc/gcc-$GCC_VERSION/gcc-$GCC_VERSION.tar.xz" | grep -q "200 OK"; then
              echo "✅ GCC $GCC_VERSION 可用"
            else
              echo "⚠️ GCC $GCC_VERSION 不可用，尝试备用版本"
              # 备用版本：尝试检测最新可用版本
              GCC_VERSION=$(curl -s https://ftp.gnu.org/gnu/gcc/ | grep -o 'gcc-[0-9]\+\.[0-9]\+\.[0-9]\+' | sort -Vr | head -1 | cut -d- -f2)
              if [ -z "$GCC_VERSION" ]; then
                GCC_VERSION="12.3.0"
                echo "⚠️ 无法检测最新版本，使用默认: $GCC_VERSION"
              fi
            fi
          else
            GCC_VERSION="$USER_VERSION"
            echo "使用用户指定版本: $GCC_VERSION"
            
            # 验证用户指定的版本
            echo "验证用户指定的GCC版本 $GCC_VERSION 是否存在..."
            if ! curl -s --head "https://ftp.gnu.org/gnu/gcc/gcc-$GCC_VERSION/gcc-$GCC_VERSION.tar.xz" | grep -q "200 OK"; then
              echo "❌ 用户指定的GCC版本 $GCC_VERSION 不存在或无法访问"
              echo "尝试查找可用的相近版本..."
              
              # 获取所有可用版本
              AVAILABLE_VERSIONS=$(curl -s https://ftp.gnu.org/gnu/gcc/ | grep -o 'gcc-[0-9]\+\.[0-9]\+\.[0-9]\+' | sort -Vr | cut -d- -f2)
              
              # 查找相近版本
              MAJOR_VERSION=$(echo "$GCC_VERSION" | cut -d. -f1)
              SIMILAR_VERSIONS=$(echo "$AVAILABLE_VERSIONS" | grep "^$MAJOR_VERSION\.")
              
              if [ -n "$SIMILAR_VERSIONS" ]; then
                NEW_VERSION=$(echo "$SIMILAR_VERSIONS" | head -1)
                echo "找到相近版本: $NEW_VERSION"
                GCC_VERSION="$NEW_VERSION"
              else
                # 使用架构推荐的版本
                echo "使用架构推荐版本: $ARCH_GCC"
                GCC_VERSION="$ARCH_GCC"
              fi
            fi
          fi
          
          # 根据GCC版本选择合适的Binutils版本
          echo "根据GCC $GCC_VERSION 选择Binutils版本..."
          GCC_MAJOR=$(echo "$GCC_VERSION" | cut -d. -f1)
          
          case $GCC_MAJOR in
            13|14)
              BINUTILS_VERSION="2.41"
              ;;
            12)
              BINUTILS_VERSION="2.40"
              ;;
            11)
              BINUTILS_VERSION="2.38"
              ;;
            10)
              BINUTILS_VERSION="2.36.1"
              ;;
            9)
              BINUTILS_VERSION="2.34"
              ;;
            8)
              BINUTILS_VERSION="2.32"
              ;;
            *)
              BINUTILS_VERSION="$DEFAULT_BINUTILS"
              ;;
          esac
          
          # 验证Binutils版本
          echo "验证Binutils版本 $BINUTILS_VERSION..."
          if ! curl -s --head "https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS_VERSION.tar.xz" | grep -q "200 OK"; then
            echo "⚠️ Binutils $BINUTILS_VERSION 不可用，尝试检测最新版本"
            BINUTILS_VERSION=$(curl -s https://ftp.gnu.org/gnu/binutils/ | grep -o 'binutils-[0-9]\+\.[0-9]\+\.[0-9]\+' | sort -Vr | head -1 | cut -d- -f2)
          fi
          
          # 设置其他版本
          LINUX_VERSION="$DEFAULT_LINUX"
          MUSL_VERSION="$DEFAULT_MUSL"
          GLIBC_VERSION="$DEFAULT_GLIBC"
          
          echo "🎯 最终版本选择:"
          echo "- 目标架构: $TARGET_ARCH"
          echo "- C库类型: $LIBC_TYPE"
          echo "- GCC版本: $GCC_VERSION (主版本: $GCC_MAJOR)"
          echo "- Binutils版本: $BINUTILS_VERSION"
          echo "- Linux内核: $LINUX_VERSION"
          echo "- Musl版本: $MUSL_VERSION"
          echo "- Glibc版本: $GLIBC_VERSION"
          echo ""
          echo "📊 版本选择说明:"
          echo "1. OpenWrt $OPENWRT_VERSION → GCC $DEFAULT_GCC"
          echo "2. 架构 $TARGET_ARCH → 适配版本"
          echo "3. 版本验证 → 确保可用性"
          
          # 设置输出变量
          echo "gcc_version=$GCC_VERSION" >> $GITHUB_OUTPUT
          echo "binutils_version=$BINUTILS_VERSION" >> $GITHUB_OUTPUT
          echo "linux_version=$LINUX_VERSION" >> $GITHUB_OUTPUT
          echo "musl_version=$MUSL_VERSION" >> $GITHUB_OUTPUT
          echo "glibc_version=$GLIBC_VERSION" >> $GITHUB_OUTPUT
          
          # 同时设置到环境变量以便调试
          echo "DEBUG_GCC_VERSION=$GCC_VERSION" >> $GITHUB_ENV
          echo "DEBUG_BINUTILS_VERSION=$BINUTILS_VERSION" >> $GITHUB_ENV

      - name: 🔎 检查现有编译器
        id: check-existing
        run: |
          echo "=== 检查现有编译器 ==="
          ARCH="${{ github.event.inputs.target_arch }}"
          LIBC="${{ github.event.inputs.libc }}"
          GCC_VERSION='${{ steps.version-detection.outputs.gcc_version }}'
          BINUTILS_VERSION='${{ steps.version-detection.outputs.binutils_version }}'
          
          echo "检查版本变量:"
          echo "- GCC_VERSION: '$GCC_VERSION'"
          echo "- BINUTILS_VERSION: '$BINUTILS_VERSION'"
          
          if [ "$LIBC" = "musl" ]; then
            LIBC_DIR="musl"
          else
            LIBC_DIR="glibc"
          fi
          
          OUTPUT_DIR="${{ env.COMPILER_BASE_DIR }}/${ARCH}/${LIBC_DIR}/gcc-${GCC_VERSION}_binutils-${BINUTILS_VERSION}"
          
          echo "检查目录: $OUTPUT_DIR"
          echo "完整路径: $(realpath "$OUTPUT_DIR" 2>/dev/null || echo "$OUTPUT_DIR")"
          
          # 先检查目录是否存在
          if [ -d "$OUTPUT_DIR" ]; then
            echo "✅ 编译器目录已存在"
            echo "目录内容:"
            ls -la "$OUTPUT_DIR/" 2>/dev/null | head -10
            
            # 检查目录是否完整
            REQUIRED_DIRS=("bin" "lib" "include" "libexec")
            REQUIRED_FILES=("*-gcc" "*-g++" "*-ld" "*-ar")
            
            MISSING_ITEMS=()
            
            # 检查必要目录
            for dir in "${REQUIRED_DIRS[@]}"; do
              if [ ! -d "$OUTPUT_DIR/$dir" ]; then
                MISSING_ITEMS+=("目录 $dir")
                echo "  ❌ 缺少目录: $dir"
              else
                echo "  ✅ 目录存在: $dir (文件数: $(find "$OUTPUT_DIR/$dir" -type f 2>/dev/null | wc -l))"
              fi
            done
            
            # 检查必要文件
            for file_pattern in "${REQUIRED_FILES[@]}"; do
              found_file=$(find "$OUTPUT_DIR" -name "$file_pattern" -type f 2>/dev/null | head -1)
              if [ -n "$found_file" ]; then
                echo "  ✅ 找到文件: $(basename "$found_file")"
              else
                MISSING_ITEMS+=("文件 $file_pattern")
                echo "  ❌ 缺少文件: $file_pattern"
              fi
            done
            
            # 检查版本匹配
            echo "检查版本信息..."
            if [ -f "$OUTPUT_DIR/metadata.json" ]; then
              echo "找到元数据文件"
              STORED_GCC=$(jq -r '.gcc_version' "$OUTPUT_DIR/metadata.json" 2>/dev/null)
              STORED_BINUTILS=$(jq -r '.binutils_version' "$OUTPUT_DIR/metadata.json" 2>/dev/null)
              
              if [ "$STORED_GCC" = "$GCC_VERSION" ] && [ "$STORED_BINUTILS" = "$BINUTILS_VERSION" ]; then
                echo "  ✅ 版本匹配: GCC $STORED_GCC, Binutils $STORED_BINUTILS"
              else
                echo "  ⚠️ 版本不匹配"
                echo "    存储: GCC $STORED_GCC, Binutils $STORED_BINUTILS"
                echo "    请求: GCC $GCC_VERSION, Binutils $BINUTILS_VERSION"
                MISSING_ITEMS+=("版本不匹配")
              fi
            else
              echo "  ⚠️ 未找到元数据文件"
            fi
            
            if [ ${#MISSING_ITEMS[@]} -eq 0 ]; then
              echo "✅ 编译器文件完整"
              
              if [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
                echo "⚠️ 强制重新构建已启用"
                NEED_BUILD="true"
              else
                echo "✅ 跳过构建，使用现有编译器"
                NEED_BUILD="false"
              fi
            else
              echo "⚠️ 编译器不完整，缺少:"
              for item in "${MISSING_ITEMS[@]}"; do
                echo "  - $item"
              done
              NEED_BUILD="true"
            fi
          else
            echo "❌ 编译器目录不存在，需要构建"
            echo "尝试列出父目录内容:"
            ls -la "$(dirname "$OUTPUT_DIR")" 2>/dev/null || echo "父目录不存在"
            NEED_BUILD="true"
          fi
          
          echo "构建决策: $NEED_BUILD"
          echo "need_build=$NEED_BUILD" >> $GITHUB_OUTPUT

  build-compiler:
    needs: [show-device-info, setup]
    if: needs.setup.outputs.need_build == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    
    steps:
      - name: 📥 检出仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 📋 显示构建信息
        run: |
          echo "========================================"
          echo "        交叉编译器构建信息              "
          echo "========================================"
          echo "目标架构: ${{ github.event.inputs.target_arch }}"
          echo "C库类型: ${{ github.event.inputs.libc }}"
          echo "GCC版本: ${{ needs.setup.outputs.gcc_version }}"
          echo "Binutils版本: ${{ needs.setup.outputs.binutils_version }}"
          echo "Linux内核: ${{ needs.setup.outputs.linux_version }}"
          echo "Musl版本: ${{ needs.setup.outputs.musl_version }}"
          echo "Glibc版本: ${{ needs.setup.outputs.glibc_version }}"
          echo "OpenWrt版本: ${{ env.OPENWRT_VERSION }}"
          echo "强制重建: ${{ github.event.inputs.force_rebuild }}"
          echo "清理构建: ${{ github.event.inputs.clean_build }}"
          echo "构建需求: ${{ needs.setup.outputs.need_build }}"
          echo "========================================"
          echo "开始时间: $(date)"
          echo "运行ID: ${{ github.run_id }}"
          echo "运行序号: ${{ github.run_number }}"
          echo "版本选择策略:"
          echo "- 根据OpenWrt版本选择基础版本"
          echo "- 根据目标架构调整版本"
          echo "- 验证版本可用性"
          echo "========================================"

      - name: 🏗️ 设置环境
        run: |
          echo "=== 设置构建环境 ==="
          ARCH="${{ github.event.inputs.target_arch }}"
          LIBC="${{ github.event.inputs.libc }}"
          echo "处理架构: $ARCH"
          echo "处理C库: $LIBC"
          
          case "$ARCH" in
            arm_cortex-a7)
              TARGET="armvirt"
              SUBTARGET="armv7"
              ARCH_NAME="arm"
              ARCH_DIR="arm_cortex-a7"
              PREFIX="arm-openwrt-linux"
              CPU_TYPE="cortex-a7"
              TUNE="cortex-a7"
              ABI="32"
              FLOAT_ABI="hard"
              ;;
            aarch64)
              TARGET="armvirt"
              SUBTARGET="64"
              ARCH_NAME="aarch64"
              ARCH_DIR="aarch64"
              PREFIX="aarch64-openwrt-linux"
              CPU_TYPE="cortex-a53"
              TUNE="cortex-a53"
              ABI="64"
              FLOAT_ABI=""
              ;;
            x86_64)
              TARGET="x86"
              SUBTARGET="64"
              ARCH_NAME="x86_64"
              ARCH_DIR="x86_64"
              PREFIX="x86_64-openwrt-linux"
              CPU_TYPE="x86_64"
              TUNE="generic"
              ABI="64"
              FLOAT_ABI=""
              ;;
            mips)
              TARGET="ramips"
              SUBTARGET="mt7621"
              ARCH_NAME="mips"
              ARCH_DIR="mips"
              PREFIX="mips-openwrt-linux"
              CPU_TYPE="24kc"
              TUNE="24kc"
              ABI="32"
              FLOAT_ABI="softfloat"
              ;;
            mipsel)
              TARGET="ramips"
              SUBTARGET="mt7621"
              ARCH_NAME="mipsel"
              ARCH_DIR="mipsel"
              PREFIX="mipsel-openwrt-linux"
              CPU_TYPE="24kc"
              TUNE="24kc"
              ABI="32"
              FLOAT_ABI="softfloat"
              ;;
            arm_cortex-a53)
              TARGET="rockchip"
              SUBTARGET="armv8"
              ARCH_NAME="aarch64"
              ARCH_DIR="arm_cortex-a53"
              PREFIX="aarch64-openwrt-linux"
              CPU_TYPE="cortex-a53"
              TUNE="cortex-a53"
              ABI="64"
              FLOAT_ABI=""
              ;;
            riscv64)
              TARGET="virt"
              SUBTARGET="rv64"
              ARCH_NAME="riscv64"
              ARCH_DIR="riscv64"
              PREFIX="riscv64-openwrt-linux"
              CPU_TYPE="generic"
              TUNE="generic"
              ABI="lp64d"
              FLOAT_ABI="hard"
              ;;
            *)
              echo "❌ 不支持的架构: $ARCH"
              exit 1
              ;;
          esac
          
          if [ "$LIBC" = "musl" ]; then
            PREFIX="${PREFIX}-musl"
            LIBC_SUFFIX="musl"
            LIBC_DIR="musl"
            USE_MUSL="y"
            USE_GLIBC="n"
            LIBC_VERSION='${{ needs.setup.outputs.musl_version }}'
          else
            PREFIX="${PREFIX}-gnu"
            LIBC_SUFFIX="glibc"
            LIBC_DIR="glibc"
            USE_MUSL="n"
            USE_GLIBC="y"
            LIBC_VERSION='${{ needs.setup.outputs.glibc_version }}'
          fi
          
          # 从setup作业获取版本
          GCC_VERSION='${{ needs.setup.outputs.gcc_version }}'
          BINUTILS_VERSION='${{ needs.setup.outputs.binutils_version }}'
          LINUX_VERSION='${{ needs.setup.outputs.linux_version }}'
          
          BUILD_ID="${ARCH_DIR}_${LIBC_DIR}_gcc-${GCC_VERSION}_binutils-${BINUTILS_VERSION}_$(date +%Y%m%d_%H%M%S)"
          BUILD_DIR="/tmp/compiler-build-${BUILD_ID}"
          OUTPUT_DIR="${{ env.COMPILER_BASE_DIR }}/${ARCH_DIR}/${LIBC_DIR}/gcc-${GCC_VERSION}_binutils-${BINUTILS_VERSION}"
          
          echo "📊 环境配置汇总:"
          echo "  构建ID: $BUILD_ID"
          echo "  构建目录: $BUILD_DIR"
          echo "  输出目录: $OUTPUT_DIR"
          echo "  目标平台: $TARGET/$SUBTARGET"
          echo "  架构名称: $ARCH_NAME"
          echo "  架构目录: $ARCH_DIR"
          echo "  C库目录: $LIBC_DIR"
          echo "  C库版本: $LIBC_VERSION"
          echo "  编译器前缀: $PREFIX-"
          echo "  CPU类型: $CPU_TYPE"
          echo "  调优: $TUNE"
          echo "  ABI: $ABI"
          echo "  浮点ABI: $FLOAT_ABI"
          echo "  GCC版本: $GCC_VERSION"
          echo "  Binutils版本: $BINUTILS_VERSION"
          echo "  Linux内核版本: $LINUX_VERSION"
          
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "OUTPUT_DIR=$OUTPUT_DIR" >> $GITHUB_ENV
          echo "TARGET=$TARGET" >> $GITHUB_ENV
          echo "SUBTARGET=$SUBTARGET" >> $GITHUB_ENV
          echo "ARCH_NAME=$ARCH_NAME" >> $GITHUB_ENV
          echo "ARCH_DIR=$ARCH_DIR" >> $GITHUB_ENV
          echo "LIBC_DIR=$LIBC_DIR" >> $GITHUB_ENV
          echo "LIBC_VERSION=$LIBC_VERSION" >> $GITHUB_ENV
          echo "PREFIX=$PREFIX" >> $GITHUB_ENV
          echo "CPU_TYPE=$CPU_TYPE" >> $GITHUB_ENV
          echo "TUNE=$TUNE" >> $GITHUB_ENV
          echo "ABI=$ABI" >> $GITHUB_ENV
          echo "FLOAT_ABI=$FLOAT_ABI" >> $GITHUB_ENV
          echo "USE_MUSL=$USE_MUSL" >> $GITHUB_ENV
          echo "USE_GLIBC=$USE_GLIBC" >> $GITHUB_ENV
          echo "GCC_VERSION=$GCC_VERSION" >> $GITHUB_ENV
          echo "BINUTILS_VERSION=$BINUTILS_VERSION" >> $GITHUB_ENV
          echo "LINUX_VERSION=$LINUX_VERSION" >> $GITHUB_ENV
          echo "LIBC_SUFFIX=$LIBC_SUFFIX" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV

      - name: 🔧 安装依赖（根据版本调整）
        run: |
          echo "=== 安装构建依赖 ==="
          echo "开始时间: $(date)"
          echo "GCC版本: ${{ env.GCC_VERSION }}"
          GCC_MAJOR=$(echo "${{ env.GCC_VERSION }}" | cut -d. -f1)
          
          echo "更新软件包列表..."
          sudo apt-get update
          
          echo "安装基础构建工具..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
            build-essential \
            gcc g++ make \
            flex bison \
            git wget curl \
            file gawk gettext \
            rsync unzip \
            autoconf automake autopoint libtool \
            pkg-config texinfo \
            gperf cmake ninja-build \
            patchutils bc \
            bzip2 xz-utils \
            help2man \
            jq info install-info \
            liblzma-dev zstd libzstd-dev \
            libexpat-dev libgdbm-dev libreadline-dev libsqlite3-dev libffi-dev \
            libelf-dev libdw-dev libcap-dev libattr1-dev libaudit-dev libiberty-dev
          
          echo "安装版本特定的依赖..."
          
          # 根据GCC版本安装特定依赖
          if [ $GCC_MAJOR -ge 13 ]; then
            echo "GCC 13+ 需要较新的依赖..."
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
              libgmp-dev libmpfr-dev libmpc-dev libisl-dev \
              libgnutls28-dev libcurl4-gnutls-dev \
              python3 python3-dev python3-distutils \
              libncurses5-dev libssl-dev \
              gnutls-bin \
              liblzma-dev zlib1g-dev
          elif [ $GCC_MAJOR -ge 11 ]; then
            echo "GCC 11-12 依赖..."
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
              libgmp-dev libmpfr-dev libmpc-dev libisl-dev \
              libgnutls28-dev libcurl4-gnutls-dev \
              python3 python3-dev python3-distutils \
              libncurses5-dev libssl-dev \
              gnutls-bin \
              liblzma-dev zlib1g-dev
          else
            echo "GCC 10及以下版本依赖..."
            sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
              libgmp-dev libmpfr-dev libmpc-dev libisl-dev \
              libgnutls28-dev \
              python3 python3-dev \
              libncurses5-dev libssl-dev \
              liblzma-dev zlib1g-dev
          fi
          
          # 根据架构安装特定依赖
          ARCH="${{ github.event.inputs.target_arch }}"
          case "$ARCH" in
            "riscv64")
              echo "RISC-V架构需要额外的依赖..."
              sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
                device-tree-compiler \
                qemu-system-riscv64 \
                libfdt-dev
              ;;
            "aarch64"|"arm_cortex-a7"|"arm_cortex-a53")
              echo "ARM架构依赖..."
              sudo DEBIAN_FRONTEND=noninteractive apt-get install -y \
                gcc-aarch64-linux-gnu \
                gcc-arm-linux-gnueabihf
              ;;
          esac
          
          echo "✅ 依赖安装完成"
          echo "安装的包版本:"
          gcc --version | head -1
          make --version | head -1
          python3 --version
          echo "结束时间: $(date)"

      - name: 🗑️ 清理构建缓存
        if: ${{ github.event.inputs.clean_build == 'true' }}
        run: |
          echo "=== 清理构建缓存 ==="
          echo "开始清理缓存..."
          sudo rm -rf /tmp/compiler-build-* 2>/dev/null || true
          echo "✅ 缓存清理完成"

      - name: 📥 下载OpenWrt源码
        run: |
          echo "=== 获取OpenWrt源码 ==="
          echo "开始时间: $(date)"
          mkdir -p "${{ env.BUILD_DIR }}"
          cd "${{ env.BUILD_DIR }}"
          echo "当前目录: $(pwd)"
          echo "克隆OpenWrt ${{ env.OPENWRT_VERSION }} 分支..."
          
          # 尝试不同的克隆方式
          echo "尝试方法1: 克隆指定分支..."
          if git clone --depth 1 --branch "v${{ env.OPENWRT_VERSION }}" https://github.com/openwrt/openwrt.git .; then
            echo "✅ Git clone成功"
          else
            echo "方法1失败，尝试方法2: 克隆主分支然后切换..."
            git clone --depth 1 https://github.com/openwrt/openwrt.git .
            if git checkout "v${{ env.OPENWRT_VERSION }}"; then
              echo "✅ 切换版本成功"
            else
              echo "方法2失败，尝试方法3: 使用tar包..."
              wget -q --show-progress -O openwrt.tar.xz "https://github.com/openwrt/openwrt/archive/refs/tags/v${{ env.OPENWRT_VERSION }}.tar.gz"
              if [ $? -eq 0 ]; then
                tar -xzf openwrt.tar.xz --strip-components=1
                rm -f openwrt.tar.xz
                echo "✅ 使用tar包下载成功"
              else
                echo "❌ 所有下载方法都失败"
                exit 1
              fi
            fi
          fi
          
          echo "源码大小: $(du -sh . | cut -f1)"
          echo "OpenWrt版本确认:"
          grep "VERSION_NUMBER" include/version.mk 2>/dev/null || echo "版本文件未找到"
          echo "结束时间: $(date)"

      - name: 📝 生成配置文件（强制覆盖）
        run: |
          echo "=== 生成OpenWrt配置（强制覆盖）==="
          echo "开始时间: $(date)"
          cd "${{ env.BUILD_DIR }}"
          echo "当前目录: $(pwd)"
          
          echo "使用版本:"
          echo "- GCC: ${{ env.GCC_VERSION }}"
          echo "- Binutils: ${{ env.BINUTILS_VERSION }}"
          echo "- Linux: ${{ env.LINUX_VERSION }}"
          echo "- C库版本: ${{ env.LIBC_VERSION }}"
          echo "- C库类型: ${{ env.LIBC_DIR }}"
          echo "- 目标: ${{ env.TARGET }}"
          echo "- 子目标: ${{ env.SUBTARGET }}"
          echo "- 架构: ${{ env.ARCH_NAME }}"
          echo "- 编译器前缀: ${{ env.PREFIX }}-"
          
          echo "步骤1: 清理所有现有配置..."
          rm -f .config .config.old .config.cmd 2>/dev/null || true
          
          echo "步骤2: 创建site配置目录..."
          mkdir -p include/site
          
          echo "步骤3: 生成site配置..."
          echo "ac_cv_sys_file_offset_bits=64" > include/site/${{ env.ARCH_NAME }}
          echo "ac_cv_sys_large_files=yes" >> include/site/${{ env.ARCH_NAME }}
          
          # 设置字节序
          case "${{ env.ARCH_NAME }}" in
            "mips")
              echo "ac_cv_c_bigendian=yes" >> include/site/${{ env.ARCH_NAME }}
              ;;
            *)
              echo "ac_cv_c_bigendian=no" >> include/site/${{ env.ARCH_NAME }}
              ;;
          esac
          
          CONFIG_FILE=".config"
          echo "步骤4: 生成主配置文件: $CONFIG_FILE"
          
          # 生成完整的配置
          cat > $CONFIG_FILE << EOF
# 目标配置
CONFIG_TARGET_${{ env.TARGET }}=y
CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y
CONFIG_TARGET_ARCH="${{ env.ARCH_NAME }}"
CONFIG_TARGET_PREFIX="${{ env.PREFIX }}-"
CONFIG_EXTERNAL_TOOLCHAIN=n
CONFIG_USE_MUSL=${{ env.USE_MUSL }}
CONFIG_BUILD_TOOLCHAIN=y
CONFIG_GCC_VERSION="${{ env.GCC_VERSION }}"
CONFIG_BINUTILS_VERSION="${{ env.BINUTILS_VERSION }}"
CONFIG_LINUX_VERSION="${{ env.LINUX_VERSION }}"
EOF

          # 根据C库类型添加配置
          if [ "${{ env.USE_MUSL }}" = "y" ]; then
            cat >> $CONFIG_FILE << EOF
CONFIG_MUSL_VERSION="${{ env.LIBC_VERSION }}"
EOF
          else
            cat >> $CONFIG_FILE << EOF
CONFIG_GLIBC_VERSION="${{ env.LIBC_VERSION }}"
EOF
          fi
          
          # 添加优化配置
          cat >> $CONFIG_FILE << EOF
# 优化构建配置
CONFIG_ALL=n
CONFIG_ALL_KMODS=n
CONFIG_ALL_NONSHARED=n
CONFIG_DEVEL=y
CONFIG_CCACHE=n
CONFIG_TARGET_ROOTFS_INITRAMFS=y
CONFIG_SDK=y
CONFIG_STRIP_KERNEL_EXPORTS=y
CONFIG_BUILD_PATENTED=y
CONFIG_BUILD_NLS=y
CONFIG_USE_LIBSTDCXX=y
EOF

          # 根据GCC版本添加优化选项
          GCC_MAJOR=$(echo "${{ env.GCC_VERSION }}" | cut -d. -f1)
          if [ $GCC_MAJOR -ge 11 ]; then
            cat >> $CONFIG_FILE << EOF
# GCC 11+ 优化选项
CONFIG_GCC_USE_VERSION_${GCC_MAJOR}=y
CONFIG_GCC_USE_GRAPHITE=y
EOF
          fi
          
          # 禁用不需要的目标（防止默认配置覆盖）
          cat >> $CONFIG_FILE << EOF
# 禁用其他目标（防止默认配置覆盖）
CONFIG_TARGET_ath79=n
CONFIG_TARGET_ath79_generic=n
CONFIG_TARGET_bcm27xx=n
CONFIG_TARGET_bcm53xx=n
CONFIG_TARGET_ipq40xx=n
CONFIG_TARGET_ipq806x=n
CONFIG_TARGET_lantiq=n
CONFIG_TARGET_layerscape=n
CONFIG_TARGET_mediatek=n
CONFIG_TARGET_mpc85xx=n
CONFIG_TARGET_mvebu=n
CONFIG_TARGET_octeon=n
CONFIG_TARGET_octeontx=n
CONFIG_TARGET_oxnas=n
CONFIG_TARGET_pistachio=n
CONFIG_TARGET_ramips=n
CONFIG_TARGET_rockchip=n
CONFIG_TARGET_sunxi=n
CONFIG_TARGET_tegra=n
CONFIG_TARGET_x86=n
CONFIG_TARGET_arc=n
CONFIG_TARGET_arm64=n
CONFIG_TARGET_armsr=n
CONFIG_TARGET_bcm47xx=n
CONFIG_TARGET_bcm4908=n
CONFIG_TARGET_bmips=n
CONFIG_TARGET_brcm2708=n
CONFIG_TARGET_brcm47xx=n
CONFIG_TARGET_brcm63xx=n
CONFIG_TARGET_cns3xxx=n
CONFIG_TARGET_gemini=n
CONFIG_TARGET_imx6=n
CONFIG_TARGET_kirkwood=n
CONFIG_TARGET_malta=n
CONFIG_TARGET_mxs=n
CONFIG_TARGET_omap=n
CONFIG_TARGET_orion=n
CONFIG_TARGET_pxa=n
CONFIG_TARGET_samsung=n
CONFIG_TARGET_sifiveu=n
CONFIG_TARGET_socfpga=n
CONFIG_TARGET_uml=n
CONFIG_TARGET_zynq=n
EOF

          # 最后再次确认我们的目标
          cat >> $CONFIG_FILE << EOF
# 确认启用我们的目标
CONFIG_TARGET_${{ env.TARGET }}=y
CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y
EOF
          
          echo "配置文件大小: $(wc -l < $CONFIG_FILE) 行"
          echo "配置摘要:"
          echo "------------------------------"
          cat $CONFIG_FILE | grep -E "CONFIG_TARGET_|CONFIG_GCC|CONFIG_BINUTILS|CONFIG_.*LIBC|CONFIG_USE_MUSL|CONFIG_BUILD_TOOLCHAIN|CONFIG_TARGET_ARCH"
          echo "------------------------------"
          
          # 验证配置是否正确写入
          echo "验证配置..."
          if grep -q "CONFIG_GCC_VERSION=\"${{ env.GCC_VERSION }}\"" $CONFIG_FILE; then
            echo "✅ GCC版本正确写入: ${{ env.GCC_VERSION }}"
          else
            echo "❌ GCC版本未正确写入"
            exit 1
          fi
          
          if grep -q "CONFIG_TARGET_${{ env.TARGET }}=y" $CONFIG_FILE; then
            echo "✅ 目标正确设置: ${{ env.TARGET }}"
          else
            echo "❌ 目标未正确设置"
            exit 1
          fi
          
          if grep -q "CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\"" $CONFIG_FILE; then
            echo "✅ 架构正确设置: ${{ env.ARCH_NAME }}"
          else
            echo "❌ 架构未正确设置"
            exit 1
          fi
          
          if [ "${{ env.USE_MUSL }}" = "y" ]; then
            if grep -q "CONFIG_MUSL_VERSION=\"${{ env.LIBC_VERSION }}\"" $CONFIG_FILE; then
              echo "✅ Musl版本正确写入: ${{ env.LIBC_VERSION }}"
            else
              echo "❌ Musl版本未正确写入"
              exit 1
            fi
          else
            if grep -q "CONFIG_GLIBC_VERSION=\"${{ env.LIBC_VERSION }}\"" $CONFIG_FILE; then
              echo "✅ Glibc版本正确写入: ${{ env.LIBC_VERSION }}"
            else
              echo "❌ Glibc版本未正确写入"
              exit 1
            fi
          fi
          
          echo "✅ 配置文件生成完成"
          echo "结束时间: $(date)"

      - name: 🛠️ 应用配置（强制）
        run: |
          echo "=== 应用配置（强制）==="
          echo "开始时间: $(date)"
          cd "${{ env.BUILD_DIR }}"
          
          echo "步骤1: 显示当前.config文件..."
          echo "前30行内容:"
          head -30 .config
          
          echo "步骤2: 备份当前配置..."
          cp .config .config.backup
          
          echo "步骤3: 运行defconfig..."
          make defconfig 2>&1 | tee /tmp/defconfig1.log
          DEFCONFIG_STATUS=${PIPESTATUS[0]}
          
          if [ $DEFCONFIG_STATUS -eq 0 ]; then
            echo "✅ defconfig成功"
          else
            echo "⚠️ defconfig有警告，状态码: $DEFCONFIG_STATUS"
          fi
          
          echo "步骤4: 检查并修复配置..."
          
          # 检查工具链配置
          echo "🔧 工具链配置检查:"
          
          # 确保构建工具链启用
          if ! grep -q "CONFIG_BUILD_TOOLCHAIN=y" .config; then
            echo "❌ 构建工具链未启用，手动启用..."
            echo "CONFIG_BUILD_TOOLCHAIN=y" >> .config
          else
            echo "✅ 构建工具链已启用"
          fi
          
          # 检查GCC版本
          GCC_CONF=$(grep 'CONFIG_GCC_VERSION=' .config | cut -d'"' -f2)
          EXPECTED_GCC="${{ env.GCC_VERSION }}"
          echo "GCC版本: 配置=$GCC_CONF, 期望=$EXPECTED_GCC"
          if [ "$GCC_CONF" != "$EXPECTED_GCC" ]; then
            echo "❌ GCC版本不匹配，手动修复..."
            sed -i "/CONFIG_GCC_VERSION=/d" .config
            echo "CONFIG_GCC_VERSION=\"$EXPECTED_GCC\"" >> .config
            echo "✅ GCC版本修复为: $EXPECTED_GCC"
          else
            echo "✅ GCC版本匹配"
          fi
          
          # 检查Binutils版本
          BINUTILS_CONF=$(grep 'CONFIG_BINUTILS_VERSION=' .config | cut -d'"' -f2)
          EXPECTED_BINUTILS="${{ env.BINUTILS_VERSION }}"
          echo "Binutils版本: 配置=$BINUTILS_CONF, 期望=$EXPECTED_BINUTILS"
          if [ "$BINUTILS_CONF" != "$EXPECTED_BINUTILS" ]; then
            echo "❌ Binutils版本不匹配，手动修复..."
            sed -i "/CONFIG_BINUTILS_VERSION=/d" .config
            echo "CONFIG_BINUTILS_VERSION=\"$EXPECTED_BINUTILS\"" >> .config
            echo "✅ Binutils版本修复为: $EXPECTED_BINUTILS"
          else
            echo "✅ Binutils版本匹配"
          fi
          
          # 检查Linux内核版本
          LINUX_CONF=$(grep 'CONFIG_LINUX_VERSION=' .config | cut -d'"' -f2)
          EXPECTED_LINUX="${{ env.LINUX_VERSION }}"
          echo "Linux内核版本: 配置=$LINUX_CONF, 期望=$EXPECTED_LINUX"
          if [ "$LINUX_CONF" != "$EXPECTED_LINUX" ]; then
            echo "❌ Linux内核版本不匹配，手动修复..."
            sed -i "/CONFIG_LINUX_VERSION=/d" .config
            echo "CONFIG_LINUX_VERSION=\"$EXPECTED_LINUX\"" >> .config
            echo "✅ Linux内核版本修复为: $EXPECTED_LINUX"
          else
            echo "✅ Linux内核版本匹配"
          fi
          
          # 检查C库配置
          echo "📚 C库配置检查:"
          if [ "${{ env.USE_MUSL }}" = "y" ]; then
            if ! grep -q "CONFIG_USE_MUSL=y" .config; then
              echo "❌ Musl未启用，手动启用..."
              sed -i "/CONFIG_USE_MUSL=/d" .config
              echo "CONFIG_USE_MUSL=y" >> .config
            else
              echo "✅ Musl已启用"
            fi
            
            MUSL_CONF=$(grep 'CONFIG_MUSL_VERSION=' .config | cut -d'"' -f2)
            EXPECTED_MUSL="${{ env.LIBC_VERSION }}"
            echo "Musl版本: 配置=$MUSL_CONF, 期望=$EXPECTED_MUSL"
            if [ "$MUSL_CONF" != "$EXPECTED_MUSL" ]; then
              echo "❌ Musl版本不匹配，手动修复..."
              sed -i "/CONFIG_MUSL_VERSION=/d" .config
              echo "CONFIG_MUSL_VERSION=\"$EXPECTED_MUSL\"" >> .config
              echo "✅ Musl版本修复为: $EXPECTED_MUSL"
            else
              echo "✅ Musl版本匹配"
            fi
          else
            if ! grep -q "CONFIG_USE_MUSL=n" .config; then
              echo "❌ Glibc未正确配置，手动配置..."
              sed -i "/CONFIG_USE_MUSL=/d" .config
              echo "CONFIG_USE_MUSL=n" >> .config
            else
              echo "✅ Glibc已启用"
            fi
            
            GLIBC_CONF=$(grep 'CONFIG_GLIBC_VERSION=' .config | cut -d'"' -f2)
            EXPECTED_GLIBC="${{ env.LIBC_VERSION }}"
            echo "Glibc版本: 配置=$GLIBC_CONF, 期望=$EXPECTED_GLIBC"
            if [ "$GLIBC_CONF" != "$EXPECTED_GLIBC" ]; then
              echo "❌ Glibc版本不匹配，手动修复..."
              sed -i "/CONFIG_GLIBC_VERSION=/d" .config
              echo "CONFIG_GLIBC_VERSION=\"$EXPECTED_GLIBC\"" >> .config
              echo "✅ Glibc版本修复为: $EXPECTED_GLIBC"
            else
              echo "✅ Glibc版本匹配"
            fi
          fi
          
          # 检查目标配置
          echo "🎯 目标平台检查:"
          
          # 检查目标
          TARGET_CONF=$(grep 'CONFIG_TARGET_' .config | grep '=y' | head -1 | cut -d'=' -f1 | sed 's/CONFIG_TARGET_//')
          EXPECTED_TARGET="${{ env.TARGET }}"
          echo "目标: 配置=$TARGET_CONF, 期望=$EXPECTED_TARGET"
          if [ "$TARGET_CONF" != "$EXPECTED_TARGET" ]; then
            echo "❌ 目标不匹配，手动修复..."
            # 禁用所有目标
            sed -i '/CONFIG_TARGET_[a-zA-Z0-9]*=y/d' .config
            # 启用我们的目标
            echo "CONFIG_TARGET_$EXPECTED_TARGET=y" >> .config
            echo "CONFIG_TARGET_${EXPECTED_TARGET}_${{ env.SUBTARGET }}=y" >> .config
            echo "✅ 目标修复为: $EXPECTED_TARGET"
          else
            echo "✅ 目标匹配"
          fi
          
          # 检查架构
          ARCH_CONF=$(grep 'CONFIG_TARGET_ARCH=' .config | cut -d'"' -f2)
          EXPECTED_ARCH="${{ env.ARCH_NAME }}"
          echo "架构: 配置=$ARCH_CONF, 期望=$EXPECTED_ARCH"
          if [ "$ARCH_CONF" != "$EXPECTED_ARCH" ]; then
            echo "❌ 架构不匹配，手动修复..."
            sed -i "/CONFIG_TARGET_ARCH=/d" .config
            echo "CONFIG_TARGET_ARCH=\"$EXPECTED_ARCH\"" >> .config
            echo "✅ 架构修复为: $EXPECTED_ARCH"
          else
            echo "✅ 架构匹配"
          fi
          
          # 检查编译器前缀
          PREFIX_CONF=$(grep 'CONFIG_TARGET_PREFIX=' .config | cut -d'"' -f2)
          EXPECTED_PREFIX="${{ env.PREFIX }}-"
          echo "编译器前缀: 配置=$PREFIX_CONF, 期望=$EXPECTED_PREFIX"
          if [ "$PREFIX_CONF" != "$EXPECTED_PREFIX" ]; then
            echo "❌ 编译器前缀不匹配，手动修复..."
            sed -i "/CONFIG_TARGET_PREFIX=/d" .config
            echo "CONFIG_TARGET_PREFIX=\"$EXPECTED_PREFIX\"" >> .config
            echo "✅ 编译器前缀修复为: $EXPECTED_PREFIX"
          else
            echo "✅ 编译器前缀匹配"
          fi
          
          echo "步骤5: 再次运行defconfig确保配置一致..."
          make defconfig 2>&1 | tee /tmp/defconfig2.log
          
          echo "步骤6: 显示最终配置摘要..."
          echo "=============================="
          echo "        最终配置摘要          "
          echo "=============================="
          
          # 显示关键配置
          echo "🔧 关键配置:"
          echo "  🔍 GCC版本: $(grep 'CONFIG_GCC_VERSION=' .config | cut -d'"' -f2)"
          echo "  🔍 Binutils版本: $(grep 'CONFIG_BINUTILS_VERSION=' .config | cut -d'"' -f2)"
          echo "  🔍 Linux内核版本: $(grep 'CONFIG_LINUX_VERSION=' .config | cut -d'"' -f2)"
          echo "  🔍 目标: $(grep 'CONFIG_TARGET_' .config | grep '=y' | head -1)"
          echo "  🔍 架构: $(grep 'CONFIG_TARGET_ARCH=' .config | cut -d'"' -f2)"
          echo "  🔍 编译器前缀: $(grep 'CONFIG_TARGET_PREFIX=' .config | cut -d'"' -f2)"
          
          if [ "${{ env.USE_MUSL }}" = "y" ]; then
            echo "  🔍 Musl版本: $(grep 'CONFIG_MUSL_VERSION=' .config | cut -d'"' -f2)"
          else
            echo "  🔍 Glibc版本: $(grep 'CONFIG_GLIBC_VERSION=' .config | cut -d'"' -f2)"
          fi
          
          echo "步骤7: 验证配置完整性..."
          ALL_CORRECT=true
          
          # 验证所有关键配置
          if grep -q "CONFIG_GCC_VERSION=\"${{ env.GCC_VERSION }}\"" .config; then
            echo "✅ GCC版本验证通过"
          else
            echo "❌ GCC版本验证失败"
            ALL_CORRECT=false
          fi
          
          if grep -q "CONFIG_TARGET_${{ env.TARGET }}=y" .config; then
            echo "✅ 目标验证通过"
          else
            echo "❌ 目标验证失败"
            ALL_CORRECT=false
          fi
          
          if grep -q "CONFIG_BUILD_TOOLCHAIN=y" .config; then
            echo "✅ 构建工具链验证通过"
          else
            echo "❌ 构建工具链验证失败"
            ALL_CORRECT=false
          fi
          
          if [ "$ALL_CORRECT" = true ]; then
            echo "✅ 所有配置验证通过"
          else
            echo "❌ 配置验证失败，请检查日志"
            exit 1
          fi
          
          echo "=============================="
          echo "✅ 配置强制应用完成"
          echo "结束时间: $(date)"

      - name: 🔨 编译工具链（版本适配）
        timeout-minutes: 150
        run: |
          echo "=== 开始编译工具链（版本适配）==="
          cd "${{ env.BUILD_DIR }}"
          echo "工作目录: $(pwd)"
          echo "开始时间: $(date)"
          
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=xterm-256color
          export ABI=64
          export CC="gcc"
          export CXX="g++"
          export MAKEFLAGS="-j$(nproc)"
          
          echo "系统信息:"
          echo "- CPU核心: $(nproc)"
          echo "- 内存: $(free -h | grep Mem | awk '{print $2}')"
          echo "- 磁盘空间:"
          df -h .
          
          echo "构建环境信息:"
          echo "- GCC版本: ${{ env.GCC_VERSION }}"
          echo "- Binutils版本: ${{ env.BINUTILS_VERSION }}"
          echo "- Linux内核版本: ${{ env.LINUX_VERSION }}"
          echo "- C库版本: ${{ env.LIBC_VERSION }}"
          
          echo "步骤1: 创建host工具目录..."
          mkdir -p staging_dir/host/bin
          mkdir -p staging_dir/host/lib
          mkdir -p staging_dir/host/include
          
          echo "步骤2: 最终配置检查..."
          echo "当前配置:"
          grep -E "CONFIG_GCC_VERSION|CONFIG_BINUTILS_VERSION|CONFIG_TARGET_|CONFIG_BUILD_TOOLCHAIN" .config
          
          echo "步骤3: 下载源码包..."
          mkdir -p dl
          echo "开始下载工具链源码..."
          
          # 首先下载关键包
          echo "下载关键包..."
          for pkg in gcc binutils linux; do
            echo "下载 $pkg..."
            make package/toolchain/$pkg/download V=s 2>&1 | tail -20
          done
          
          # 下载所有包
          echo "下载所有必要的包..."
          make -j1 download V=s 2>&1 | tee /tmp/download.log
          DOWNLOAD_STATUS=${PIPESTATUS[0]}
          if [ $DOWNLOAD_STATUS -eq 0 ]; then
            echo "✅ 下载成功"
          else
            echo "⚠️ 下载有警告，继续尝试..."
            echo "下载状态: $DOWNLOAD_STATUS"
          fi
          
          echo "检查关键包下载情况:"
          for pkg in gcc binutils linux; do
            pkg_files=$(find dl -name "${pkg}-*.tar.*" -o -name "${pkg}-*.tar.gz" -o -name "${pkg}-*.tar.bz2" 2>/dev/null | wc -l)
            if [ $pkg_files -gt 0 ]; then
              echo "  ✅ $pkg: 找到 $pkg_files 个文件"
              find dl -name "${pkg}-*" -type f 2>/dev/null | head -2 | xargs -I {} basename {}
            else
              echo "  ❌ $pkg: 未找到"
            fi
          done
          
          # 检查C库包
          if [ "${{ env.USE_MUSL }}" = "y" ]; then
            musl_files=$(find dl -name "musl-*.tar.*" 2>/dev/null | wc -l)
            if [ $musl_files -gt 0 ]; then
              echo "  ✅ musl: 找到 $musl_files 个文件"
            else
              echo "  ❌ musl: 未找到"
            fi
          fi
          
          echo "步骤4: 编译工具链..."
          echo "开始编译，使用 $(nproc) 个核心..."
          
          # 分步编译以提高成功率
          echo "子步骤4.1: 准备工具链..."
          make toolchain/prepare -j$(nproc) V=s 2>&1 | tee /tmp/prepare.log
          PREPARE_STATUS=${PIPESTATUS[0]}
          
          if [ $PREPARE_STATUS -eq 0 ]; then
            echo "✅ 工具链准备成功"
          else
            echo "⚠️ 工具链准备有警告"
          fi
          
          echo "子步骤4.2: 编译工具链..."
          make toolchain/compile -j$(nproc) V=s 2>&1 | tee /tmp/compile.log
          COMPILE_STATUS=${PIPESTATUS[0]}
          
          if [ $COMPILE_STATUS -eq 0 ]; then
            echo "✅ 工具链编译成功"
          else
            echo "❌ 工具链编译失败，状态码: $COMPILE_STATUS"
            echo "错误摘要:"
            grep -E "Error:|error:|failed:" /tmp/compile.log | tail -30
            echo "尝试单线程编译..."
            make toolchain/compile -j1 V=s 2>&1 | tee /tmp/compile-single.log
            COMPILE_SINGLE_STATUS=${PIPESTATUS[0]}
            if [ $COMPILE_SINGLE_STATUS -eq 0 ]; then
              echo "✅ 单线程编译成功"
            else
              echo "❌ 所有编译尝试都失败"
              exit 1
            fi
          fi
          
          echo "步骤5: 安装工具链..."
          make toolchain/install -j$(nproc) V=s 2>&1 | tee /tmp/install.log
          INSTALL_STATUS=${PIPESTATUS[0]}
          if [ $INSTALL_STATUS -eq 0 ]; then
            echo "✅ 工具链安装成功"
          else
            echo "⚠️ 安装有警告，状态码: $INSTALL_STATUS"
            echo "警告摘要:"
            grep -E "Warning:|warning:" /tmp/install.log | tail -10
          fi
          
          echo "✅ 工具链构建完成"
          echo "结束时间: $(date)"
          echo "构建目录大小: $(du -sh . | cut -f1)"

      - name: ✅ 验证构建结果（完整工具链）
        run: |
          echo "=== 验证构建结果（完整工具链）==="
          echo "开始时间: $(date)"
          cd "${{ env.BUILD_DIR }}"
          echo "当前目录: $(pwd)"
          
          echo "查找工具链目录..."
          TOOLCHAIN_DIR=$(find staging_dir -name "toolchain-*" -type d 2>/dev/null | head -1)
          
          if [ -z "$TOOLCHAIN_DIR" ]; then
            echo "❌ 未找到工具链目录"
            echo "尝试其他可能的目录..."
            # 尝试更多可能的路径
            for path in staging_dir/toolchain staging_dir/host staging_dir/target-*; do
              if [ -d "$path" ]; then
                echo "检查: $path"
                find "$path" -name "*gcc" -type f 2>/dev/null | head -3
              fi
            done
            exit 1
          fi
          
          echo "✅ 找到工具链目录: $TOOLCHAIN_DIR"
          echo "目录大小: $(du -sh "$TOOLCHAIN_DIR" | cut -f1)"
          
          echo "查找编译器..."
          COMPILER_PATH=""
          
          # 搜索GCC编译器的可能路径
          SEARCH_PATHS=(
            "$TOOLCHAIN_DIR/bin"
            "$TOOLCHAIN_DIR/usr/bin"
            "$TOOLCHAIN_DIR/libexec/gcc/*/*"
            "$TOOLCHAIN_DIR"
          )
          
          for search_path in "${SEARCH_PATHS[@]}"; do
            if [ -d "$(dirname "$search_path" 2>/dev/null)" ] || [ -d "$search_path" ]; then
              found=$(find $search_path -name "*gcc" -type f 2>/dev/null | head -1)
              if [ -n "$found" ]; then
                COMPILER_PATH="$found"
                echo "在 $search_path 中找到: $found"
                break
              fi
            fi
          done
          
          if [ -z "$COMPILER_PATH" ]; then
            echo "❌ 未找到编译器"
            echo "尝试更广泛的搜索..."
            find "$TOOLCHAIN_DIR" -type f -name "*gcc*" 2>/dev/null | head -20
            exit 1
          fi
          
          if [ ! -x "$COMPILER_PATH" ]; then
            echo "❌ 编译器不可执行: $COMPILER_PATH"
            ls -la "$COMPILER_PATH"
            exit 1
          fi
          
          COMPILER_NAME=$(basename "$COMPILER_PATH")
          echo "✅ 找到编译器: $COMPILER_NAME"
          echo "完整路径: $COMPILER_PATH"
          
          echo "编译器信息:"
          "$COMPILER_PATH" --version 2>&1 | head -5
          
          echo "目标三元组:"
          TARGET_TRIPLET=$("$COMPILER_PATH" -dumpmachine 2>&1)
          echo "$TARGET_TRIPLET"
          
          echo "测试交叉编译..."
          echo '#include <stdio.h>' > test.c
          echo '#include <stdlib.h>' >> test.c
          echo 'int main() {' >> test.c
          echo '    printf("Cross-compiler test OK\\n");' >> test.c
          echo '    return 0;' >> test.c
          echo '}' >> test.c
          
          "$COMPILER_PATH" test.c -o test_program 2>&1
          COMPILE_TEST_STATUS=$?
          
          if [ $COMPILE_TEST_STATUS -eq 0 ] && [ -f "test_program" ]; then
            echo "✅ 交叉编译测试通过"
            echo "生成文件类型:"
            file test_program
            rm -f test.c test_program
          else
            echo "❌ 交叉编译测试失败"
            cat test.c
            exit 1
          fi
          
          echo "==================== 完整工具链检查 ===================="
          
          # 获取工具前缀
          if [[ "$COMPILER_NAME" == *"gcc" ]]; then
            TOOL_PREFIX="${COMPILER_NAME%gcc}"
          else
            TOOL_PREFIX="$TARGET_TRIPLET-"
          fi
          
          echo "工具前缀: $TOOL_PREFIX"
          
          # 完整的关键工具列表
          declare -A TOOL_CATEGORIES=(
            ["编译器"]="gcc g++ cpp gfortran gcov gcov-dump gcov-tool"
            ["汇编器"]="as gas"
            ["链接器"]="ld ld.bfd ld.gold lld"
            ["归档器"]="ar ranlib"
            ["符号工具"]="nm objdump objcopy strip strings size readelf addr2line"
            ["调试工具"]="gdb gdbserver"
            ["预处理"]="cpp cpp0"
            ["其他工具"]="elfedit windres dlltool"
            ["运行时"]="ldd ld.so"
          )
          
          # 搜索路径
          BIN_PATHS=(
            "$TOOLCHAIN_DIR/bin"
            "$TOOLCHAIN_DIR/usr/bin"
            "$TOOLCHAIN_DIR/usr/sbin"
            "$TOOLCHAIN_DIR/sbin"
            "$TOOLCHAIN_DIR/libexec/gcc/*/*"
            "$TOOLCHAIN_DIR"
          )
          
          echo "🔍 搜索工具链目录: $TOOLCHAIN_DIR"
          echo ""
          
          MISSING_CRITICAL=()
          MISSING_IMPORTANT=()
          ALL_FOUND=()
          
          # 检查每个类别的工具
          for category in "${!TOOL_CATEGORIES[@]}"; do
            echo "📋 $category:"
            tools=(${TOOL_CATEGORIES[$category]})
            category_missing=()
            
            for tool_base in "${tools[@]}"; do
              tool_name="${TOOL_PREFIX}${tool_base}"
              tool_found=""
              
              # 在所有可能的路径中搜索
              for bin_path in "${BIN_PATHS[@]}"; do
                if [ -d "$(dirname "$bin_path" 2>/dev/null)" ] || [ -d "$bin_path" ]; then
                  # 尝试精确匹配
                  tool_path=$(find $bin_path -name "$tool_name" -type f 2>/dev/null | head -1)
                  
                  # 如果没找到带前缀的，尝试不带前缀的
                  if [ -z "$tool_path" ]; then
                    tool_path=$(find $bin_path -name "$tool_base" -type f 2>/dev/null | head -1)
                  fi
                  
                  if [ -n "$tool_path" ] && [ -x "$tool_path" ]; then
                    tool_found="$tool_path"
                    break
                  fi
                fi
              done
              
              if [ -n "$tool_found" ]; then
                echo "  ✅ $tool_base: $(basename "$tool_found")"
                ALL_FOUND+=("$tool_base:$tool_found")
              else
                echo "  ⚠️  $tool_base: 未找到"
                category_missing+=("$tool_base")
                
                # 分类记录缺失的工具
                case "$category" in
                  "编译器"|"链接器"|"汇编器")
                    MISSING_CRITICAL+=("$tool_base")
                    ;;
                  "归档器"|"符号工具")
                    MISSING_IMPORTANT+=("$tool_base")
                    ;;
                esac
              fi
            done
            
            if [ ${#category_missing[@]} -gt 0 ]; then
              echo "  缺失: ${category_missing[*]}"
            fi
            echo ""
          done
          
          # 检查动态链接器
          echo "📋 运行时库检查:"
          
          # 查找libc库
          LIBC_PATHS=(
            "$TOOLCHAIN_DIR/lib"
            "$TOOLCHAIN_DIR/usr/lib"
            "$TOOLCHAIN_DIR/lib64"
            "$TOOLCHAIN_DIR/usr/lib64"
          )
          
          LIBC_FOUND=false
          for lib_path in "${LIBC_PATHS[@]}"; do
            if [ -d "$lib_path" ]; then
              libc_file=$(find "$lib_path" -name "libc.so.*" -o -name "libc.a" -o -name "libc.so" 2>/dev/null | head -1)
              if [ -n "$libc_file" ]; then
                echo "  ✅ 找到C库: $(basename "$libc_file")"
                LIBC_FOUND=true
                break
              fi
            fi
          done
          
          if [ "$LIBC_FOUND" = false ]; then
            echo "  ⚠️  未找到C库"
          fi
          
          # 查找头文件
          HEADER_PATHS=(
            "$TOOLCHAIN_DIR/include"
            "$TOOLCHAIN_DIR/usr/include"
            "$TOOLCHAIN_DIR/sysroot/include"
          )
          
          HEADER_FOUND=false
          for header_path in "${HEADER_PATHS[@]}"; do
            if [ -f "$header_path/stdio.h" ] || [ -f "$header_path/stdlib.h" ]; then
              echo "  ✅ 找到头文件目录: $header_path"
              HEADER_FOUND=true
              break
            fi
          done
          
          if [ "$HEADER_FOUND" = false ]; then
            echo "  ⚠️  未找到标准头文件"
          fi
          
          echo ""
          echo "==================== 检查总结 ===================="
          
          # 核心必要工具（必须有）
          CORE_TOOLS=("gcc" "ld" "as" "ar")
          CORE_MISSING=()
          
          for core_tool in "${CORE_TOOLS[@]}"; do
            found=false
            for found_tool in "${ALL_FOUND[@]}"; do
              if [[ "$found_tool" == "$core_tool:"* ]]; then
                found=true
                break
              fi
            done
            
            if [ "$found" = false ]; then
              CORE_MISSING+=("$core_tool")
            fi
          done
          
          if [ ${#CORE_MISSING[@]} -eq 0 ]; then
            echo "✅ 核心工具完整: gcc, ld, as, ar"
            BUILD_STATUS="PASS"
          else
            echo "❌ 缺少核心工具: ${CORE_MISSING[*]}"
            BUILD_STATUS="FAIL"
          fi
          
          # 重要工具（应该有）
          IMPORTANT_TOOLS=("g++" "strip" "objcopy" "objdump" "nm" "ranlib" "cpp")
          IMPORTANT_MISSING=()
          
          for important_tool in "${IMPORTANT_TOOLS[@]}"; do
            found=false
            for found_tool in "${ALL_FOUND[@]}"; do
              if [[ "$found_tool" == "$important_tool:"* ]]; then
                found=true
                break
              fi
            done
            
            if [ "$found" = false ]; then
              IMPORTANT_MISSING+=("$important_tool")
            fi
          done
          
          if [ ${#IMPORTANT_MISSING[@]} -eq 0 ]; then
            echo "✅ 重要工具完整"
          else
            echo "⚠️  缺少重要工具: ${IMPORTANT_MISSING[*]}"
            if [ "$BUILD_STATUS" = "PASS" ]; then
              BUILD_STATUS="WARNING"
            fi
          fi
          
          echo ""
          echo "📊 工具统计:"
          echo "- 找到的工具: ${#ALL_FOUND[@]}个"
          echo "- 缺失核心工具: ${#CORE_MISSING[@]}个"
          echo "- 缺失重要工具: ${#IMPORTANT_MISSING[@]}个"
          
          # 创建工具映射文件供后续使用
          echo "创建工具映射文件..."
          echo "# 工具链映射" > "$TOOLCHAIN_DIR/toolchain.map"
          echo "PREFIX=$TOOL_PREFIX" >> "$TOOLCHAIN_DIR/toolchain.map"
          echo "TARGET=$TARGET_TRIPLET" >> "$TOOLCHAIN_DIR/toolchain.map"
          echo "GCC_VERSION=${{ env.GCC_VERSION }}" >> "$TOOLCHAIN_DIR/toolchain.map"
          echo "BINUTILS_VERSION=${{ env.BINUTILS_VERSION }}" >> "$TOOLCHAIN_DIR/toolchain.map"
          echo "TOOLS_COUNT=${#ALL_FOUND[@]}" >> "$TOOLCHAIN_DIR/toolchain.map"
          echo "" >> "$TOOLCHAIN_DIR/toolchain.map"
          
          for tool_info in "${ALL_FOUND[@]}"; do
            IFS=':' read -r tool_name tool_path <<< "$tool_info"
            echo "$tool_name=$tool_path" >> "$TOOLCHAIN_DIR/toolchain.map"
          done
          
          # 设置环境变量
          echo "TOOL_PREFIX=$TOOL_PREFIX" >> $GITHUB_ENV
          echo "TARGET_TRIPLET=$TARGET_TRIPLET" >> $GITHUB_ENV
          echo "BUILD_STATUS=$BUILD_STATUS" >> $GITHUB_ENV
          
          if [ "$BUILD_STATUS" = "FAIL" ]; then
            echo "❌ 工具链不完整，构建失败"
            exit 1
          elif [ "$BUILD_STATUS" = "WARNING" ]; then
            echo "⚠️  工具链基本完整，但有警告"
            echo "BUILD_COMPLETE=true" >> $GITHUB_ENV
          else
            echo "✅ 工具链完整，构建成功"
            echo "BUILD_COMPLETE=true" >> $GITHUB_ENV
          fi
          
          echo "TOOLCHAIN_DIR=$TOOLCHAIN_DIR" >> $GITHUB_ENV
          echo "COMPILER_PATH=$COMPILER_PATH" >> $GITHUB_ENV
          echo "COMPILER_NAME=$COMPILER_NAME" >> $GITHUB_ENV
          echo "ALL_TOOLS_COUNT=${#ALL_FOUND[@]}" >> $GITHUB_ENV
          echo "结束时间: $(date)"

      - name: 💾 保存编译器（带版本信息）
        if: env.BUILD_COMPLETE == 'true'
        run: |
          echo "=== 保存编译器（带版本信息）==="
          echo "开始时间: $(date)"
          cd "${{ env.BUILD_DIR }}"
          
          echo "准备输出目录: ${{ env.OUTPUT_DIR }}"
          mkdir -p "${{ env.OUTPUT_DIR }}"
          
          if [ -d "${{ env.OUTPUT_DIR }}" ] && [ "$(ls -A "${{ env.OUTPUT_DIR }}" 2>/dev/null)" ]; then
            echo "清理现有输出目录..."
            rm -rf "${{ env.OUTPUT_DIR }}"/*
          fi
          
          echo "复制工具链文件..."
          if [ -d "$TOOLCHAIN_DIR" ]; then
            echo "从: $TOOLCHAIN_DIR"
            echo "到: ${{ env.OUTPUT_DIR }}"
            
            # 使用rsync进行更可靠的复制
            rsync -av "$TOOLCHAIN_DIR/" "${{ env.OUTPUT_DIR }}/" 2>&1 | tail -20
            
            echo "✅ 复制完成"
          else
            echo "❌ 工具链目录不存在"
            exit 1
          fi
          
          echo "创建详细的元数据文件..."
          cat > "${{ env.OUTPUT_DIR }}/metadata.json" << EOF
          {
            "architecture": "${{ env.ARCH_DIR }}",
            "arch_name": "${{ env.ARCH_NAME }}",
            "libc": "${{ env.LIBC_DIR }}",
            "libc_version": "${{ env.LIBC_VERSION }}",
            "target": "${{ env.TARGET }}",
            "subtarget": "${{ env.SUBTARGET }}",
            "compiler_prefix": "${{ env.PREFIX }}-",
            "gcc_version": "${{ env.GCC_VERSION }}",
            "binutils_version": "${{ env.BINUTILS_VERSION }}",
            "linux_version": "${{ env.LINUX_VERSION }}",
            "openwrt_version": "${{ env.OPENWRT_VERSION }}",
            "cpu_type": "${{ env.CPU_TYPE }}",
            "tune": "${{ env.TUNE }}",
            "abi": "${{ env.ABI }}",
            "float_abi": "${{ env.FLOAT_ABI }}",
            "build_date": "$(date -Iseconds)",
            "workflow_run": "${{ github.run_id }}",
            "build_id": "${{ env.BUILD_ID }}",
            "tools_count": "${{ env.ALL_TOOLS_COUNT }}",
            "target_triplet": "${{ env.TARGET_TRIPLET }}",
            "tool_prefix": "${{ env.TOOL_PREFIX }}"
          }
          EOF
          
          echo "创建说明文件..."
          cat > "${{ env.OUTPUT_DIR }}/README.md" << EOF
          # ${{ env.ARCH_DIR }} ${{ env.LIBC_DIR }} 交叉编译器

          ## 基本信息
          - 架构: ${{ env.ARCH_DIR }} (${{ env.ARCH_NAME }})
          - C库: ${{ env.LIBC_DIR }} ${{ env.LIBC_VERSION }}
          - GCC版本: ${{ env.GCC_VERSION }}
          - Binutils版本: ${{ env.BINUTILS_VERSION }}
          - Linux内核: ${{ env.LINUX_VERSION }}
          - OpenWrt版本: ${{ env.OPENWRT_VERSION }}
          - 编译器前缀: ${{ env.PREFIX }}-
          - 目标三元组: ${{ env.TARGET_TRIPLET }}
          - CPU类型: ${{ env.CPU_TYPE }}
          - 调优: ${{ env.TUNE }}
          - ABI: ${{ env.ABI }}
          - 浮点ABI: ${{ env.FLOAT_ABI }}
          - 工具数量: ${{ env.ALL_TOOLS_COUNT }}
          - 构建时间: $(date)

          ## 版本兼容性
          此编译器专为以下环境设计：
          - OpenWrt ${{ env.OPENWRT_VERSION }}
          - ${{ env.ARCH_DIR }} 架构设备
          - ${{ env.LIBC_DIR }} C库

          ## 使用方法
          \`\`\`bash
          # 设置环境变量
          export STAGING_DIR="\$(pwd)"
          export PATH="\$STAGING_DIR/bin:\$PATH"
          
          # 验证编译器
          ${{ env.PREFIX }}-gcc --version
          
          # 编译示例程序
          ${{ env.PREFIX }}-gcc -o hello hello.c
          \`\`\`

          ## 包含的工具
          - 编译器: gcc, g++, cpp
          - 汇编器: as, gas
          - 链接器: ld, ld.bfd
          - 二进制工具: objcopy, objdump, strip, nm
          - 归档工具: ar, ranlib
          - 调试工具: gdb, gdbserver

          ## 注意事项
          1. 此工具链专为交叉编译设计
          2. 需要相应的头文件和库文件
          3. 建议在OpenWrt构建系统中使用
          4. 版本已针对目标架构优化

          ## 构建信息
          - 工作流: #${{ github.run_id }}
          - 构建ID: ${{ env.BUILD_ID }}
          - 保存路径: ${{ env.OUTPUT_DIR }}
          EOF
          
          echo "计算成果大小..."
          TOTAL_SIZE=$(du -sh "${{ env.OUTPUT_DIR }}" | cut -f1)
          FILE_COUNT=$(find "${{ env.OUTPUT_DIR }}" -type f | wc -l)
          DIR_COUNT=$(find "${{ env.OUTPUT_DIR }}" -type d | wc -l)
          
          echo "📊 最终成果统计:"
          echo "- 输出目录: ${{ env.OUTPUT_DIR }}"
          echo "- 总大小: $TOTAL_SIZE"
          echo "- 文件数量: $FILE_COUNT"
          echo "- 目录数量: $DIR_COUNT"
          echo "- 架构: ${{ env.ARCH_DIR }}"
          echo "- C库: ${{ env.LIBC_DIR }}"
          echo "- GCC版本: ${{ env.GCC_VERSION }}"
          echo "- Binutils版本: ${{ env.BINUTILS_VERSION }}"
          
          echo "TOTAL_SIZE=$TOTAL_SIZE" >> $GITHUB_ENV
          echo "FILE_COUNT=$FILE_COUNT" >> $GITHUB_ENV
          echo "DIR_COUNT=$DIR_COUNT" >> $GITHUB_ENV
          
          echo "✅ 编译器保存完成"
          echo "结束时间: $(date)"

      - name: 📤 提交到Git仓库
        if: env.BUILD_COMPLETE == 'true'
        run: |
          echo "=== 提交编译器到Git仓库 ==="
          echo "开始时间: $(date)"
          cd "${{ github.workspace }}"
          
          git config user.email "github-actions@github.com"
          git config user.name "GitHub Actions"
          git config pull.rebase false
          
          echo "拉取最新代码..."
          git pull origin main --no-edit
          
          echo "添加编译器文件..."
          git add -f "firmware-config/build-Compiler-file/compilers/*"
          
          if ! git diff --cached --quiet; then
            echo "检测到变更，创建提交..."
            
            COMMIT_MSG="build(compiler): 添加 ${{ env.ARCH_DIR }}-${{ env.LIBC_DIR }} 交叉编译器 v${{ env.GCC_VERSION }}"
            COMMIT_BODY="架构: ${{ env.ARCH_DIR }}\nC库: ${{ env.LIBC_DIR }} ${{ env.LIBC_VERSION }}\nGCC: ${{ env.GCC_VERSION }}\nBinutils: ${{ env.BINUTILS_VERSION }}\n大小: ${{ env.TOTAL_SIZE }}\n工具数: ${{ env.ALL_TOOLS_COUNT }}\n工作流: #${{ github.run_id }}"
            
            git commit -m "$COMMIT_MSG" -m "$COMMIT_BODY"
            
            echo "推送到仓库..."
            if git push origin main; then
              echo "✅ 编译器已成功提交到仓库"
            else
              echo "⚠️ 推送失败，重新尝试..."
              git pull origin main --rebase
              git push origin main
            fi
          else
            echo "没有变更需要提交"
          fi
          
          echo "结束时间: $(date)"

      - name: 📊 显示最终成果
        if: env.BUILD_COMPLETE == 'true'
        run: |
          echo "========================================"
          echo "          🎉 构建完成报告              "
          echo "========================================"
          echo "✅ 交叉编译器构建成功!"
          echo ""
          echo "📊 构建信息:"
          echo "- 架构: ${{ env.ARCH_DIR }} (${{ env.ARCH_NAME }})"
          echo "- C库: ${{ env.LIBC_DIR }} ${{ env.LIBC_VERSION }}"
          echo "- GCC版本: ${{ env.GCC_VERSION }}"
          echo "- Binutils版本: ${{ env.BINUTILS_VERSION }}"
          echo "- Linux内核: ${{ env.LINUX_VERSION }}"
          echo "- 编译器前缀: ${{ env.PREFIX }}-"
          echo "- 目标平台: ${{ env.TARGET }}/${{ env.SUBTARGET }}"
          echo "- 目标三元组: ${{ env.TARGET_TRIPLET }}"
          echo ""
          echo "📦 成果统计:"
          echo "- 总大小: ${{ env.TOTAL_SIZE }}"
          echo "- 文件数量: ${{ env.FILE_COUNT }}"
          echo "- 目录数量: ${{ env.DIR_COUNT }}"
          echo "- 工具数量: ${{ env.ALL_TOOLS_COUNT }}"
          echo "- 输出目录: ${{ env.OUTPUT_DIR }}"
          echo ""
          echo "🚀 使用方法:"
          echo "cd ${{ env.OUTPUT_DIR }}"
          echo "export STAGING_DIR=\$(pwd)"
          echo 'export PATH="$STAGING_DIR/bin:$PATH"'
          echo "${{ env.PREFIX }}-gcc --version"
          echo ""
          echo "🔧 版本适配策略:"
          echo "- OpenWrt ${{ env.OPENWRT_VERSION }} → GCC ${{ env.GCC_VERSION }}"
          echo "- 架构优化 → 针对 ${{ env.ARCH_DIR }} 调整"
          echo "- 版本验证 → 确保组件兼容性"
          echo ""
          echo "⏰ 构建时间: $(date)"
          echo "========================================"

      - name: 📄 上传构建日志
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.BUILD_ID }}
          path: /tmp/*.log
          retention-days: 30

  skip-build:
    needs: setup
    if: needs.setup.outputs.need_build == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: ⏭️ 跳过构建
        run: |
          echo "========================================"
          echo "        ⏭️ 跳过构建报告                "
          echo "========================================"
          echo "✅ 编译器已存在且完整，跳过构建"
          echo ""
          echo "📋 跳过原因:"
          echo "- 编译器目录已存在且完整"
          echo "- 版本匹配正确"
          echo "- 未启用强制重新构建"
          echo ""
          echo "🔧 现有编译器信息:"
          echo "- 架构: ${{ github.event.inputs.target_arch }}"
          echo "- C库: ${{ github.event.inputs.libc }}"
          echo "- GCC版本: ${{ needs.setup.outputs.gcc_version }}"
          echo "- Binutils版本: ${{ needs.setup.outputs.binutils_version }}"
          echo ""
          echo "💡 如需重新构建，请启用'强制重新构建'选项"
          echo "========================================"

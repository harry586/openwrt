# .github/workflows/compiler-matrix-build.yml
name: 🔧 交叉编译器构建

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构（IPQ40xx选择arm_cortex-a7）'
        required: true
        default: 'arm_cortex-a7'
        type: choice
        options: ['aarch64', 'x86_64', 'mips', 'mipsel', 'arm_cortex-a7', 'arm_cortex-a53', 'riscv64']
      libc:
        description: 'C库类型（嵌入式推荐musl）'
        required: true
        default: 'musl'
        type: choice
        options: ['musl', 'glibc']
      gcc_version:
        description: 'GCC版本（输入版本号如12.3.0，或auto自动检测）'
        required: true
        default: 'auto'
        type: string
      clean_build:
        description: '清理之前的构建缓存'
        required: true
        default: false
        type: boolean
      force_rebuild:
        description: '强制重新构建（即使已存在）'
        required: true
        default: false
        type: boolean

env:
  OPENWRT_VERSION: "23.05.2"
  COMPILER_BASE_DIR: "${{ github.workspace }}/firmware-config/build-Compiler-file/compilers"

jobs:
  show-device-info:
    runs-on: ubuntu-latest
    steps:
      - name: 📱 显示架构对应设备
        run: |
          echo "================================================"
          echo "          🎯 目标架构设备对应表                 "
          echo "================================================"
          echo ""
          echo "1️⃣ aarch64 (ARM 64位)"
          echo "   ├─ 📱 树莓派系列"
          echo "   │  ├─ 树莓派 4B (Raspberry Pi 4)"
          echo "   │  ├─ 树莓派 CM4 (Compute Module 4)"
          echo "   │  └─ 树莓派 400"
          echo "   ├─ 🖥️ 瑞芯微系列"
          echo "   │  ├─ RK3399 (ROCK Pi 4/NanoPi M4)"
          echo "   │  ├─ RK3568 (FriendlyELEC NanoPi R5S)"
          echo "   │  └─ RK3588 (高端开发板)"
          echo "   ├─ 📺 电视盒子"
          echo "   │  ├─ 晶晨 S905 (X96 Max/Beelink GT King)"
          echo "   │  ├─ 晶晨 S912 (H96 Pro/Beelink GT1)"
          echo "   │  └─ 晶晨 S922X (Odroid N2+)"
          echo "   └─ 🖥️ 其他ARM64设备"
          echo "      ├─ Orange Pi 5"
          echo "      ├─ Banana Pi BPI-M5"
          echo "      └─ 各种ARM服务器"
          echo ""
          echo "2️⃣ x86_64 (x86 64位)"
          echo "   ├─ 💻 个人电脑"
          echo "   │  ├─ Intel Core i3/i5/i7/i9"
          echo "   │  ├─ AMD Ryzen 3/5/7/9"
          echo "   │  └─ 各种x86笔记本"
          echo "   ├─ 🖥️ 服务器"
          echo "   │  ├─ 戴尔PowerEdge"
          echo "   │  ├─ 惠普ProLiant"
          echo "   │  └─ 超微服务器"
          echo "   └─ ☁️ 虚拟机/容器"
          echo "      ├─ VMware/VirtualBox虚拟机"
          echo "      ├─ Docker容器"
          echo "      └─ 云服务器实例"
          echo ""
          echo "3️⃣ mips (MIPS 32位大端)"
          echo "   ├─ 🛜 华硕路由器"
          echo "   │  ├─ RT-ACRH17"
          echo "   │  ├─ RT-AC85P"
          echo "   │  └─ RT-N56U"
          echo "   ├─ 🛜 网件路由器"
          echo "   │  ├─ R7800"
          echo "   │  ├─ R9000"
          echo "   │  └─ XR500"
          echo "   └─ 🛜 其他MIPS设备"
          echo "      ├─ 中兴路由器"
          echo "      ├─ 华为旧款路由器"
          echo "      └─ 早期智能家居设备"
          echo ""
          echo "4️⃣ mipsel (MIPS 32位小端)"
          echo "   ├─ 🛜 联发科MT7621"
          echo "   │  ├─ 斐讯 K2P (Phicomm K2P)"
          echo "   │  ├─ Newifi 3 (新路由3)"
          echo "   │  ├─ 小米路由器 3G"
          echo "   │  ├─ 红米路由器 AC2100"
          echo "   │  └─ 极路由 B70"
          echo "   ├─ 🛜 联发科MT7620"
          echo "   │  ├─ 小米路由器 Mini"
          echo "   │  ├─ 极路由 1S"
          echo "   │  ├─ 斐讯 K1/K2"
          echo "   │  └─ 联想 Newifi Mini"
          echo "   └─ 🛜 其他MTK设备"
          echo "      ├─ MT7628 (低端路由)"
          echo "      ├─ MT7688 (物联网设备)"
          echo "      └─ 各种WiFi模块"
          echo ""
          echo "5️⃣ arm_cortex-a7 (ARM Cortex-A7)"
          echo "   ├─ 🛜 高通IPQ40xx系列 (你的设备！)"
          echo "   │  ├─ 小米路由器 4A千兆版"
          echo "   │  ├─ 红米路由器 AC2100 (部分版本)"
          echo "   │  ├─ GL.iNet MT1300"
          echo "   │  ├─ 360家庭防火墙 5Pro"
          echo "   │  ├─ Linksys EA6350 v3"
          echo "   │  └─ Netgear R6900P"
          echo "   ├─ 🛜 联发科MT7623/MT7629"
          echo "   │  ├─ 小米路由器 3G (部分版本)"
          echo "   │  ├─ 斐讯 K3C"
          echo "   │  └─ 部分企业路由器"
          echo "   ├─ 🍊 全志H3/H2+系列"
          echo "   │  ├─ Orange Pi PC (香橙派PC)"
          echo "   │  ├─ Orange Pi Plus"
          echo "   │  ├─ Banana Pi M2+"
          echo "   │  └─ NanoPi NEO"
          echo "   └─ 🔧 其他Cortex-A7设备"
          echo "      ├─ 某些智能摄像头"
          echo "      ├─ 工业控制设备"
          echo "      └─ 低功耗嵌入式设备"
          echo ""
          echo "6️⃣ arm_cortex-a53 (ARM Cortex-A53)"
          echo "   ├─ 🛜 联发科MT7622"
          echo "   │  ├─ 小米路由器 AX3600"
          echo "   │  ├─ 红米路由器 AX6"
          echo "   │  └─ 部分WiFi6路由器"
          echo "   ├─ 📱 64位设备32位模式"
          echo "   │  ├─ 树莓派 3 (32位模式)"
          echo "   │  ├─ 某些电视盒子"
          echo "   │  └─ 低端平板电脑"
          echo "   └─ 🔧 其他A53设备"
          echo "      ├─ 某些智能音箱"
          echo "      ├─ 物联网网关"
          echo "      └─ 边缘计算设备"
          echo ""
          echo "7️⃣ riscv64 (RISC-V 64位)"
          echo "   ├─ 🔬 开发板"
          echo "   │  ├─ HiFive Unmatched"
          echo "   │  ├─ VisionFive 2"
          echo "   │  ├─ BeagleV"
          echo "   │  └─ SiFive开发板"
          echo "   ├─ 🖥️ 新兴设备"
          echo "   │  ├─ 某些AI加速器"
          echo "   │  ├─ 定制芯片设备"
          echo "   │  └─ 学术研究设备"
          echo "   └─ 🚀 未来设备"
          echo "      ├─ RISC-V笔记本电脑"
          echo "      ├─ RISC-V服务器"
          echo "      └─ 各种创新硬件"
          echo ""
          echo "================================================"
          echo "选择建议："
          echo "1. 路由器设备 → 根据芯片型号选择"
          echo "2. 开发板 → 根据CPU架构选择"
          echo "3. PC/服务器 → 选择x86_64"
          echo "4. 不确定 → 查看设备规格书或CPU信息"
          echo "================================================"

  setup:
    runs-on: ubuntu-22.04
    outputs:
      gcc_version: ${{ steps.version-detection.outputs.gcc_version }}
      binutils_version: ${{ steps.version-detection.outputs.binutils_version }}
      linux_version: ${{ steps.version-detection.outputs.linux_version }}
      musl_version: ${{ steps.version-detection.outputs.musl_version }}
      glibc_version: ${{ steps.version-detection.outputs.glibc_version }}
      need_build: ${{ steps.check-existing.outputs.need_build }}
    steps:
      - name: 📥 检出仓库（用于检查现有编译器）
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            firmware-config/build-Compiler-file/compilers
          sparse-checkout-cone-mode: false

      - name: 🏗️ 初始化
        run: |
          echo "=== 交叉编译器构建系统 ==="
          mkdir -p "${{ env.COMPILER_BASE_DIR }}"
          echo "基础目录: ${{ env.COMPILER_BASE_DIR }}"
          echo "开始时间: $(date)"
          echo "当前工作区内容:"
          ls -la "${{ github.workspace }}/firmware-config/build-Compiler-file/compilers" 2>/dev/null || echo "编译器目录不存在"

      - name: 🔍 动态检测GCC版本
        id: version-detection
        run: |
          echo "=== 动态检测工具链版本 ==="
          USER_VERSION="${{ github.event.inputs.gcc_version }}"
          if [ "$USER_VERSION" = "auto" ] || [ "$USER_VERSION" = "" ]; then
            echo "正在检测最新GCC稳定版本..."
            GCC_VERSION=$(curl -s https://ftp.gnu.org/gnu/gcc/ | grep -o 'gcc-[0-9]\+\.[0-9]\+\.[0-9]\+' | sort -Vr | head -1 | cut -d- -f2)
            if [ -z "$GCC_VERSION" ]; then
              GCC_VERSION="12.3.0"
              echo "⚠️ 无法检测最新版本，使用默认: $GCC_VERSION"
            else
              echo "✅ 检测到最新GCC版本: $GCC_VERSION"
            fi
          else
            GCC_VERSION="$USER_VERSION"
            echo "使用指定GCC版本: $GCC_VERSION"
          fi
          echo "检测Binutils版本..."
          BINUTILS_VERSION=$(curl -s https://ftp.gnu.org/gnu/binutils/ | grep -o 'binutils-[0-9]\+\.[0-9]\+\.[0-9]\+' | sort -Vr | head -1 | cut -d- -f2)
          if [ -z "$BINUTILS_VERSION" ]; then
            BINUTILS_VERSION="2.40"
            echo "⚠️ 无法检测Binutils版本，使用默认: $BINUTILS_VERSION"
          else
            echo "✅ 检测到Binutils版本: $BINUTILS_VERSION"
          fi
          LINUX_VERSION="5.15.133"
          MUSL_VERSION="1.2.4"
          GLIBC_VERSION="2.37"
          echo "最终版本配置:"
          echo "- GCC: $GCC_VERSION"
          echo "- Binutils: $BINUTILS_VERSION"
          echo "- Linux内核: $LINUX_VERSION"
          echo "- Musl: $MUSL_VERSION"
          echo "- Glibc: $GLIBC_VERSION"
          echo "gcc_version=$GCC_VERSION" >> $GITHUB_OUTPUT
          echo "binutils_version=$BINUTILS_VERSION" >> $GITHUB_OUTPUT
          echo "linux_version=$LINUX_VERSION" >> $GITHUB_OUTPUT
          echo "musl_version=$MUSL_VERSION" >> $GITHUB_OUTPUT
          echo "glibc_version=$GLIBC_VERSION" >> $GITHUB_OUTPUT

      - name: 🔎 检查现有编译器
        id: check-existing
        run: |
          echo "=== 检查现有编译器 ==="
          echo "========================================"
          echo "         🔧 编译器完整性检查            "
          echo "========================================"
          ARCH="${{ github.event.inputs.target_arch }}"
          LIBC="${{ github.event.inputs.libc }}"
          GCC_VERSION='${{ steps.version-detection.outputs.gcc_version }}'
          if [ "$LIBC" = "musl" ]; then
            LIBC_DIR="musl"
          else
            LIBC_DIR="glibc"
          fi
          OUTPUT_DIR="${{ env.COMPILER_BASE_DIR }}/${ARCH}/${LIBC_DIR}/gcc-${GCC_VERSION}"
          echo "检查目录: $OUTPUT_DIR"
          echo "完整路径: $(realpath "$OUTPUT_DIR" 2>/dev/null || echo "$OUTPUT_DIR")"
          echo "📋 关键编译器工具清单:"
          echo ""
          REQUIRED_DIRS=("bin" "lib" "include" "libexec" "share" "usr")
          echo "📁 必需目录检查:"
          for dir in "${REQUIRED_DIRS[@]}"; do
            if [ -d "$OUTPUT_DIR/$dir" ]; then
              echo "  ✅ 目录 $dir"
            else
              echo "  ❌ 目录 $dir: 缺失"
            fi
          done
          echo ""
          NEED_BUILD="true"
          if [ -d "$OUTPUT_DIR" ]; then
            echo "✅ 编译器目录已存在"
            echo ""
            COMPILER_PREFIX=""
            if [ -d "$OUTPUT_DIR/bin" ]; then
              GCC_FILE=$(find "$OUTPUT_DIR/bin" -name "*gcc" -type f 2>/dev/null | head -1)
              if [ -n "$GCC_FILE" ]; then
                COMPILER_PREFIX=$(basename "$GCC_FILE" | sed 's/-gcc$//')
                echo "🔍 检测到编译器前缀: $COMPILER_PREFIX"
              fi
            fi
            if [ -z "$COMPILER_PREFIX" ]; then
              case "$ARCH" in
                arm_cortex-a7)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="arm-openwrt-linux-muslgnueabihf"
                  else
                    COMPILER_PREFIX="arm-openwrt-linux-gnueabihf"
                  fi
                  ;;
                aarch64)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="aarch64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="aarch64-openwrt-linux-gnu"
                  fi
                  ;;
                x86_64)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="x86_64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="x86_64-openwrt-linux-gnu"
                  fi
                  ;;
                mips)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="mips-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="mips-openwrt-linux-gnu"
                  fi
                  ;;
                mipsel)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="mipsel-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="mipsel-openwrt-linux-gnu"
                  fi
                  ;;
                arm_cortex-a53)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="aarch64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="aarch64-openwrt-linux-gnu"
                  fi
                  ;;
                riscv64)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="riscv64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="riscv64-openwrt-linux-gnu"
                  fi
                  ;;
                *)
                  COMPILER_PREFIX="unknown"
                  ;;
              esac
              echo "🔍 使用架构推断编译器前缀: $COMPILER_PREFIX"
            fi
            echo ""
            echo "🛠️ 关键编译器文件检查:"
            echo ""
            case "$ARCH" in
              aarch64)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ld.gold" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-strings" "bin/${COMPILER_PREFIX}-c++" "bin/${COMPILER_PREFIX}-c++filt" "bin/${COMPILER_PREFIX}-addr2line" "bin/${COMPILER_PREFIX}-gcc-ar" "bin/${COMPILER_PREFIX}-gcc-nm" "bin/${COMPILER_PREFIX}-gcc-ranlib" "bin/${COMPILER_PREFIX}-gcov" "bin/${COMPILER_PREFIX}-gcov-dump" "bin/${COMPILER_PREFIX}-gcov-tool" "bin/${COMPILER_PREFIX}-gprof")
                ;;
              x86_64)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-elfedit" "bin/${COMPILER_PREFIX}-gcc-ranlib")
                ;;
              mips)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-strings")
                ;;
              mipsel)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-strings" "bin/${COMPILER_PREFIX}-c++" "bin/${COMPILER_PREFIX}-c++filt")
                ;;
              arm_cortex-a7)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf")
                ;;
              arm_cortex-a53)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-elfedit" "bin/${COMPILER_PREFIX}-gcc-ranlib")
                ;;
              riscv64)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf")
                ;;
            esac
            ACTUAL_GCC_VERSION="$GCC_VERSION"
            if [ -d "$OUTPUT_DIR/lib/gcc/${COMPILER_PREFIX}" ]; then
              DETECTED_VERSION=$(ls "$OUTPUT_DIR/lib/gcc/${COMPILER_PREFIX}" 2>/dev/null | head -1)
              if [ -n "$DETECTED_VERSION" ]; then
                ACTUAL_GCC_VERSION="$DETECTED_VERSION"
                echo "🔍 检测到实际GCC版本: $ACTUAL_GCC_VERSION"
              fi
            fi
            KEY_LIB_FILES=("lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc.a" "lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc_eh.a" "lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc_s.so" "lib/libc.a" "lib/libm.a" "usr/include/stdio.h" "usr/include/stdlib.h" "usr/include/string.h" "usr/include/features.h")
            MISSING_FILES=()
            EXISTING_FILES=()
            echo "🔧 编译器工具文件 (${#KEY_FILES[@]}个):"
            for file_path in "${KEY_FILES[@]}"; do
              full_path="$OUTPUT_DIR/$file_path"
              if [ -f "$full_path" ] || [ -e "$full_path" ]; then
                EXISTING_FILES+=("$file_path")
                echo "  ✅ $file_path"
              else
                MISSING_FILES+=("$file_path")
                echo "  ❌ $file_path: 缺失"
              fi
            done
            echo ""
            echo "📚 关键库文件 (${#KEY_LIB_FILES[@]}个):"
            for file_path in "${KEY_LIB_FILES[@]}"; do
              full_path="$OUTPUT_DIR/$file_path"
              if [ -f "$full_path" ] || [ -e "$full_path" ]; then
                EXISTING_FILES+=("$file_path")
                echo "  ✅ $file_path"
              else
                if [[ "$file_path" == *"usr/include/"* ]]; then
                  alt_paths=("include/${file_path##*/}" "sysroot/usr/include/${file_path##*/}" "${file_path#usr/}")
                  found_alt=false
                  for alt_path in "${alt_paths[@]}"; do
                    if [ -f "$OUTPUT_DIR/$alt_path" ]; then
                      EXISTING_FILES+=("$file_path (位于 $alt_path)")
                      echo "  ✅ $file_path (位于 $alt_path)"
                      found_alt=true
                      break
                    fi
                  done
                  if [ "$found_alt" = false ]; then
                    MISSING_FILES+=("$file_path")
                    echo "  ❌ $file_path: 缺失"
                  fi
                elif [[ "$file_path" == *"lib/gcc/"* ]]; then
                  gcc_base="lib/gcc/${COMPILER_PREFIX}"
                  if [ -d "$OUTPUT_DIR/$gcc_base" ]; then
                    actual_version_dir=$(ls "$OUTPUT_DIR/$gcc_base" 2>/dev/null | head -1)
                    if [ -n "$actual_version_dir" ]; then
                      lib_name=$(basename "$file_path")
                      actual_lib_path="$gcc_base/$actual_version_dir/$lib_name"
                      if [ -f "$OUTPUT_DIR/$actual_lib_path" ]; then
                        EXISTING_FILES+=("$file_path (版本: $actual_version_dir)")
                        echo "  ✅ $file_path (版本: $actual_version_dir)"
                      else
                        MISSING_FILES+=("$file_path")
                        echo "  ❌ $file_path: 缺失"
                      fi
                    else
                      MISSING_FILES+=("$file_path")
                      echo "  ❌ $file_path: 缺失 (GCC目录为空)"
                    fi
                  else
                    MISSING_FILES+=("$file_path")
                    echo "  ❌ $file_path: 缺失 (GCC目录不存在)"
                  fi
                else
                  MISSING_FILES+=("$file_path")
                  echo "  ❌ $file_path: 缺失"
                fi
              fi
            done
            echo ""
            echo "📊 检查统计:"
            echo "  - 总检查文件: $((${#KEY_FILES[@]} + ${#KEY_LIB_FILES[@]}))"
            echo "  - 存在文件: ${#EXISTING_FILES[@]}"
            echo "  - 缺失文件: ${#MISSING_FILES[@]}"
            echo ""
            echo "🔑 关键文件组完整性:"
            CORE_COMPILERS=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld")
            CORE_MISSING=0
            for core_file in "${CORE_COMPILERS[@]}"; do
              if [[ " ${MISSING_FILES[*]} " == *"$core_file"* ]]; then
                CORE_MISSING=$((CORE_MISSING + 1))
              fi
            done
            if [ $CORE_MISSING -eq 0 ]; then
              echo "  ✅ 核心编译工具组: 完整 (gcc, g++, ld)"
            else
              echo "  ❌ 核心编译工具组: 缺失 $CORE_MISSING 个文件"
            fi
            BINUTILS_TOOLS=("bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-objcopy")
            BINUTILS_MISSING=0
            for tool in "${BINUTILS_TOOLS[@]}"; do
              if [[ " ${MISSING_FILES[*]} " == *"$tool"* ]]; then
                BINUTILS_MISSING=$((BINUTILS_MISSING + 1))
              fi
            done
            if [ $BINUTILS_MISSING -eq 0 ]; then
              echo "  ✅ 基础二进制工具组: 完整 (ar, as, strip, objcopy)"
            else
              echo "  ❌ 基础二进制工具组: 缺失 $BINUTILS_MISSING 个文件"
            fi
            KEY_LIBRARIES=("lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc.a" "lib/libc.a" "usr/include/stdio.h")
            LIBRARIES_MISSING=0
            for lib in "${KEY_LIBRARIES[@]}"; do
              if [[ " ${MISSING_FILES[*]} " == *"$lib"* ]]; then
                LIBRARIES_MISSING=$((LIBRARIES_MISSING + 1))
              fi
            done
            if [ $LIBRARIES_MISSING -eq 0 ]; then
              echo "  ✅ 关键库文件组: 完整 (libgcc.a, libc.a, stdio.h)"
            else
              echo "  ❌ 关键库文件组: 缺失 $LIBRARIES_MISSING 个文件"
            fi
            echo ""
            if [ ${#MISSING_FILES[@]} -eq 0 ]; then
              echo "🎉 所有关键文件都存在，编译器完整！"
              if [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
                echo "⚠️ 强制重新构建已启用"
                NEED_BUILD="true"
              else
                echo "✅ 跳过构建，使用现有编译器"
                NEED_BUILD="false"
              fi
            else
              TOOL_MISSING=0
              LIB_MISSING=0
              for missing_file in "${MISSING_FILES[@]}"; do
                if [[ "$missing_file" == *"/bin/"* ]]; then
                  TOOL_MISSING=$((TOOL_MISSING + 1))
                elif [[ "$missing_file" == *"/lib/"* ]] || [[ "$missing_file" == *"/include/"* ]]; then
                  LIB_MISSING=$((LIB_MISSING + 1))
                fi
              done
              echo "⚠️ 编译器不完整:"
              echo "  - 缺失工具文件: $TOOL_MISSING 个"
              echo "  - 缺失库/头文件: $LIB_MISSING 个"
              if [ $CORE_MISSING -gt 0 ]; then
                echo "  ❗ 缺失核心编译工具，必须重新构建"
              fi
              if [ ${#MISSING_FILES[@]} -gt 0 ]; then
                echo ""
                echo "缺失的关键文件（前10个）:"
                for ((i=0; i<${#MISSING_FILES[@]} && i<10; i++)); do
                  echo "  - ${MISSING_FILES[$i]}"
                done
              fi
              NEED_BUILD="true"
            fi
          else
            echo "❌ 编译器目录不存在，需要构建"
            NEED_BUILD="true"
          fi
          echo ""
          echo "构建决策: $NEED_BUILD"
          echo "========================================"
          echo "need_build=$NEED_BUILD" >> $GITHUB_OUTPUT

  build-compiler:
    needs: [show-device-info, setup]
    if: needs.setup.outputs.need_build == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    
    steps:
      - name: 📥 检出仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 📋 显示构建信息
        run: |
          echo "========================================"
          echo "        交叉编译器构建信息              "
          echo "========================================"
          echo "目标架构: ${{ github.event.inputs.target_arch }}"
          echo "C库类型: ${{ github.event.inputs.libc }}"
          echo "GCC版本: ${{ needs.setup.outputs.gcc_version }}"
          echo "Binutils版本: ${{ needs.setup.outputs.binutils_version }}"
          echo "Linux内核: ${{ needs.setup.outputs.linux_version }}"
          echo "OpenWrt版本: ${{ env.OPENWRT_VERSION }}"
          echo "强制重建: ${{ github.event.inputs.force_rebuild }}"
          echo "清理构建: ${{ github.event.inputs.clean_build }}"
          echo "构建需求: ${{ needs.setup.outputs.need_build }}"
          echo "========================================"
          echo "开始时间: $(date)"
          echo "运行ID: ${{ github.run_id }}"
          echo "运行序号: ${{ github.run_number }}"

      - name: 🏗️ 设置环境
        run: |
          echo "=== 设置构建环境 ==="
          ARCH="${{ github.event.inputs.target_arch }}"
          LIBC="${{ github.event.inputs.libc }}"
          echo "处理架构: $ARCH"
          echo "处理C库: $LIBC"
          case "$ARCH" in
            arm_cortex-a7)
              TARGET="armvirt"
              SUBTARGET="armv7"
              ARCH_NAME="arm"
              ARCH_DIR="arm_cortex-a7"
              PREFIX="arm-openwrt-linux"
              CPU_TYPE="cortex-a7"
              TUNE="cortex-a7"
              ABI="32"
              FLOAT_ABI="hard"
              ;;
            aarch64)
              TARGET="armvirt"
              SUBTARGET="64"
              ARCH_NAME="aarch64"
              ARCH_DIR="aarch64"
              PREFIX="aarch64-openwrt-linux"
              CPU_TYPE="cortex-a53"
              TUNE="cortex-a53"
              ABI="64"
              FLOAT_ABI=""
              ;;
            x86_64)
              TARGET="x86"
              SUBTARGET="64"
              ARCH_NAME="x86_64"
              ARCH_DIR="x86_64"
              PREFIX="x86_64-openwrt-linux"
              CPU_TYPE="x86_64"
              TUNE="generic"
              ABI="64"
              FLOAT_ABI=""
              ;;
            mips)
              TARGET="ramips"
              SUBTARGET="mt7621"
              ARCH_NAME="mips"
              ARCH_DIR="mips"
              PREFIX="mips-openwrt-linux"
              CPU_TYPE="24kc"
              TUNE="24kc"
              ABI="32"
              FLOAT_ABI="softfloat"
              ;;
            mipsel)
              TARGET="ramips"
              SUBTARGET="mt7621"
              ARCH_NAME="mipsel"
              ARCH_DIR="mipsel"
              PREFIX="mipsel-openwrt-linux"
              CPU_TYPE="24kc"
              TUNE="24kc"
              ABI="32"
              FLOAT_ABI="softfloat"
              ;;
            arm_cortex-a53)
              TARGET="rockchip"
              SUBTARGET="armv8"
              ARCH_NAME="aarch64"
              ARCH_DIR="arm_cortex-a53"
              PREFIX="aarch64-openwrt-linux"
              CPU_TYPE="cortex-a53"
              TUNE="cortex-a53"
              ABI="64"
              FLOAT_ABI=""
              ;;
            riscv64)
              TARGET="virt"
              SUBTARGET="rv64"
              ARCH_NAME="riscv64"
              ARCH_DIR="riscv64"
              PREFIX="riscv64-openwrt-linux"
              CPU_TYPE="generic"
              TUNE="generic"
              ABI="lp64d"
              FLOAT_ABI="hard"
              ;;
            *)
              echo "❌ 不支持的架构: $ARCH"
              exit 1
              ;;
          esac
          if [ "$LIBC" = "musl" ]; then
            PREFIX="${PREFIX}-musl"
            LIBC_SUFFIX="musl"
            LIBC_DIR="musl"
            USE_MUSL="y"
            USE_GLIBC="n"
          else
            PREFIX="${PREFIX}-gnu"
            LIBC_SUFFIX="glibc"
            LIBC_DIR="glibc"
            USE_MUSL="n"
            USE_GLIBC="y"
          fi
          GCC_VERSION='${{ needs.setup.outputs.gcc_version }}'
          BINUTILS_VERSION='${{ needs.setup.outputs.binutils_version }}'
          LINUX_VERSION='${{ needs.setup.outputs.linux_version }}'
          BUILD_ID="${ARCH_DIR}_${LIBC_DIR}_gcc-${GCC_VERSION}_$(date +%Y%m%d_%H%M%S)"
          BUILD_DIR="/tmp/compiler-build-${BUILD_ID}"
          OUTPUT_DIR="${{ env.COMPILER_BASE_DIR }}/${ARCH_DIR}/${LIBC_DIR}/gcc-${GCC_VERSION}"
          echo "📊 环境配置汇总:"
          echo "  构建ID: $BUILD_ID"
          echo "  构建目录: $BUILD_DIR"
          echo "  输出目录: $OUTPUT_DIR"
          echo "  目标平台: $TARGET/$SUBTARGET"
          echo "  架构名称: $ARCH_NAME"
          echo "  架构目录: $ARCH_DIR"
          echo "  C库目录: $LIBC_DIR"
          echo "  编译器前缀: $PREFIX-"
          echo "  CPU类型: $CPU_TYPE"
          echo "  调优: $TUNE"
          echo "  ABI: $ABI"
          echo "  浮点ABI: $FLOAT_ABI"
          echo "  GCC版本: $GCC_VERSION"
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "OUTPUT_DIR=$OUTPUT_DIR" >> $GITHUB_ENV
          echo "TARGET=$TARGET" >> $GITHUB_ENV
          echo "SUBTARGET=$SUBTARGET" >> $GITHUB_ENV
          echo "ARCH_NAME=$ARCH_NAME" >> $GITHUB_ENV
          echo "ARCH_DIR=$ARCH_DIR" >> $GITHUB_ENV
          echo "LIBC_DIR=$LIBC_DIR" >> $GITHUB_ENV
          echo "PREFIX=$PREFIX" >> $GITHUB_ENV
          echo "CPU_TYPE=$CPU_TYPE" >> $GITHUB_ENV
          echo "TUNE=$TUNE" >> $GITHUB_ENV
          echo "ABI=$ABI" >> $GITHUB_ENV
          echo "FLOAT_ABI=$FLOAT_ABI" >> $GITHUB_ENV
          echo "USE_MUSL=$USE_MUSL" >> $GITHUB_ENV
          echo "USE_GLIBC=$USE_GLIBC" >> $GITHUB_ENV
          echo "GCC_VERSION=$GCC_VERSION" >> $GITHUB_ENV
          echo "BINUTILS_VERSION=$BINUTILS_VERSION" >> $GITHUB_ENV
          echo "LINUX_VERSION=$LINUX_VERSION" >> $GITHUB_ENV
          echo "LIBC_SUFFIX=$LIBC_SUFFIX" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV

      - name: 🔧 安装依赖
        run: |
          echo "=== 安装构建依赖 ==="
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential gcc g++ make flex bison libgmp-dev libmpfr-dev libmpc-dev libisl-dev python3 python3-dev python3-pip git wget curl zlib1g-dev liblzma-dev file gawk gettext libncurses5-dev libssl-dev python3-distutils rsync unzip ncurses-term autoconf automake libtool pkg-config texinfo gperf cmake ninja-build patchutils bc bzip2 xz-utils help2man libexpat-dev libgdbm-dev libreadline-dev libsqlite3-dev libffi-dev lzma-dev zstd libzstd-dev libelf-dev libdw-dev jq texlive texlive-latex-extra texlive-fonts-extra doxygen graphviz locales locales-all sudo apt-utils dialog man-db manpages manpages-dev
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ncurses-term ncurses-base ncurses-bin libncursesw5 libncursesw5-dev libtinfo5 libtinfo-dev terminfo
          export TERM=xterm-256color
          export TERMINFO=/usr/share/terminfo
          echo "export TERM=xterm-256color" >> ~/.bashrc
          echo "export TERMINFO=/usr/share/terminfo" >> ~/.bashrc
          sudo locale-gen en_US.UTF-8
          export LANG=en_US.UTF-8
          export LC_ALL=en_US.UTF-8
          echo "✅ 依赖安装完成"

      - name: 🗑️ 清理构建缓存
        if: ${{ github.event.inputs.clean_build == 'true' }}
        run: |
          echo "=== 清理构建缓存 ==="
          sudo rm -rf /tmp/compiler-build-* 2>/dev/null || true
          echo "✅ 缓存清理完成"

      - name: 📥 下载OpenWrt源码
        run: |
          echo "=== 获取OpenWrt源码 ==="
          mkdir -p "${{ env.BUILD_DIR }}"
          cd "${{ env.BUILD_DIR }}"
          echo "克隆OpenWrt ${{ env.OPENWRT_VERSION }} 分支..."
          git clone --depth 1 --branch v${{ env.OPENWRT_VERSION }} https://github.com/openwrt/openwrt.git .
          if [ $? -ne 0 ]; then
            echo "Git clone失败，使用tar包..."
            wget -q -O openwrt.tar.xz https://github.com/openwrt/openwrt/archive/refs/tags/v${{ env.OPENWRT_VERSION }}.tar.gz
            tar -xzf openwrt.tar.xz --strip-components=1
            rm -f openwrt.tar.xz
          fi
          echo "源码大小: $(du -sh . | cut -f1)"

      - name: 📝 生成配置文件（非交互式）
        run: |
          echo "=== 生成OpenWrt配置（非交互式）==="
          cd "${{ env.BUILD_DIR }}"
          CONFIG_FILE=".config"
          > $CONFIG_FILE
          echo "CONFIG_TARGET_${{ env.TARGET }}=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_BOARD=\"${{ env.TARGET }}\"" >> $CONFIG_FILE
          echo "CONFIG_TARGET_SUBTARGET=\"${{ env.SUBTARGET }}\"" >> $CONFIG_FILE
          echo "CONFIG_TARGET_ARCH_PACKAGES=\"${{ env.ARCH_NAME }}\"" >> $CONFIG_FILE
          echo "CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\"" >> $CONFIG_FILE
          echo "CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}-\"" >> $CONFIG_FILE
          echo "CONFIG_BUILD_TOOLCHAIN=y" >> $CONFIG_FILE
          echo "CONFIG_TOOLCHAINOPTS=y" >> $CONFIG_FILE
          echo "CONFIG_GCC_VERSION=\"${{ env.GCC_VERSION }}\"" >> $CONFIG_FILE
          echo "CONFIG_BINUTILS_VERSION=\"${{ env.BINUTILS_VERSION }}\"" >> $CONFIG_FILE
          echo "CONFIG_LINUX_VERSION=\"${{ env.LINUX_VERSION }}\"" >> $CONFIG_FILE
          echo "CONFIG_LIBC=\"${{ env.LIBC_SUFFIX }}\"" >> $CONFIG_FILE
          if [ "${{ env.USE_MUSL }}" = "y" ]; then
            echo "CONFIG_USE_MUSL=y" >> $CONFIG_FILE
            echo "CONFIG_MUSL_VERSION=\"${{ needs.setup.outputs.musl_version }}\"" >> $CONFIG_FILE
          else
            echo "CONFIG_USE_GLIBC=y" >> $CONFIG_FILE
            echo "CONFIG_GLIBC_VERSION=\"${{ needs.setup.outputs.glibc_version }}\"" >> $CONFIG_FILE
          fi
          echo "CONFIG_ARCH_${{ env.ARCH_NAME }}=y" >> $CONFIG_FILE
          if [ "${{ env.ARCH_NAME }}" = "arm" ] || [ "${{ env.ARCH_NAME }}" = "aarch64" ]; then
            echo "CONFIG_CPU_TYPE=\"${{ env.CPU_TYPE }}\"" >> $CONFIG_FILE
            echo "CONFIG_CPU_TUNE=\"${{ env.TUNE }}\"" >> $CONFIG_FILE
            if [ "${{ env.FLOAT_ABI }}" != "" ]; then
              echo "CONFIG_FPU=\"${{ env.FLOAT_ABI }}\"" >> $CONFIG_FILE
            fi
          elif [ "${{ env.ARCH_NAME }}" = "mips" ] || [ "${{ env.ARCH_NAME }}" = "mipsel" ]; then
            echo "CONFIG_CPU_TYPE=\"${{ env.CPU_TYPE }}\"" >> $CONFIG_FILE
          fi
          echo "CONFIG_DEVEL=y" >> $CONFIG_FILE
          echo "CONFIG_BUILD_PATENTED=y" >> $CONFIG_FILE
          echo "CONFIG_CCACHE=n" >> $CONFIG_FILE
          echo "CONFIG_ALL=n" >> $CONFIG_FILE
          echo "CONFIG_ALL_KMODS=n" >> $CONFIG_FILE
          echo "CONFIG_ALL_NONSHARED=n" >> $CONFIG_FILE
          echo "CONFIG_BASE_FILES=y" >> $CONFIG_FILE
          echo "CONFIG_BUSYBOX_DEFAULT_FEATURE_EDITING=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_ROOTFS_INITRAMFS=y" >> $CONFIG_FILE
          echo "CONFIG_EXTERNAL_TOOLCHAIN=n" >> $CONFIG_FILE
          echo "配置文件生成完成，共 $(wc -l < $CONFIG_FILE) 行"

      - name: 🔧 修复网络和终端环境
        run: |
          echo "=== 修复网络和终端环境 ==="
          cd "${{ env.BUILD_DIR }}"
          git config --global http.postBuffer 524288000
          git config --global http.lowSpeedLimit 0
          git config --global http.lowSpeedTime 999999
          git config --global core.compression 0
          git config --global core.looseCompression 0
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=dumb
          export DEBIAN_FRONTEND=noninteractive
          export GIT_SSL_NO_VERIFY=1
          export PYTHONHTTPSVERIFY=0
          export CURL_SSL_NO_VERIFY=1
          mkdir -p include/site
          mkdir -p tmp
          echo "✅ 网络和终端环境修复完成"

      - name: 🛠️ 应用配置（修复版 - 直接使用defconfig）
        run: |
          echo "=== 应用配置（修复版 - 直接使用defconfig）==="
          cd "${{ env.BUILD_DIR }}"
          
          # 备份原始配置文件
          if [ -f ".config" ]; then
            cp .config .config.original
            echo "✅ 已备份原始配置文件"
          fi
          
          echo "🚨 关键修复：使用正确的非交互式defconfig方法"
          echo "🔄 运行 make defconfig (无交互)..."
          
          # 设置正确的环境变量
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=dumb
          export DEBIAN_FRONTEND=noninteractive
          
          # 创建必要的目录
          mkdir -p include/site
          mkdir -p tmp
          
          # 方法1：直接运行defconfig，重定向所有输出
          echo "使用直接defconfig方法..."
          make defconfig > /tmp/defconfig_output.log 2>&1
          EXIT_CODE=$?
          
          echo "defconfig退出代码: $EXIT_CODE"
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "✅ defconfig成功"
            
            # 检查配置文件是否生成
            if [ -f ".config" ]; then
              config_lines=$(wc -l < .config)
              echo "配置文件行数: $config_lines"
              
              # 显示关键配置
              echo ""
              echo "📋 关键配置检查:"
              grep -E "CONFIG_TARGET|CONFIG_BUILD_TOOLCHAIN|CONFIG_GCC|CONFIG_LIBC" .config 2>/dev/null | head -10 || echo "无法获取配置摘要"
              
              echo "✅ 配置应用成功"
            else
              echo "❌ 配置文件未生成"
              
              # 尝试恢复原始配置
              if [ -f ".config.original" ]; then
                cp .config.original .config
                echo "✅ 恢复原始配置文件"
                exit 0
              else
                echo "❌ 无原始配置可恢复"
                exit 1
              fi
            fi
          else
            echo "⚠️ defconfig退出代码: $EXIT_CODE"
            
            # 即使退出代码非零，也可能成功生成了配置
            if [ -f ".config" ]; then
              echo "ℹ️ 配置文件已生成，可能defconfig有警告"
              config_lines=$(wc -l < .config)
              echo "配置文件行数: $config_lines"
              
              # 显示警告
              echo "defconfig警告信息:"
              tail -10 /tmp/defconfig_output.log
              
              echo "✅ 配置应用完成（有警告）"
            else
              echo "❌ defconfig失败且未生成配置文件"
              echo "错误输出:"
              tail -20 /tmp/defconfig_output.log
              
              # 尝试使用原始配置
              if [ -f ".config.original" ]; then
                cp .config.original .config
                echo "✅ 恢复原始配置文件并继续"
              else
                echo "❌ 无配置文件可用，退出"
                exit 1
              fi
            fi
          fi

      - name: 🔨 编译工具链
        timeout-minutes: 150
        run: |
          echo "=== 开始编译工具链 ==="
          cd "${{ env.BUILD_DIR }}"
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=dumb
          export DEBIAN_FRONTEND=noninteractive
          echo "系统信息:"
          echo "- CPU核心: $(nproc)"
          echo "- 内存: $(free -h | grep Mem | awk '{print $2}')"
          echo "下载源码包..."
          mkdir -p dl
          make -j1 download V=s 2>&1 | tail -30
          DOWNLOAD_STATUS=${PIPESTATUS[0]}
          if [ $DOWNLOAD_STATUS -eq 0 ]; then
            echo "✅ 源码包下载成功"
          else
            echo "⚠️ 源码包下载有警告，继续..."
          fi
          echo "编译工具链..."
          CPU_CORES=$(nproc)
          MAKE_JOBS=$CPU_CORES
          TOTAL_MEM=$(free -m | awk '/^Mem:/{print $2}')
          if [ $TOTAL_MEM -lt 4096 ]; then
            MAKE_JOBS=$((CPU_CORES / 2))
            if [ $MAKE_JOBS -lt 1 ]; then
              MAKE_JOBS=1
            fi
            echo "⚠️ 内存较低(${TOTAL_MEM}MB)，减少并行任务到 $MAKE_JOBS"
          fi
          echo "使用 $MAKE_JOBS 个并行任务进行编译..."
          make toolchain/compile -j$MAKE_JOBS V=s 2>&1 | tee /tmp/compile.log
          COMPILE_STATUS=${PIPESTATUS[0]}
          if [ $COMPILE_STATUS -eq 0 ]; then
            echo "✅ 工具链编译成功"
          else
            echo "❌ 工具链编译失败"
            echo "错误摘要:"
            grep -E "Error:|error:|failed:" /tmp/compile.log | tail -20
            exit 1
          fi
          echo "安装工具链..."
          make toolchain/install -j$MAKE_JOBS V=s 2>&1 | tee /tmp/install.log
          INSTALL_STATUS=${PIPESTATUS[0]}
          if [ $INSTALL_STATUS -eq 0 ]; then
            echo "✅ 工具链安装成功"
          else
            echo "⚠️ 安装有警告"
            grep -E "Warning:|warning:" /tmp/install.log | tail -10
          fi
          echo "✅ 工具链构建完成"

      - name: ✅ 验证构建结果
        run: |
          echo "=== 验证构建结果 ==="
          cd "${{ env.BUILD_DIR }}"
          TOOLCHAIN_DIR=$(find staging_dir -name "toolchain-*" -type d 2>/dev/null | head -1)
          if [ -z "$TOOLCHAIN_DIR" ]; then
            echo "❌ 未找到工具链目录"
            exit 1
          fi
          echo "✅ 工具链目录: $TOOLCHAIN_DIR"
          COMPILER_PATH=$(find "$TOOLCHAIN_DIR/bin" -name "*gcc" -type f 2>/dev/null | head -1)
          if [ -z "$COMPILER_PATH" ]; then
            echo "❌ 未找到编译器"
            exit 1
          fi
          echo "✅ 编译器: $(basename "$COMPILER_PATH")"
          echo "编译器信息:"
          "$COMPILER_PATH" --version 2>&1 | head -3
          echo "目标三元组:"
          "$COMPILER_PATH" -dumpmachine 2>&1
          echo "交叉编译测试..."
          echo '#include <stdio.h>' > test.c
          echo 'int main() { printf("OK\\n"); return 0; }' >> test.c
          "$COMPILER_PATH" test.c -o test_program 2>&1
          if [ $? -eq 0 ] && [ -f "test_program" ]; then
            echo "✅ 测试通过"
            file test_program
            rm -f test.c test_program
          else
            echo "❌ 测试失败"
            exit 1
          fi
          COMPILER_NAME=$(basename "$COMPILER_PATH")
          TOOL_PREFIX=$(echo "$COMPILER_NAME" | sed 's/gcc$//')
          echo "TOOLCHAIN_DIR=$TOOLCHAIN_DIR" >> $GITHUB_ENV
          echo "COMPILER_PATH=$COMPILER_PATH" >> $GITHUB_ENV
          echo "TOOL_PREFIX=$TOOL_PREFIX" >> $GITHUB_ENV

      - name: 💾 保存编译器
        run: |
          echo "=== 保存编译器 ==="
          cd "${{ env.BUILD_DIR }}"
          mkdir -p "${{ env.OUTPUT_DIR }}"
          if [ -d "${{ env.OUTPUT_DIR }}" ] && [ "$(ls -A "${{ env.OUTPUT_DIR }}" 2>/dev/null)" ]; then
            rm -rf "${{ env.OUTPUT_DIR }}"/*
            echo "✅ 清理输出目录"
          fi
          echo "复制工具链..."
          if [ ! -d "$TOOLCHAIN_DIR" ]; then
            echo "❌ 工具链目录不存在: $TOOLCHAIN_DIR"
            exit 1
          fi
          cp -r "$TOOLCHAIN_DIR"/* "${{ env.OUTPUT_DIR }}/" 2>&1 | grep -v "cannot stat" || true
          if [ -d "${{ env.OUTPUT_DIR }}/bin" ]; then
            echo "✅ 工具链复制成功"
            file_count=$(find "${{ env.OUTPUT_DIR }}" -type f 2>/dev/null | wc -l)
            echo "📊 复制文件数: $file_count"
          else
            echo "❌ 工具链复制失败，bin目录不存在"
            exit 1
          fi
          echo "创建元数据..."
          echo "{" > "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"architecture\": \"${{ env.ARCH_DIR }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"libc\": \"${{ env.LIBC_DIR }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"target\": \"${{ env.TARGET }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"subtarget\": \"${{ env.SUBTARGET }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"compiler_prefix\": \"${{ env.PREFIX }}-\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"gcc_version\": \"${{ env.GCC_VERSION }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"binutils_version\": \"${{ env.BINUTILS_VERSION }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"linux_version\": \"${{ env.LINUX_VERSION }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"openwrt_version\": \"${{ env.OPENWRT_VERSION }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"build_date\": \"$(date -Iseconds)\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"workflow_run\": \"${{ github.run_id }}\"," >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "  \"build_id\": \"${{ env.BUILD_ID }}\"" >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "}" >> "${{ env.OUTPUT_DIR }}/metadata.json"
          TOTAL_SIZE=$(du -sh "${{ env.OUTPUT_DIR }}" | cut -f1)
          FILE_COUNT=$(find "${{ env.OUTPUT_DIR }}" -type f | wc -l)
          echo "✅ 保存完成: $TOTAL_SIZE, $FILE_COUNT 文件"
          echo "TOTAL_SIZE=$TOTAL_SIZE" >> $GITHUB_ENV
          echo "FILE_COUNT=$FILE_COUNT" >> $GITHUB_ENV

      - name: 📤 提交到Git仓库
        run: |
          echo "=== 提交编译器到Git仓库 ==="
          cd "${{ github.workspace }}"
          git config user.email "github-actions@github.com"
          git config user.name "GitHub Actions"
          git pull origin main --no-edit
          git add -f "firmware-config/build-Compiler-file/compilers/*"
          if ! git diff --cached --quiet; then
            git commit -m "build(compiler): 添加 ${{ env.ARCH_DIR }}-${{ env.LIBC_DIR }} 交叉编译器" -m "版本: GCC ${{ env.GCC_VERSION }}" -m "大小: ${{ env.TOTAL_SIZE }}" -m "文件数: ${{ env.FILE_COUNT }}" -m "工作流: #${{ github.run_id }}"
            git push origin main
            echo "✅ 编译器已提交"
          else
            echo "没有变更需要提交"
          fi

      - name: 📊 显示最终成果
        run: |
          echo "========================================"
          echo "          🎉 构建完成报告              "
          echo "========================================"
          echo "✅ 交叉编译器构建成功!"
          echo "📊 构建信息:"
          echo "- 架构: ${{ env.ARCH_DIR }}"
          echo "- C库: ${{ env.LIBC_DIR }}"
          echo "- GCC版本: ${{ env.GCC_VERSION }}"
          echo "- 编译器前缀: ${{ env.PREFIX }}-"
          echo "- 目标平台: ${{ env.TARGET }}/${{ env.SUBTARGET }}"
          echo "📦 成果统计:"
          echo "- 总大小: ${{ env.TOTAL_SIZE }}"
          echo "- 文件数量: ${{ env.FILE_COUNT }}"
          echo "- 输出目录: ${{ env.OUTPUT_DIR }}"
          echo "🚀 使用方法:"
          echo "cd ${{ env.OUTPUT_DIR }}"
          echo "export STAGING_DIR=\$(pwd)"
          echo 'export PATH="$STAGING_DIR/bin:$PATH"'
          echo "${{ env.PREFIX }}-gcc --version"
          echo "========================================"

      - name: 📄 上传构建日志
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.BUILD_ID }}
          path: /tmp/*.log
          retention-days: 30

  skip-build:
    needs: setup
    if: needs.setup.outputs.need_build == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: ⏭️ 跳过构建
        run: |
          echo "========================================"
          echo "        ⏭️ 跳过构建报告                "
          echo "========================================"
          echo "✅ 编译器已存在且完整，跳过构建"
          echo "📋 跳过原因:"
          echo "- 编译器目录已存在且完整"
          echo "- 未启用强制重新构建"
          echo "🔧 现有编译器信息:"
          echo "- 架构: ${{ github.event.inputs.target_arch }}"
          echo "- C库: ${{ github.event.inputs.libc }}"
          echo "- GCC版本: ${{ needs.setup.outputs.gcc_version }}"
          echo "💡 如需重新构建，请启用'强制重新构建'选项"
          echo "========================================"

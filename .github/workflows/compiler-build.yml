# .github/workflows/compiler-matrix-build.yml
name: 🔧 交叉编译器构建

on:
  workflow_dispatch:
    inputs:
      target_arch:
        description: '目标架构（IPQ40xx选择arm_cortex-a7）'
        required: true
        default: 'arm_cortex-a7'
        type: choice
        options: ['aarch64', 'x86_64', 'mips', 'mipsel', 'arm_cortex-a7', 'arm_cortex-a53', 'riscv64']
      libc:
        description: 'C库类型（嵌入式推荐musl）'
        required: true
        default: 'musl'
        type: choice
        options: ['musl', 'glibc']
      gcc_version:
        description: 'GCC版本（OpenWrt 23.05支持12.3.0，输入auto自动选择）'
        required: true
        default: 'auto'
        type: string
      clean_build:
        description: '清理之前的构建缓存'
        required: true
        default: false
        type: boolean
      force_rebuild:
        description: '强制重新构建（即使已存在）'
        required: true
        default: false
        type: boolean

env:
  OPENWRT_VERSION: "23.05.2"
  COMPILER_BASE_DIR: "${{ github.workspace }}/firmware-config/build-Compiler-file/compilers"

jobs:
  show-device-info:
    runs-on: ubuntu-latest
    steps:
      - name: 📱 显示架构对应设备
        run: |
          echo "================================================"
          echo "          🎯 目标架构设备对应表                 "
          echo "================================================"
          echo ""
          echo "1️⃣ aarch64 (ARM 64位)"
          echo "   ├─ 📱 树莓派系列"
          echo "   │  ├─ 树莓派 4B (Raspberry Pi 4)"
          echo "   │  ├─ 树莓派 CM4 (Compute Module 4)"
          echo "   │  └─ 树莓派 400"
          echo "   ├─ 🖥️ 瑞芯微系列"
          echo "   │  ├─ RK3399 (ROCK Pi 4/NanoPi M4)"
          echo "   │  ├─ RK3568 (FriendlyELEC NanoPi R5S)"
          echo "   │  └─ RK3588 (高端开发板)"
          echo "   ├─ 📺 电视盒子"
          echo "   │  ├─ 晶晨 S905 (X96 Max/Beelink GT King)"
          echo "   │  ├─ 晶晨 S912 (H96 Pro/Beelink GT1)"
          echo "   │  └─ 晶晨 S922X (Odroid N2+)"
          echo "   ├─ 🖥️ 其他ARM64设备"
          echo "      ├─ Orange Pi 5"
          echo "      ├─ Banana Pi BPI-M5"
          echo "      └─ 各种ARM服务器"
          echo ""
          echo "2️⃣ x86_64 (x86 64位)"
          echo "   ├─ 💻 个人电脑"
          echo "   │  ├─ Intel Core i3/i5/i7/i9"
          echo "   │  ├─ AMD Ryzen 3/5/7/9"
          echo "   │  └─ 各种x86笔记本"
          echo "   ├─ 🖥️ 服务器"
          echo "   │  ├─ 戴尔PowerEdge"
          echo "   │  ├─ 惠普ProLiant"
          echo "   │  └─ 超微服务器"
          echo "   └─ ☁️ 虚拟机/容器"
          echo "      ├─ VMware/VirtualBox虚拟机"
          echo "      ├─ Docker容器"
          echo "      └─ 云服务器实例"
          echo ""
          echo "3️⃣ mips (MIPS 32位大端)"
          echo "   ├─ 🛜 华硕路由器"
          echo "   │  ├─ RT-ACRH17"
          echo "   │  ├─ RT-AC85P"
          echo "   │  └─ RT-N56U"
          echo "   ├─ 🛜 网件路由器"
          echo "   │  ├─ R7800"
          echo "   │  ├─ R9000"
          echo "   │  └─ XR500"
          echo "   └─ 🛜 其他MIPS设备"
          echo "      ├─ 中兴路由器"
          echo "      ├─ 华为旧款路由器"
          echo "      └─ 早期智能家居设备"
          echo ""
          echo "4️⃣ mipsel (MIPS 32位小端)"
          echo "   ├─ 🛜 联发科MT7621"
          echo "   │  ├─ 斐讯 K2P (Phicomm K2P)"
          echo "   │  ├─ Newifi 3 (新路由3)"
          echo "   │  ├─ 小米路由器 3G"
          echo "   │  ├─ 红米路由器 AC2100"
          echo "   │  └─ 极路由 B70"
          echo "   ├─ 🛜 联发科MT7620"
          echo "   │  ├─ 小米路由器 Mini"
          echo "   │  ├─ 极路由 1S"
          echo "   │  ├─ 斐讯 K1/K2"
          echo "   │  └─ 联想 Newifi Mini"
          echo "   └─ 🛜 其他MTK设备"
          echo "      ├─ MT7628 (低端路由)"
          echo "      ├─ MT7688 (物联网设备)"
          echo "      └─ 各种WiFi模块"
          echo ""
          echo "5️⃣ arm_cortex-a7 (ARM Cortex-A7)"
          echo "   ├─ 🛜 高通IPQ40xx系列 (你的设备！)"
          echo "   │  ├─ 小米路由器 4A千兆版"
          echo "   │  ├─ 红米路由器 AC2100 (部分版本)"
          echo "   │  ├─ GL.iNet MT1300"
          echo "   │  ├─ 360家庭防火墙 5Pro"
          echo "   │  ├─ Linksys EA6350 v3"
          echo "   │  └─ Netgear R6900P"
          echo "   ├─ 🛜 联发科MT7623/MT7629"
          echo "   │  ├─ 小米路由器 3G (部分版本)"
          echo "   │  ├─ 斐讯 K3C"
          echo "   │  └─ 部分企业路由器"
          echo "   ├─ 🍊 全志H3/H2+系列"
          echo "   │  ├─ Orange Pi PC (香橙派PC)"
          echo "   │  ├─ Orange Pi Plus"
          echo "   │  ├─ Banana Pi M2+"
          echo "   │  └─ NanoPi NEO"
          echo "   └─ 🔧 其他Cortex-A7设备"
          echo "      ├─ 某些智能摄像头"
          echo "      ├─ 工业控制设备"
          echo "      └─ 低功耗嵌入式设备"
          echo ""
          echo "6️⃣ arm_cortex-a53 (ARM Cortex-A53)"
          echo "   ├─ 🛜 联发科MT7622"
          echo "   │  ├─ 小米路由器 AX3600"
          echo "   │  ├─ 红米路由器 AX6"
          echo "   │  └─ 部分WiFi6路由器"
          echo "   ├─ 📱 64位设备32位模式"
          echo "   │  ├─ 树莓派 3 (32位模式)"
          echo "   │  ├─ 某些电视盒子"
          echo "   │  └─ 低端平板电脑"
          echo "   └─ 🔧 其他A53设备"
          echo "      ├─ 某些智能音箱"
          echo "      ├─ 物联网网关"
          echo "      └─ 边缘计算设备"
          echo ""
          echo "7️⃣ riscv64 (RISC-V 64位)"
          echo "   ├─ 🔬 开发板"
          echo "   │  ├─ HiFive Unmatched"
          echo "   │  ├─ VisionFive 2"
          echo "   │  ├─ BeagleV"
          echo "   │  └─ SiFive开发板"
          echo "   ├─ 🖥️ 新兴设备"
          echo "   │  ├─ 某些AI加速器"
          echo "   │  ├─ 定制芯片设备"
          echo "   │  └─ 学术研究设备"
          echo "   └─ 🚀 未来设备"
          echo "      ├─ RISC-V笔记本电脑"
          echo "      ├─ RISC-V服务器"
          echo "      └─ 各种创新硬件"
          echo ""
          echo "================================================"
          echo "选择建议："
          echo "1. 路由器设备 → 根据芯片型号选择"
          echo "2. 开发板 → 根据CPU架构选择"
          echo "3. PC/服务器 → 选择x86_64"
          echo "4. 不确定 → 查看设备规格书或CPU信息"
          echo "================================================"

  setup:
    runs-on: ubuntu-22.04
    outputs:
      gcc_version: ${{ steps.version-detection.outputs.gcc_version }}
      binutils_version: ${{ steps.version-detection.outputs.binutils_version }}
      linux_version: ${{ steps.version-detection.outputs.linux_version }}
      musl_version: ${{ steps.version-detection.outputs.musl_version }}
      glibc_version: ${{ steps.version-detection.outputs.glibc_version }}
      need_build: ${{ steps.check-existing.outputs.need_build }}
    steps:
      - name: 📥 检出仓库（用于检查现有编译器）
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          sparse-checkout: |
            firmware-config/build-Compiler-file/compilers
          sparse-checkout-cone-mode: false

      - name: 🏗️ 初始化
        run: |
          echo "=== 交叉编译器构建系统 ==="
          mkdir -p "${{ env.COMPILER_BASE_DIR }}"
          echo "基础目录: ${{ env.COMPILER_BASE_DIR }}"
          echo "开始时间: $(date)"
          echo "当前工作区内容:"
          ls -la "${{ github.workspace }}/firmware-config/build-Compiler-file/compilers" 2>/dev/null || echo "编译器目录不存在"

      - name: 🔍 动态检测GCC版本（修复版）
        id: version-detection
        run: |
          echo "=== 动态检测工具链版本 ==="
          USER_VERSION="${{ github.event.inputs.gcc_version }}"
          
          # OpenWrt 23.05支持的GCC版本（根据实际支持调整）
          OPENWRT_2305_SUPPORTED_GCC="12.3.0 12.2.0 11.3.0 11.2.0 10.4.0"
          
          if [ "$USER_VERSION" = "auto" ] || [ "$USER_VERSION" = "" ]; then
            echo "正在为OpenWrt 23.05选择支持的GCC版本..."
            # 使用OpenWrt 23.05支持的版本，而不是最新版本
            GCC_VERSION="12.3.0"
            echo "✅ 选择OpenWrt 23.05支持的GCC版本: $GCC_VERSION"
            echo "💡 支持的版本: $OPENWRT_2305_SUPPORTED_GCC"
          else
            GCC_VERSION="$USER_VERSION"
            echo "使用指定GCC版本: $GCC_VERSION"
            
            # 检查版本是否在支持列表中
            if [[ ! " $OPENWRT_2305_SUPPORTED_GCC " =~ " $GCC_VERSION " ]]; then
              echo "⚠️ 警告: GCC $GCC_VERSION 可能不被OpenWrt 23.05完全支持"
              echo "💡 建议使用: $OPENWRT_2305_SUPPORTED_GCC"
            fi
          fi
          
          # Binutils版本也需要兼容
          echo "检测Binutils版本..."
          BINUTILS_VERSION="2.40"  # OpenWrt 23.05使用2.40
          echo "✅ 使用Binutils版本: $BINUTILS_VERSION"
          
          # 其他版本
          LINUX_VERSION="5.15.133"
          MUSL_VERSION="1.2.4"
          GLIBC_VERSION="2.37"
          
          echo "最终版本配置:"
          echo "- GCC: $GCC_VERSION (OpenWrt 23.05兼容)"
          echo "- Binutils: $BINUTILS_VERSION"
          echo "- Linux内核: $LINUX_VERSION"
          echo "- Musl: $MUSL_VERSION"
          echo "- Glibc: $GLIBC_VERSION"
          
          echo "gcc_version=$GCC_VERSION" >> $GITHUB_OUTPUT
          echo "binutils_version=$BINUTILS_VERSION" >> $GITHUB_OUTPUT
          echo "linux_version=$LINUX_VERSION" >> $GITHUB_OUTPUT
          echo "musl_version=$MUSL_VERSION" >> $GITHUB_OUTPUT
          echo "glibc_version=$GLIBC_VERSION" >> $GITHUB_OUTPUT

      - name: 🔎 检查现有编译器
        id: check-existing
        run: |
          echo "=== 检查现有编译器 ==="
          echo "========================================"
          echo "         🔧 编译器完整性检查            "
          echo "========================================"
          ARCH="${{ github.event.inputs.target_arch }}"
          LIBC="${{ github.event.inputs.libc }}"
          GCC_VERSION='${{ steps.version-detection.outputs.gcc_version }}'
          if [ "$LIBC" = "musl" ]; then
            LIBC_DIR="musl"
          else
            LIBC_DIR="glibc"
          fi
          OUTPUT_DIR="${{ env.COMPILER_BASE_DIR }}/${ARCH}/${LIBC_DIR}/gcc-${GCC_VERSION}"
          echo "检查目录: $OUTPUT_DIR"
          echo "完整路径: $(realpath "$OUTPUT_DIR" 2>/dev/null || echo "$OUTPUT_DIR")"
          echo "📋 关键编译器工具清单:"
          echo ""
          REQUIRED_DIRS=("bin" "lib" "include" "libexec" "share" "usr")
          echo "📁 必需目录检查:"
          for dir in "${REQUIRED_DIRS[@]}"; do
            if [ -d "$OUTPUT_DIR/$dir" ]; then
              echo "  ✅ 目录 $dir"
            else
              echo "  ❌ 目录 $dir: 缺失"
            fi
          done
          echo ""
          NEED_BUILD="true"
          if [ -d "$OUTPUT_DIR" ]; then
            echo "✅ 编译器目录已存在"
            echo ""
            COMPILER_PREFIX=""
            if [ -d "$OUTPUT_DIR/bin" ]; then
              GCC_FILE=$(find "$OUTPUT_DIR/bin" -name "*gcc" -type f 2>/dev/null | head -1)
              if [ -n "$GCC_FILE" ]; then
                COMPILER_PREFIX=$(basename "$GCC_FILE" | sed 's/-gcc$//')
                echo "🔍 检测到编译器前缀: $COMPILER_PREFIX"
              fi
            fi
            if [ -z "$COMPILER_PREFIX" ]; then
              case "$ARCH" in
                arm_cortex-a7)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="arm-openwrt-linux-muslgnueabihf"
                  else
                    COMPILER_PREFIX="arm-openwrt-linux-gnueabihf"
                  fi
                  ;;
                aarch64)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="aarch64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="aarch64-openwrt-linux-gnu"
                  fi
                  ;;
                x86_64)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="x86_64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="x86_64-openwrt-linux-gnu"
                  fi
                  ;;
                mips)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="mips-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="mips-openwrt-linux-gnu"
                  fi
                  ;;
                mipsel)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="mipsel-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="mipsel-openwrt-linux-gnu"
                  fi
                  ;;
                arm_cortex-a53)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="aarch64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="aarch64-openwrt-linux-gnu"
                  fi
                  ;;
                riscv64)
                  if [ "$LIBC" = "musl" ]; then
                    COMPILER_PREFIX="riscv64-openwrt-linux-musl"
                  else
                    COMPILER_PREFIX="riscv64-openwrt-linux-gnu"
                  fi
                  ;;
                *)
                  COMPILER_PREFIX="unknown"
                  ;;
              esac
              echo "🔍 使用架构推断编译器前缀: $COMPILER_PREFIX"
            fi
            echo ""
            echo "🛠️ 关键编译器文件检查:"
            echo ""
            case "$ARCH" in
              aarch64)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ld.gold" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-strings" "bin/${COMPILER_PREFIX}-c++" "bin/${COMPILER_PREFIX}-c++filt" "bin/${COMPILER_PREFIX}-addr2line" "bin/${COMPILER_PREFIX}-gcc-ar" "bin/${COMPILER_PREFIX}-gcc-nm" "bin/${COMPILER_PREFIX}-gcc-ranlib" "bin/${COMPILER_PREFIX}-gcov" "bin/${COMPILER_PREFIX}-gcov-dump" "bin/${COMPILER_PREFIX}-gcov-tool" "bin/${COMPILER_PREFIX}-gprof")
                ;;
              x86_64)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-elfedit" "bin/${COMPILER_PREFIX}-gcc-ranlib")
                ;;
              mips)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-strings")
                ;;
              mipsel)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf" "bin/${COMPILER_PREFIX}-size" "bin/${COMPILER_PREFIX}-strings" "bin/${COMPILER_PREFIX}-c++" "bin/${COMPILER_PREFIX}-c++filt")
                ;;
              arm_cortex-a7)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ld.bfd" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf")
                ;;
              arm_cortex-a53)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-elfedit" "bin/${COMPILER_PREFIX}-gcc-ranlib")
                ;;
              riscv64)
                KEY_FILES=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld" "bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-nm" "bin/${COMPILER_PREFIX}-objcopy" "bin/${COMPILER_PREFIX}-objdump" "bin/${COMPILER_PREFIX}-ranlib" "bin/${COMPILER_PREFIX}-readelf")
                ;;
            esac
            ACTUAL_GCC_VERSION="$GCC_VERSION"
            if [ -d "$OUTPUT_DIR/lib/gcc/${COMPILER_PREFIX}" ]; then
              DETECTED_VERSION=$(ls "$OUTPUT_DIR/lib/gcc/${COMPILER_PREFIX}" 2>/dev/null | head -1)
              if [ -n "$DETECTED_VERSION" ]; then
                ACTUAL_GCC_VERSION="$DETECTED_VERSION"
                echo "🔍 检测到实际GCC版本: $ACTUAL_GCC_VERSION"
              fi
            fi
            KEY_LIB_FILES=("lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc.a" "lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc_eh.a" "lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc_s.so" "lib/libc.a" "lib/libm.a" "usr/include/stdio.h" "usr/include/stdlib.h" "usr/include/string.h" "usr/include/features.h")
            MISSING_FILES=()
            EXISTING_FILES=()
            echo "🔧 编译器工具文件 (${#KEY_FILES[@]}个):"
            for file_path in "${KEY_FILES[@]}"; do
              full_path="$OUTPUT_DIR/$file_path"
              if [ -f "$full_path" ] || [ -e "$full_path" ]; then
                EXISTING_FILES+=("$file_path")
                echo "  ✅ $file_path"
              else
                MISSING_FILES+=("$file_path")
                echo "  ❌ $file_path: 缺失"
              fi
            done
            echo ""
            echo "📚 关键库文件 (${#KEY_LIB_FILES[@]}个):"
            for file_path in "${KEY_LIB_FILES[@]}"; do
              full_path="$OUTPUT_DIR/$file_path"
              if [ -f "$full_path" ] || [ -e "$full_path" ]; then
                EXISTING_FILES+=("$file_path")
                echo "  ✅ $file_path"
              else
                if [[ "$file_path" == *"usr/include/"* ]]; then
                  alt_paths=("include/${file_path##*/}" "sysroot/usr/include/${file_path##*/}" "${file_path#usr/}")
                  found_alt=false
                  for alt_path in "${alt_paths[@]}"; do
                    if [ -f "$OUTPUT_DIR/$alt_path" ]; then
                      EXISTING_FILES+=("$file_path (位于 $alt_path)")
                      echo "  ✅ $file_path (位于 $alt_path)"
                      found_alt=true
                      break
                    fi
                  done
                  if [ "$found_alt" = false ]; then
                    MISSING_FILES+=("$file_path")
                    echo "  ❌ $file_path: 缺失"
                  fi
                elif [[ "$file_path" == *"lib/gcc/"* ]]; then
                  gcc_base="lib/gcc/${COMPILER_PREFIX}"
                  if [ -d "$OUTPUT_DIR/$gcc_base" ]; then
                    actual_version_dir=$(ls "$OUTPUT_DIR/$gcc_base" 2>/dev/null | head -1)
                    if [ -n "$actual_version_dir" ]; then
                      lib_name=$(basename "$file_path")
                      actual_lib_path="$gcc_base/$actual_version_dir/$lib_name"
                      if [ -f "$OUTPUT_DIR/$actual_lib_path" ]; then
                        EXISTING_FILES+=("$file_path (版本: $actual_version_dir)")
                        echo "  ✅ $file_path (版本: $actual_version_dir)"
                      else
                        MISSING_FILES+=("$file_path")
                        echo "  ❌ $file_path: 缺失"
                      fi
                    else
                      MISSING_FILES+=("$file_path")
                      echo "  ❌ $file_path: 缺失 (GCC目录为空)"
                    fi
                  else
                    MISSING_FILES+=("$file_path")
                    echo "  ❌ $file_path: 缺失 (GCC目录不存在)"
                  fi
                else
                  MISSING_FILES+=("$file_path")
                  echo "  ❌ $file_path: 缺失"
                fi
              fi
            done
            echo ""
            echo "📊 检查统计:"
            echo "  - 总检查文件: $((${#KEY_FILES[@]} + ${#KEY_LIB_FILES[@]}))"
            echo "  - 存在文件: ${#EXISTING_FILES[@]}"
            echo "  - 缺失文件: ${#MISSING_FILES[@]}"
            echo ""
            echo "🔑 关键文件组完整性:"
            CORE_COMPILERS=("bin/${COMPILER_PREFIX}-gcc" "bin/${COMPILER_PREFIX}-g++" "bin/${COMPILER_PREFIX}-ld")
            CORE_MISSING=0
            for core_file in "${CORE_COMPILERS[@]}"; do
              if [[ " ${MISSING_FILES[*]} " == *"$core_file"* ]]; then
                CORE_MISSING=$((CORE_MISSING + 1))
              fi
            done
            if [ $CORE_MISSING -eq 0 ]; then
              echo "  ✅ 核心编译工具组: 完整 (gcc, g++, ld)"
            else
              echo "  ❌ 核心编译工具组: 缺失 $CORE_MISSING 个文件"
            fi
            BINUTILS_TOOLS=("bin/${COMPILER_PREFIX}-ar" "bin/${COMPILER_PREFIX}-as" "bin/${COMPILER_PREFIX}-strip" "bin/${COMPILER_PREFIX}-objcopy")
            BINUTILS_MISSING=0
            for tool in "${BINUTILS_TOOLS[@]}"; do
              if [[ " ${MISSING_FILES[*]} " == *"$tool"* ]]; then
                BINUTILS_MISSING=$((BINUTILS_MISSING + 1))
              fi
            done
            if [ $BINUTILS_MISSING -eq 0 ]; then
              echo "  ✅ 基础二进制工具组: 完整 (ar, as, strip, objcopy)"
            else
              echo "  ❌ 基础二进制工具组: 缺失 $BINUTILS_MISSING 个文件"
            fi
            KEY_LIBRARIES=("lib/gcc/${COMPILER_PREFIX}/${ACTUAL_GCC_VERSION}/libgcc.a" "lib/libc.a" "usr/include/stdio.h")
            LIBRARIES_MISSING=0
            for lib in "${KEY_LIBRARIES[@]}"; do
              if [[ " ${MISSING_FILES[*]} " == *"$lib"* ]]; then
                LIBRARIES_MISSING=$((LIBRARIES_MISSING + 1))
              fi
            done
            if [ $LIBRARIES_MISSING -eq 0 ]; then
              echo "  ✅ 关键库文件组: 完整 (libgcc.a, libc.a, stdio.h)"
            else
              echo "  ❌ 关键库文件组: 缺失 $LIBRARIES_MISSING 个文件"
            fi
            echo ""
            if [ ${#MISSING_FILES[@]} -eq 0 ]; then
              echo "🎉 所有关键文件都存在，编译器完整！"
              if [ "${{ github.event.inputs.force_rebuild }}" = "true" ]; then
                echo "⚠️ 强制重新构建已启用"
                NEED_BUILD="true"
              else
                echo "✅ 跳过构建，使用现有编译器"
                NEED_BUILD="false"
              fi
            else
              TOOL_MISSING=0
              LIB_MISSING=0
              for missing_file in "${MISSING_FILES[@]}"; do
                if [[ "$missing_file" == *"/bin/"* ]]; then
                  TOOL_MISSING=$((TOOL_MISSING + 1))
                elif [[ "$missing_file" == *"/lib/"* ]] || [[ "$missing_file" == *"/include/"* ]]; then
                  LIB_MISSING=$((LIB_MISSING + 1))
                fi
              done
              echo "⚠️ 编译器不完整:"
              echo "  - 缺失工具文件: $TOOL_MISSING 个"
              echo "  - 缺失库/头文件: $LIB_MISSING 个"
              if [ $CORE_MISSING -gt 0 ]; then
                echo "  ❗ 缺失核心编译工具，必须重新构建"
              fi
              if [ ${#MISSING_FILES[@]} -gt 0 ]; then
                echo ""
                echo "缺失的关键文件（前10个）:"
                for ((i=0; i<${#MISSING_FILES[@]} && i<10; i++)); do
                  echo "  - ${MISSING_FILES[$i]}"
                done
              fi
              NEED_BUILD="true"
            fi
          else
            echo "❌ 编译器目录不存在，需要构建"
            NEED_BUILD="true"
          fi
          echo ""
          echo "构建决策: $NEED_BUILD"
          echo "========================================"
          echo "need_build=$NEED_BUILD" >> $GITHUB_OUTPUT

  build-compiler:
    needs: [show-device-info, setup]
    if: needs.setup.outputs.need_build == 'true'
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    
    steps:
      - name: 📥 检出仓库
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: 📋 显示构建信息
        run: |
          echo "========================================"
          echo "        交叉编译器构建信息              "
          echo "========================================"
          echo "🚨 用户输入参数:"
          echo "  目标架构: ${{ github.event.inputs.target_arch }}"
          echo "  C库类型: ${{ github.event.inputs.libc }}"
          echo "  GCC版本: ${{ github.event.inputs.gcc_version }}"
          echo "  清理构建: ${{ github.event.inputs.clean_build }}"
          echo "  强制重建: ${{ github.event.inputs.force_rebuild }}"
          echo "🚨 检测到的版本:"
          echo "  GCC版本: ${{ needs.setup.outputs.gcc_version }}"
          echo "  Binutils版本: ${{ needs.setup.outputs.binutils_version }}"
          echo "  Linux内核: ${{ needs.setup.outputs.linux_version }}"
          echo "  Musl版本: ${{ needs.setup.outputs.musl_version }}"
          echo "  Glibc版本: ${{ needs.setup.outputs.glibc_version }}"
          echo "🚨 构建需求:"
          echo "  是否需要构建: ${{ needs.setup.outputs.need_build }}"
          echo "========================================"
          echo "开始时间: $(date)"
          echo "运行ID: ${{ github.run_id }}"
          echo "运行序号: ${{ github.run_number }}"

      - name: 🏗️ 设置环境（修复版）
        run: |
          echo "=== 设置构建环境 ==="
          ARCH="${{ github.event.inputs.target_arch }}"
          LIBC="${{ github.event.inputs.libc }}"
          echo "🚨 处理架构: $ARCH"
          echo "🚨 处理C库: $LIBC"
          
          # 修复：根据架构正确设置目标平台
          case "$ARCH" in
            arm_cortex-a7)
              TARGET="armvirt"
              SUBTARGET="armv7"
              ARCH_NAME="arm"
              ARCH_DIR="arm_cortex-a7"
              PREFIX="arm-openwrt-linux"
              CPU_TYPE="cortex-a7"
              TUNE="cortex-a7"
              ABI="32"
              FLOAT_ABI="hard"
              ;;
            aarch64)
              TARGET="armvirt"
              SUBTARGET="64"
              ARCH_NAME="aarch64"
              ARCH_DIR="aarch64"
              PREFIX="aarch64-openwrt-linux"
              CPU_TYPE="cortex-a53"
              TUNE="cortex-a53"
              ABI="64"
              FLOAT_ABI=""
              ;;
            x86_64)
              TARGET="x86"
              SUBTARGET="64"
              ARCH_NAME="x86_64"
              ARCH_DIR="x86_64"
              PREFIX="x86_64-openwrt-linux"
              CPU_TYPE="x86-64"
              TUNE="generic"
              ABI="64"
              FLOAT_ABI=""
              ;;
            mips)
              TARGET="ramips"
              SUBTARGET="mt7621"
              ARCH_NAME="mips"
              ARCH_DIR="mips"
              PREFIX="mips-openwrt-linux"
              CPU_TYPE="24kc"
              TUNE="24kc"
              ABI="32"
              FLOAT_ABI="softfloat"
              ;;
            mipsel)
              TARGET="ramips"
              SUBTARGET="mt7621"
              ARCH_NAME="mipsel"
              ARCH_DIR="mipsel"
              PREFIX="mipsel-openwrt-linux"
              CPU_TYPE="24kc"
              TUNE="24kc"
              ABI="32"
              FLOAT_ABI="softfloat"
              ;;
            arm_cortex-a53)
              TARGET="rockchip"
              SUBTARGET="armv8"
              ARCH_NAME="aarch64"
              ARCH_DIR="arm_cortex-a53"
              PREFIX="aarch64-openwrt-linux"
              CPU_TYPE="cortex-a53"
              TUNE="cortex-a53"
              ABI="64"
              FLOAT_ABI=""
              ;;
            riscv64)
              TARGET="virt"
              SUBTARGET="rv64"
              ARCH_NAME="riscv64"
              ARCH_DIR="riscv64"
              PREFIX="riscv64-openwrt-linux"
              CPU_TYPE="generic"
              TUNE="generic"
              ABI="lp64d"
              FLOAT_ABI="hard"
              ;;
            *)
              echo "❌ 不支持的架构: $ARCH"
              exit 1
              ;;
          esac
          
          if [ "$LIBC" = "musl" ]; then
            PREFIX="${PREFIX}-musl"
            LIBC_SUFFIX="musl"
            LIBC_DIR="musl"
            USE_MUSL="y"
            USE_GLIBC="n"
          else
            PREFIX="${PREFIX}-gnu"
            LIBC_SUFFIX="glibc"
            LIBC_DIR="glibc"
            USE_MUSL="n"
            USE_GLIBC="y"
          fi
          
          GCC_VERSION='${{ needs.setup.outputs.gcc_version }}'
          BINUTILS_VERSION='${{ needs.setup.outputs.binutils_version }}'
          LINUX_VERSION='${{ needs.setup.outputs.linux_version }}'
          BUILD_ID="${ARCH_DIR}_${LIBC_DIR}_gcc-${GCC_VERSION}_$(date +%Y%m%d_%H%M%S)"
          BUILD_DIR="/tmp/compiler-build-${BUILD_ID}"
          OUTPUT_DIR="${{ env.COMPILER_BASE_DIR }}/${ARCH_DIR}/${LIBC_DIR}/gcc-${GCC_VERSION}"
          
          echo "🚨 环境配置汇总:"
          echo "  构建ID: $BUILD_ID"
          echo "  构建目录: $BUILD_DIR"
          echo "  输出目录: $OUTPUT_DIR"
          echo "  目标平台: $TARGET/$SUBTARGET"
          echo "  架构名称: $ARCH_NAME"
          echo "  架构目录: $ARCH_DIR"
          echo "  C库目录: $LIBC_DIR"
          echo "  编译器前缀: $PREFIX-"
          echo "  CPU类型: $CPU_TYPE"
          echo "  调优: $TUNE"
          echo "  ABI: $ABI"
          echo "  浮点ABI: $FLOAT_ABI"
          echo "  GCC版本: $GCC_VERSION (OpenWrt 23.05兼容)"
          echo "  使用Musl: $USE_MUSL"
          echo "  使用Glibc: $USE_GLIBC"
          
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "OUTPUT_DIR=$OUTPUT_DIR" >> $GITHUB_ENV
          echo "TARGET=$TARGET" >> $GITHUB_ENV
          echo "SUBTARGET=$SUBTARGET" >> $GITHUB_ENV
          echo "ARCH_NAME=$ARCH_NAME" >> $GITHUB_ENV
          echo "ARCH_DIR=$ARCH_DIR" >> $GITHUB_ENV
          echo "LIBC_DIR=$LIBC_DIR" >> $GITHUB_ENV
          echo "PREFIX=$PREFIX" >> $GITHUB_ENV
          echo "CPU_TYPE=$CPU_TYPE" >> $GITHUB_ENV
          echo "TUNE=$TUNE" >> $GITHUB_ENV
          echo "ABI=$ABI" >> $GITHUB_ENV
          echo "FLOAT_ABI=$FLOAT_ABI" >> $GITHUB_ENV
          echo "USE_MUSL=$USE_MUSL" >> $GITHUB_ENV
          echo "USE_GLIBC=$USE_GLIBC" >> $GITHUB_ENV
          echo "GCC_VERSION=$GCC_VERSION" >> $GITHUB_ENV
          echo "BINUTILS_VERSION=$BINUTILS_VERSION" >> $GITHUB_ENV
          echo "LINUX_VERSION=$LINUX_VERSION" >> $GITHUB_ENV
          echo "LIBC_SUFFIX=$LIBC_SUFFIX" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV

      - name: 🔧 安装依赖
        run: |
          echo "=== 安装构建依赖 ==="
          echo "🚨 开始安装构建工具链所需依赖..."
          sudo apt-get update -y
          echo "🚨 安装基础编译工具..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential gcc g++ make flex bison libgmp-dev libmpfr-dev libmpc-dev libisl-dev python3 python3-dev python3-pip git wget curl zlib1g-dev liblzma-dev file gawk gettext libncurses5-dev libssl-dev python3-distutils rsync unzip ncurses-term autoconf automake libtool pkg-config texinfo gperf cmake ninja-build patchutils bc bzip2 xz-utils help2man libexpat-dev libgdbm-dev libreadline-dev libsqlite3-dev libffi-dev lzma-dev zstd libzstd-dev libelf-dev libdw-dev jq texlive texlive-latex-extra texlive-fonts-extra doxygen graphviz locales locales-all sudo apt-utils dialog man-db manpages manpages-dev
          
          echo "🚨 安装终端支持包..."
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y ncurses-term ncurses-base ncurses-bin libncursesw5 libncursesw5-dev libtinfo5 libtinfo-dev terminfo
          
          echo "🚨 设置终端环境..."
          export TERM=xterm-256color
          export TERMINFO=/usr/share/terminfo
          echo "export TERM=xterm-256color" >> ~/.bashrc
          echo "export TERMINFO=/usr/share/terminfo" >> ~/.bashrc
          
          echo "🚨 设置语言环境..."
          sudo locale-gen en_US.UTF-8
          sudo update-locale LANG=en_US.UTF-8
          export LANG=en_US.UTF-8
          export LC_ALL=en_US.UTF-8
          export LANGUAGE=en_US:en
          
          echo "✅ 依赖安装完成"
          echo "已安装包数量: $(dpkg -l | wc -l)"
          echo "磁盘使用情况:"
          df -h /

      - name: 🗑️ 清理构建缓存
        if: ${{ github.event.inputs.clean_build == 'true' }}
        run: |
          echo "=== 清理构建缓存 ==="
          echo "🚨 清理之前的构建缓存..."
          sudo rm -rf /tmp/compiler-build-* 2>/dev/null || true
          echo "✅ 缓存清理完成"

      - name: 📥 下载OpenWrt源码
        run: |
          echo "=== 获取OpenWrt源码 ==="
          mkdir -p "${{ env.BUILD_DIR }}"
          cd "${{ env.BUILD_DIR }}"
          echo "🚨 当前目录: $(pwd)"
          echo "🚨 克隆OpenWrt ${{ env.OPENWRT_VERSION }} 分支..."
          
          # 尝试使用 git clone
          if git clone --depth 1 --branch v${{ env.OPENWRT_VERSION }} https://github.com/openwrt/openwrt.git . 2>&1 | tee /tmp/clone.log; then
            echo "✅ Git clone 成功"
          else
            echo "⚠️ Git clone失败，尝试使用tar包..."
            CLONE_ERROR=$(tail -20 /tmp/clone.log)
            echo "克隆错误: $CLONE_ERROR"
            
            wget -q -O openwrt.tar.xz https://github.com/openwrt/openwrt/archive/refs/tags/v${{ env.OPENWRT_VERSION }}.tar.gz
            if [ $? -eq 0 ]; then
              echo "✅ 下载tar包成功"
              tar -xzf openwrt.tar.xz --strip-components=1
              rm -f openwrt.tar.xz
              echo "✅ 解压完成"
            else
              echo "❌ 下载tar包失败"
              exit 1
            fi
          fi
          
          echo "源码大小: $(du -sh . | cut -f1)"
          echo "文件数量: $(find . -type f | wc -l)"
          echo "目录结构:"
          ls -la

      - name: 📝 生成配置文件（修复验证版）
        run: |
          echo "=== 生成OpenWrt配置（修复验证版）==="
          cd "${{ env.BUILD_DIR }}"
          
          echo "🚨 当前工作目录: $(pwd)"
          
          # 清空并重新创建配置
          > .config
          
          echo "🚨 写入配置..."
          echo "CONFIG_TARGET_${{ env.TARGET }}=y" >> .config
          echo "CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y" >> .config
          echo "CONFIG_TARGET_BOARD=\"${{ env.TARGET }}\"" >> .config
          echo "CONFIG_TARGET_SUBTARGET=\"${{ env.SUBTARGET }}\"" >> .config
          echo "CONFIG_TARGET_ARCH_PACKAGES=\"${{ env.ARCH_NAME }}\"" >> .config
          echo "CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\"" >> .config
          echo "CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}-\"" >> .config
          
          echo "CONFIG_BUILD_TOOLCHAIN=y" >> .config
          echo "CONFIG_TOOLCHAINOPTS=y" >> .config
          echo "CONFIG_GCC_VERSION=\"${{ env.GCC_VERSION }}\"" >> .config
          echo "CONFIG_BINUTILS_VERSION=\"${{ env.BINUTILS_VERSION }}\"" >> .config
          echo "CONFIG_LINUX_VERSION=\"${{ env.LINUX_VERSION }}\"" >> .config
          echo "CONFIG_LIBC=\"${{ env.LIBC_SUFFIX }}\"" >> .config
          
          echo "CONFIG_ARCH_${{ env.ARCH_NAME }}=y" >> .config
          
          if [ "${{ env.ARCH_NAME }}" = "arm" ]; then
            echo "CONFIG_arm=y" >> .config
            echo "CONFIG_CPU_TYPE=\"${{ env.CPU_TYPE }}\"" >> .config
            echo "CONFIG_CPU_TUNE=\"${{ env.TUNE }}\"" >> .config
            if [ "${{ env.FLOAT_ABI }}" != "" ]; then
              echo "CONFIG_FPU=\"${{ env.FLOAT_ABI }}\"" >> .config
            fi
          fi
          
          echo "CONFIG_DEVEL=y" >> .config
          echo "CONFIG_BUILD_PATENTED=y" >> .config
          echo "CONFIG_CCACHE=n" >> .config
          echo "CONFIG_ALL=n" >> .config
          echo "CONFIG_ALL_KMODS=n" >> .config
          echo "CONFIG_ALL_NONSHARED=n" >> .config
          echo "CONFIG_BASE_FILES=y" >> .config
          echo "CONFIG_BUSYBOX_DEFAULT_FEATURE_EDITING=y" >> .config
          echo "CONFIG_TARGET_ROOTFS_INITRAMFS=y" >> .config
          echo "CONFIG_EXTERNAL_TOOLCHAIN=n" >> .config
          echo "CONFIG_BUILD_TOOLS=y" >> .config
          echo "CONFIG_TOOLCHAIN_BUILD=y" >> .config
          
          echo "🚨 配置文件内容:"
          echo "========================================"
          cat .config
          echo "========================================"
          CONFIG_LINES=$(wc -l < .config)
          echo "配置文件生成完成，共 $CONFIG_LINES 行"
          
          echo "🚨 验证配置关键词:"
          grep -n -E "TARGET_${{ env.TARGET }}|TARGET_ARCH|CPU_TYPE|PREFIX" .config
          
          echo "🚨 配置验证检查:"
          # 修复验证逻辑 - 正确匹配带引号的值
          TARGET_CHECK=$(grep -c "^CONFIG_TARGET_${{ env.TARGET }}=y$" .config)
          SUBTARGET_CHECK=$(grep -c "^CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y$" .config)
          ARCH_CHECK=$(grep -c "^CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\"$" .config)
          # 修复PREFIX_CHECK - 匹配带引号和破折号的值
          PREFIX_CHECK=$(grep -c "^CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}-\"$" .config)
          
          echo "  - CONFIG_TARGET_${{ env.TARGET }}=y: $TARGET_CHECK"
          echo "  - CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y: $SUBTARGET_CHECK"
          echo "  - CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\": $ARCH_CHECK"
          echo "  - CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}-\": $PREFIX_CHECK"
          
          # 显示实际找到的配置行
          echo ""
          echo "🚨 实际配置行:"
          grep "^CONFIG_TARGET_PREFIX=" .config
          
          if [ $TARGET_CHECK -eq 0 ]; then
            echo "❌ 错误: CONFIG_TARGET_${{ env.TARGET }}=y 未找到"
            exit 1
          fi
          
          if [ $SUBTARGET_CHECK -eq 0 ]; then
            echo "❌ 错误: CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y 未找到"
            exit 1
          fi
          
          if [ $ARCH_CHECK -eq 0 ]; then
            echo "❌ 错误: CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\" 未找到"
            exit 1
          fi
          
          if [ $PREFIX_CHECK -eq 0 ]; then
            echo "❌ 错误: CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}-\" 未找到"
            echo "期望的PREFIX: ${{ env.PREFIX }}-"
            echo "实际找到的行: $(grep '^CONFIG_TARGET_PREFIX=' .config || echo '未找到')"
            exit 1
          fi
          
          echo "✅ 配置验证通过"

      - name: 🔧 修复网络和终端环境
        run: |
          echo "=== 修复网络和终端环境 ==="
          cd "${{ env.BUILD_DIR }}"
          
          echo "🚨 设置Git配置..."
          git config --global http.postBuffer 524288000
          git config --global http.lowSpeedLimit 0
          git config --global http.lowSpeedTime 999999
          git config --global core.compression 0
          git config --global core.looseCompression 0
          
          echo "🚨 设置构建环境变量..."
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=dumb
          export DEBIAN_FRONTEND=noninteractive
          export GIT_SSL_NO_VERIFY=1
          export PYTHONHTTPSVERIFY=0
          export CURL_SSL_NO_VERIFY=1
          
          echo "🚨 创建必要的目录..."
          mkdir -p include/site
          mkdir -p tmp
          mkdir -p dl
          
          echo "🚨 设置语言环境..."
          export LANG=en_US.UTF-8
          export LC_ALL=en_US.UTF-8
          export LANGUAGE=en_US:en
          
          echo "✅ 网络和终端环境修复完成"

      - name: 🛠️ 应用配置（简化版）
        run: |
          echo "=== 应用配置（简化版）==="
          cd "${{ env.BUILD_DIR }}"
          
          echo "🚨 当前目录: $(pwd)"
          
          # 备份原始配置文件
          if [ -f ".config" ]; then
            cp .config .config.original
            echo "✅ 已备份原始配置文件"
          fi
          
          echo "🚨 运行 make defconfig..."
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=dumb
          export DEBIAN_FRONTEND=noninteractive
          
          make defconfig V=s 2>&1 | tee /tmp/defconfig.log
          DEFCONFIG_EXIT=$?
          
          echo "🚨 defconfig 退出代码: $DEFCONFIG_EXIT"
          
          # 即使defconfig失败也继续，因为我们有手动配置
          if [ -f ".config" ]; then
            CONFIG_LINES=$(wc -l < .config)
            echo "最终配置文件行数: $CONFIG_LINES"
            
            echo "🚨 关键配置检查:"
            echo "=== .config 关键内容 ==="
            grep -E "CONFIG_TARGET|CONFIG_ARCH|CONFIG_CPU|CONFIG_LIBC|CONFIG_GCC" .config | head -20
            
            echo ""
            echo "🚨 目标平台配置验证:"
            TARGET_CHECK=$(grep -c "CONFIG_TARGET_${{ env.TARGET }}=y" .config || true)
            SUBTARGET_CHECK=$(grep -c "CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y" .config || true)
            ARCH_CHECK=$(grep -c "CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\"" .config || true)
            PREFIX_CHECK=$(grep -c "CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}\"" .config || true)
            
            echo "  - CONFIG_TARGET_${{ env.TARGET }}=y: $TARGET_CHECK $(if [ $TARGET_CHECK -gt 0 ]; then echo "✅"; else echo "❌"; fi)"
            echo "  - CONFIG_TARGET_${{ env.TARGET }}_${{ env.SUBTARGET }}=y: $SUBTARGET_CHECK $(if [ $SUBTARGET_CHECK -gt 0 ]; then echo "✅"; else echo "❌"; fi)"
            echo "  - CONFIG_TARGET_ARCH=\"${{ env.ARCH_NAME }}\": $ARCH_CHECK $(if [ $ARCH_CHECK -gt 0 ]; then echo "✅"; else echo "❌"; fi)"
            echo "  - CONFIG_TARGET_PREFIX=\"${{ env.PREFIX }}\": $PREFIX_CHECK $(if [ $PREFIX_CHECK -gt 0 ]; then echo "✅"; else echo "❌"; fi)"
            
            # 如果配置不正确，只是警告，不退出
            if [ $TARGET_CHECK -eq 0 ] || [ $SUBTARGET_CHECK -eq 0 ]; then
              echo "⚠️ 警告: 关键配置可能缺失，但继续构建..."
            else
              echo "✅ 配置验证通过"
            fi
          else
            echo "⚠️ 警告: 配置文件未生成，但继续构建..."
          fi
          
          echo "✅ 配置应用完成"

      - name: 🔨 编译工具链（增加调试信息）
        timeout-minutes: 150
        run: |
          echo "=== 开始编译工具链 ==="
          cd "${{ env.BUILD_DIR }}"
          
          echo "🚨 设置构建环境..."
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=dumb
          export DEBIAN_FRONTEND=noninteractive
          
          echo "🚨 系统信息:"
          echo "- CPU核心: $(nproc)"
          echo "- 内存: $(free -h | grep Mem | awk '{print $2}')"
          echo "- 磁盘空间:"
          df -h /
          
          echo "🚨 当前目录内容:"
          ls -la
          
          echo "🚨 配置文件状态:"
          if [ -f ".config" ]; then
            echo "配置文件存在，大小: $(wc -l < .config) 行"
            echo "关键配置:"
            grep -E "TARGET|ARCH|CPU|LIBC|GCC" .config | head -20
          else
            echo "❌ 配置文件不存在"
            exit 1
          fi
          
          echo "🚨 第一步: 下载所有源码包..."
          echo "创建下载目录..."
          mkdir -p dl
          
          # 先下载所有依赖
          echo "开始下载源码包..."
          make -j1 download V=s 2>&1 | tee /tmp/download.log | tail -100
          DOWNLOAD_STATUS=${PIPESTATUS[0]}
          
          if [ $DOWNLOAD_STATUS -eq 0 ]; then
            echo "✅ 源码包下载成功"
          else
            echo "⚠️ 源码包下载有警告，检查日志..."
            grep -E "Error|error|failed" /tmp/download.log | tail -20
            echo "继续构建..."
          fi
          
          echo "🚨 下载目录内容:"
          ls -la dl/ | head -20
          echo "下载文件数量: $(ls -1 dl/ 2>/dev/null | wc -l)"
          
          echo "🚨 第二步: 编译工具链..."
          CPU_CORES=$(nproc)
          MAKE_JOBS=$CPU_CORES
          
          # 如果内存小于4GB，减少并行任务
          TOTAL_MEM=$(free -m | awk '/^Mem:/{print $2}')
          if [ $TOTAL_MEM -lt 4096 ]; then
            MAKE_JOBS=$((CPU_CORES / 2))
            if [ $MAKE_JOBS -lt 1 ]; then
              MAKE_JOBS=1
            fi
            echo "⚠️ 内存较低(${TOTAL_MEM}MB)，减少并行任务到 $MAKE_JOBS"
          fi
          
          echo "🚨 使用 $MAKE_JOBS 个并行任务进行编译..."
          echo "🚨 开始编译工具链..."
          
          # 编译工具链，增加详细输出
          echo "=== 编译日志开始 ==="
          make toolchain/compile -j$MAKE_JOBS V=s 2>&1 | tee /tmp/compile.log
          COMPILE_STATUS=${PIPESTATUS[0]}
          echo "=== 编译日志结束 ==="
          
          if [ $COMPILE_STATUS -eq 0 ]; then
            echo "✅ 工具链编译成功"
          else
            echo "❌ 工具链编译失败"
            echo "🚨 错误摘要:"
            grep -E "Error:|error:|failed:|configure: error|recipe for target" /tmp/compile.log | tail -50
            echo ""
            echo "🚨 最后100行详细错误日志:"
            tail -100 /tmp/compile.log
            echo ""
            echo "🚨 关键目录检查:"
            echo "staging_dir 是否存在: $(ls -d staging_dir/toolchain-* 2>/dev/null | head -1 || echo '不存在')"
            echo "build_dir 是否存在: $(ls -d build_dir/target-* 2>/dev/null | head -1 || echo '不存在')"
            exit 1
          fi
          
          echo "🚨 第三步: 安装工具链..."
          make toolchain/install -j$MAKE_JOBS V=s 2>&1 | tee /tmp/install.log
          INSTALL_STATUS=${PIPESTATUS[0]}
          
          if [ $INSTALL_STATUS -eq 0 ]; then
            echo "✅ 工具链安装成功"
          else
            echo "⚠️ 安装有警告"
            grep -E "Warning:|warning:" /tmp/install.log | tail -20
          fi
          
          echo "✅ 工具链构建完成"
          echo "构建时间: $(date)"

      - name: ✅ 验证构建结果
        run: |
          echo "=== 验证构建结果 ==="
          cd "${{ env.BUILD_DIR }}"
          
          echo "🚨 查找工具链目录..."
          TOOLCHAIN_DIR=$(find staging_dir -name "toolchain-*" -type d 2>/dev/null | head -1)
          if [ -z "$TOOLCHAIN_DIR" ]; then
            echo "❌ 未找到工具链目录"
            echo "staging_dir内容:"
            ls -la staging_dir/ 2>/dev/null || echo "staging_dir目录不存在"
            echo "可能的目录:"
            find . -type d -name "*toolchain*" 2>/dev/null | head -10
            exit 1
          fi
          
          echo "✅ 工具链目录: $TOOLCHAIN_DIR"
          echo "工具链目录内容:"
          ls -la "$TOOLCHAIN_DIR/"
          
          # 查找编译器
          echo "🚨 查找编译器..."
          COMPILER_PATH=$(find "$TOOLCHAIN_DIR/bin" -name "*gcc" -type f 2>/dev/null | head -1)
          if [ -z "$COMPILER_PATH" ]; then
            echo "❌ 未找到编译器"
            echo "bin目录内容:"
            ls -la "$TOOLCHAIN_DIR/bin/" 2>/dev/null || echo "bin目录不存在"
            echo "所有可执行文件:"
            find "$TOOLCHAIN_DIR" -type f -executable 2>/dev/null | head -20
            exit 1
          fi
          
          echo "✅ 编译器: $(basename "$COMPILER_PATH")"
          echo "🚨 编译器信息:"
          "$COMPILER_PATH" --version 2>&1 | head -5
          
          echo "🚨 目标三元组:"
          "$COMPILER_PATH" -dumpmachine 2>&1
          
          echo "🚨 交叉编译测试..."
          echo '#include <stdio.h>' > test.c
          echo 'int main() { printf("OpenWrt交叉编译器测试OK\\n"); return 0; }' >> test.c
          
          echo "编译测试程序..."
          "$COMPILER_PATH" test.c -o test_program 2>&1
          if [ $? -eq 0 ] && [ -f "test_program" ]; then
            echo "✅ 编译测试通过"
            echo "文件类型:"
            file test_program
            echo "程序输出:"
            ./test_program 2>&1 || echo "无法在当前架构运行（正常）"
            rm -f test.c test_program
          else
            echo "❌ 编译测试失败"
            echo "编译错误:"
            "$COMPILER_PATH" test.c -o test_program 2>&1
            exit 1
          fi
          
          COMPILER_NAME=$(basename "$COMPILER_PATH")
          TOOL_PREFIX=$(echo "$COMPILER_NAME" | sed 's/gcc$//')
          
          echo "TOOLCHAIN_DIR=$TOOLCHAIN_DIR" >> $GITHUB_ENV
          echo "COMPILER_PATH=$COMPILER_PATH" >> $GITHUB_ENV
          echo "TOOL_PREFIX=$TOOL_PREFIX" >> $GITHUB_ENV
          
          echo "✅ 验证完成"

      - name: 💾 保存编译器
        run: |
          echo "=== 保存编译器 ==="
          cd "${{ env.BUILD_DIR }}"
          
          echo "🚨 准备输出目录: ${{ env.OUTPUT_DIR }}"
          mkdir -p "${{ env.OUTPUT_DIR }}"
          
          if [ -d "${{ env.OUTPUT_DIR }}" ] && [ "$(ls -A "${{ env.OUTPUT_DIR }}" 2>/dev/null)" ]; then
            echo "清理输出目录..."
            rm -rf "${{ env.OUTPUT_DIR }}"/*
            echo "✅ 清理输出目录完成"
          fi
          
          echo "🚨 复制工具链..."
          if [ ! -d "$TOOLCHAIN_DIR" ]; then
            echo "❌ 工具链目录不存在: $TOOLCHAIN_DIR"
            exit 1
          fi
          
          echo "源目录大小: $(du -sh "$TOOLCHAIN_DIR" | cut -f1)"
          echo "源文件数量: $(find "$TOOLCHAIN_DIR" -type f | wc -l)"
          
          echo "开始复制..."
          rsync -av "$TOOLCHAIN_DIR"/ "${{ env.OUTPUT_DIR }}/" 2>&1 | tail -20
          
          if [ -d "${{ env.OUTPUT_DIR }}/bin" ]; then
            echo "✅ 工具链复制成功"
            file_count=$(find "${{ env.OUTPUT_DIR }}" -type f 2>/dev/null | wc -l)
            dir_count=$(find "${{ env.OUTPUT_DIR }}" -type d 2>/dev/null | wc -l)
            echo "📊 复制统计:"
            echo "  - 文件数: $file_count"
            echo "  - 目录数: $dir_count"
          else
            echo "❌ 工具链复制失败，bin目录不存在"
            ls -la "${{ env.OUTPUT_DIR }}/"
            exit 1
          fi
          
          echo "🚨 创建元数据..."
          echo '{' > "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "architecture": "'${{ env.ARCH_DIR }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "libc": "'${{ env.LIBC_DIR }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "target": "'${{ env.TARGET }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "subtarget": "'${{ env.SUBTARGET }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "compiler_prefix": "'${{ env.PREFIX }}'-",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "gcc_version": "'${{ env.GCC_VERSION }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "binutils_version": "'${{ env.BINUTILS_VERSION }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "linux_version": "'${{ env.LINUX_VERSION }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "openwrt_version": "'${{ env.OPENWRT_VERSION }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "build_date": "'$(date -Iseconds)'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "workflow_run": "'${{ github.run_id }}'",' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '  "build_id": "'${{ env.BUILD_ID }}'"' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          echo '}' >> "${{ env.OUTPUT_DIR }}/metadata.json"
          
          TOTAL_SIZE=$(du -sh "${{ env.OUTPUT_DIR }}" | cut -f1)
          FILE_COUNT=$(find "${{ env.OUTPUT_DIR }}" -type f | wc -l)
          
          echo "✅ 保存完成:"
          echo "  - 总大小: $TOTAL_SIZE"
          echo "  - 文件数: $FILE_COUNT"
          echo "  - 输出目录: ${{ env.OUTPUT_DIR }}"
          
          echo "TOTAL_SIZE=$TOTAL_SIZE" >> $GITHUB_ENV
          echo "FILE_COUNT=$FILE_COUNT" >> $GITHUB_ENV

      - name: 📤 提交到Git仓库
        run: |
          echo "=== 提交编译器到Git仓库 ==="
          cd "${{ github.workspace }}"
          
          echo "🚨 配置Git用户..."
          git config user.email "github-actions@github.com"
          git config user.name "GitHub Actions"
          
          echo "🚨 拉取最新代码..."
          git pull origin main --no-edit || echo "拉取失败，继续..."
          
          echo "🚨 添加文件..."
          git add -f "firmware-config/build-Compiler-file/compilers/*"
          
          if ! git diff --cached --quiet; then
            echo "🚨 提交变更..."
            git commit -m "build(compiler): 添加 ${{ env.ARCH_DIR }}-${{ env.LIBC_DIR }} 交叉编译器" \
              -m "版本: GCC ${{ env.GCC_VERSION }}" \
              -m "大小: ${{ env.TOTAL_SIZE }}" \
              -m "文件数: ${{ env.FILE_COUNT }}" \
              -m "工作流: #${{ github.run_id }}"
            
            echo "🚨 推送变更..."
            git push origin main
            echo "✅ 编译器已提交到仓库"
          else
            echo "ℹ️ 没有变更需要提交"
          fi

      - name: 📊 显示最终成果
        run: |
          echo "========================================"
          echo "          🎉 构建完成报告              "
          echo "========================================"
          echo "✅ 交叉编译器构建成功!"
          echo ""
          echo "📊 构建信息:"
          echo "  - 架构: ${{ env.ARCH_DIR }}"
          echo "  - C库: ${{ env.LIBC_DIR }}"
          echo "  - GCC版本: ${{ env.GCC_VERSION }}"
          echo "  - 编译器前缀: ${{ env.PREFIX }}-"
          echo "  - 目标平台: ${{ env.TARGET }}/${{ env.SUBTARGET }}"
          echo "  - CPU类型: ${{ env.CPU_TYPE }}"
          echo "  - 浮点ABI: ${{ env.FLOAT_ABI }}"
          echo ""
          echo "📦 成果统计:"
          echo "  - 总大小: ${{ env.TOTAL_SIZE }}"
          echo "  - 文件数量: ${{ env.FILE_COUNT }}"
          echo "  - 输出目录: ${{ env.OUTPUT_DIR }}"
          echo ""
          echo "🚀 使用方法:"
          echo "cd ${{ env.OUTPUT_DIR }}"
          echo "export STAGING_DIR=\$(pwd)"
          echo 'export PATH="\$STAGING_DIR/bin:\$PATH"'
          echo "${{ env.PREFIX }}-gcc --version"
          echo ""
          echo "💾 元数据位置:"
          echo "${{ env.OUTPUT_DIR }}/metadata.json"
          echo "========================================"
          echo "构建完成时间: $(date)"

      - name: 📄 上传构建日志
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ env.BUILD_ID }}
          path: /tmp/*.log
          retention-days: 30

  skip-build:
    needs: setup
    if: needs.setup.outputs.need_build == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: ⏭️ 跳过构建
        run: |
          echo "========================================"
          echo "        ⏭️ 跳过构建报告                "
          echo "========================================"
          echo "✅ 编译器已存在且完整，跳过构建"
          echo "📋 跳过原因:"
          echo "- 编译器目录已存在且完整"
          echo "- 未启用强制重新构建"
          echo "🔧 现有编译器信息:"
          echo "- 架构: ${{ github.event.inputs.target_arch }}"
          echo "- C库: ${{ github.event.inputs.libc }}"
          echo "- GCC版本: ${{ needs.setup.outputs.gcc_version }}"
          echo "💡 如需重新构建，请启用'强制重新构建'选项"
          echo "========================================"

name: OpenWrt 智能固件构建工作流

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: '设备名称 (ac42u/RT-ACRH17)'
        required: true
        default: 'ac42u'
        type: string
      old_device:
        description: '是否为老旧设备'
        required: true
        default: false
        type: boolean
      version_spec:
        description: '版本规格 (可选，如: openwrt-23.05 或 immortalwrt:master)'
        required: false
        type: string
        default: ''
      config_type:
        description: '配置类型'
        required: true
        default: 'minimal'
        type: choice
        options:
          - minimal
          - normal
          - custom
      extra_packages:
        description: '额外安装插件 (空格分隔)'
        required: false
        type: string

env:
  BUILD_DIR: /mnt/openwrt-build

jobs:
  build-firmware:
    runs-on: ubuntu-latest
    
    steps:
    - name: 初始空间检查
      run: |
        echo "=== 初始磁盘空间检查 ==="
        df -h
        AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
        AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
        echo "/mnt 可用空间: ${AVAILABLE_GB}G"
        if [ $AVAILABLE_GB -lt 50 ]; then
          echo "错误: /mnt 空间不足50G"
          exit 1
        fi

    - name: 检出配置仓库
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 设置编译环境
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libncurses5-dev libssl-dev python3 unzip zlib1g-dev subversion gcc-multilib git curl

    - name: 创建构建目录并设置权限
      run: |
        echo "=== 创建构建目录 ==="
        sudo mkdir -p $BUILD_DIR
        sudo chown -R $USER:$USER $BUILD_DIR
        sudo chmod -R 755 $BUILD_DIR
        # 添加写权限
        sudo chmod u+w $BUILD_DIR
        echo "✅ 构建目录创建完成"
        
        # 验证权限
        echo "=== 验证目录权限 ==="
        ls -ld $BUILD_DIR
        touch $BUILD_DIR/test_write.txt && echo "✅ 写入测试成功" && rm $BUILD_DIR/test_write.txt

    - name: 复制检测脚本到构建目录
      run: |
        cd $BUILD_DIR
        echo "=== 复制检测脚本到构建目录 ==="
        
        cd $GITHUB_WORKSPACE
        
        # 查找脚本文件
        VERSION_SCRIPT=$(find . -name "complete_version_detector.sh" -type f | head -1)
        DEVICE_SCRIPT=$(find . -name "device_detection.sh" -type f | head -1)
        
        if [ -z "$VERSION_SCRIPT" ] || [ -z "$DEVICE_SCRIPT" ]; then
          echo "❌ 错误: 找不到检测脚本"
          exit 1
        fi
        
        echo "✅ 找到版本检测脚本: $VERSION_SCRIPT"
        echo "✅ 找到设备检测脚本: $DEVICE_SCRIPT"
        
        # 复制到构建目录
        cp "$VERSION_SCRIPT" $BUILD_DIR/complete_version_detector.sh
        cp "$DEVICE_SCRIPT" $BUILD_DIR/device_detection.sh
        
        cd $BUILD_DIR
        chmod +x complete_version_detector.sh device_detection.sh
        echo "✅ 脚本复制完成"

    - name: 智能版本检测
      id: version-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能版本检测 ==="
        
        # 确保当前目录可写
        echo "=== 检查并修复目录权限 ==="
        sudo chown -R $USER:$USER . 2>/dev/null || true
        chmod u+w . 2>/dev/null || true
        
        # 测试写入权限
        if touch test_write.txt; then
            echo "✅ 当前目录可写"
            rm -f test_write.txt
        else
            echo "❌ 当前目录不可写，尝试修复权限"
            sudo chown -R $USER:$USER .
            chmod u+w .
            # 再次测试
            if touch test_write.txt; then
                echo "✅ 权限修复成功"
                rm -f test_write.txt
            else
                echo "❌ 权限修复失败，使用备用方案"
                # 使用临时目录
                TEMP_DIR=$(mktemp -d)
                cd $TEMP_DIR
                cp $BUILD_DIR/complete_version_detector.sh .
                chmod +x complete_version_detector.sh
            fi
        fi
        
        echo "=== 开始版本检测 ==="
        # 即使脚本返回非零退出码，我们也尝试继续，因为检测可能已经成功
        set +e
        ./complete_version_detector.sh "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_spec }}" "${{ github.event.inputs.old_device }}"
        SCRIPT_EXIT_CODE=$?
        set -e
        
        echo "脚本退出代码: $SCRIPT_EXIT_CODE"
        
        # 查找版本信息文件（可能在多个位置）
        VERSION_INFO_FILE=""
        for location in "." "/tmp" "/home/runner" "$GITHUB_WORKSPACE"; do
            if [ -f "$location/version_info.txt" ]; then
                VERSION_INFO_FILE="$location/version_info.txt"
                echo "✅ 找到版本信息文件: $VERSION_INFO_FILE"
                # 复制到当前目录
                cp "$VERSION_INFO_FILE" ./version_info.txt 2>/dev/null && echo "✅ 已复制到当前目录" || echo "⚠️ 无法复制到当前目录"
                break
            fi
        done
        
        if [ -f "version_info.txt" ]; then
            echo "✅ 版本信息文件可用"
            echo "=== version_info.txt 内容 ==="
            cat version_info.txt
            
            SELECTED_REPO=$(grep '^SELECTED_REPO=' version_info.txt | cut -d'=' -f2)
            SELECTED_BRANCH=$(grep '^SELECTED_BRANCH=' version_info.txt | cut -d'=' -f2)
            SELECTED_REPO_URL=$(grep '^SELECTED_REPO_URL=' version_info.txt | cut -d'=' -f2)
            
            echo "SELECTED_REPO=$SELECTED_REPO" >> $GITHUB_ENV
            echo "SELECTED_BRANCH=$SELECTED_BRANCH" >> $GITHUB_ENV
            echo "SELECTED_REPO_URL=$SELECTED_REPO_URL" >> $GITHUB_ENV
            
            echo "✅ 环境变量已设置:"
            echo "SELECTED_REPO: $SELECTED_REPO"
            echo "SELECTED_BRANCH: $SELECTED_BRANCH"
            echo "SELECTED_REPO_URL: $SELECTED_REPO_URL"
            
            # 即使脚本退出码非零，只要我们有版本信息就继续
            if [ $SCRIPT_EXIT_CODE -eq 0 ]; then
                echo "✅ 版本检测脚本执行成功"
            else
                echo "⚠️ 版本检测脚本报告错误，但已成功获取版本信息，继续执行"
            fi
        else
            echo "❌ 未找到版本信息文件"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 版本检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但未生成版本信息文件，尝试从输出中提取"
                # 这里可以添加从标准输出提取版本信息的逻辑
                exit 1
            fi
        fi

    # ... 后续步骤保持不变 ...

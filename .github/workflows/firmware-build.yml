# .github/workflows/firmware-build.yml
name: OpenWrt 智能固件构建工作流

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: "📱 设备名称 (如: ac42u)"
        required: true
        default: "ac42u"
        type: string
      version_selection:
        description: "🔄 版本选择"
        required: true
        type: choice
        default: "21.02"
        options: ["23.05", "21.02"]
      config_mode:
        description: "⚙️ 配置模式选择 - 🟣 基础模式 - 最小化配置，用于测试编译。🟠 正常模式 - 完整功能配置：✅ TurboACC 网络加速 ✅ UPnP 自动端口转发 ✅ Samba 文件共享 ✅ 磁盘管理 ✅ KMS 激活服务 ✅ SmartDNS 智能DNS ✅ 家长控制 ✅ 微信推送 ✅ 流量控制 (SQM) ✅ FTP 服务器 ✅ ARP 绑定 ✅ CPU 限制 ✅ 硬盘休眠"
        required: true
        type: choice
        default: "normal"
        options: ["base", "normal"]
      extra_packages:
        description: "额外安装插件 - 格式：用分号;分隔。启用插件：+插件名。禁用插件：-插件名。"
        required: false
        type: string
        default: ""
      enable_parallel:
        description: "⚡ 启用智能并行优化 (自动判断最佳任务数)"
        required: false
        type: choice
        default: "true"
        options: ["true", "false"]

env:
  BUILD_DIR: "/mnt/openwrt-build"
  REPO_ROOT: "${{ github.workspace }}"
  ENABLE_PARALLEL: "${{ github.event.inputs.enable_parallel }}"

jobs:
  build-firmware:
    runs-on: ubuntu-22.04
    
    steps:
      # 步骤 0: 生成时间戳
      - name: "0. 生成时间戳"
        run: |
          echo "=== 步骤 0: 生成时间戳 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 生成日期格式的时间戳（年月日）
          BASE_DATE=$(date -u +'%Y%m%d')
          TIMESTAMP="${{ github.event.inputs.device_name }}-${{ github.event.inputs.version_selection }}-${{ github.event.inputs.config_mode }}-$BASE_DATE"
          
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          
          echo "✅ 生成时间戳: $TIMESTAMP"
          echo "📋 构建配置:"
          echo "  设备: ${{ github.event.inputs.device_name }}"
          echo "  版本: ${{ github.event.inputs.version_selection }}"
          echo "  模式: ${{ github.event.inputs.config_mode }}"
          echo "  并行优化: ${{ github.event.inputs.enable_parallel }}"
          
          echo "🟢 步骤 0 完成"
      
      # 步骤 1: 使用Git Archive API下载源代码
      - name: "1. 使用Git Archive API下载源代码"
        run: |
          echo "=== 步骤 1: 使用Git Archive API下载源代码 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 1 失败，退出代码: $?"; exit 1' ERR
          
          # 创建临时目录
          mkdir -p /tmp/openwrt-source
          cd /tmp/openwrt-source
          
          # 获取默认分支
          echo "🔍 获取仓库默认分支..."
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}" | jq -r '.default_branch')
          echo "✅ 默认分支: $DEFAULT_BRANCH"
          
          # 使用Git Archive API下载压缩包
          echo "📥 下载源代码压缩包..."
          curl -s -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/tarball/$DEFAULT_BRANCH" -o source.tar.gz
          
          if [ ! -f "source.tar.gz" ]; then
            echo "❌ 错误: 下载源代码压缩包失败"
            exit 1
          fi
          
          echo "✅ 下载完成，文件大小: $(ls -lh source.tar.gz | awk '{print $5}')"
          
          # 解压压缩包
          echo "📦 解压源代码..."
          tar -xzf source.tar.gz --strip-components=1
          
          # 检查解压结果
          echo "🔍 检查解压结果..."
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "✅ 源代码解压成功"
            echo "✅ 重要文件存在: firmware-config/scripts/build_firmware_main.sh"
            
            # 复制到工作区
            echo "📁 复制文件到工作区..."
            mkdir -p ${{ github.workspace }}
            
            # 检查并删除编译器目录（如果有的话）
            if [ -d "firmware-config/build-Compiler-file" ]; then
              echo "⚠️ 发现编译器目录，排除不复制"
              rm -rf firmware-config/build-Compiler-file
            fi
            
            # 使用rsync复制所有文件，排除.git目录
            rsync -av --exclude='.git' . ${{ github.workspace }}/
            
            # 确保脚本文件有执行权限
            chmod +x ${{ github.workspace }}/firmware-config/scripts/*.sh 2>/dev/null || true
            
            echo "✅ 文件复制完成"
            
            # 保存源代码压缩包作为构建产物
            mkdir -p /tmp/build-artifacts/source-archive
            cp source.tar.gz /tmp/build-artifacts/source-archive/
            echo "📦 源代码已保存到: /tmp/build-artifacts/source-archive/"
          else
            echo "❌ 错误: 源代码解压失败，重要文件缺失"
            echo "📁 当前目录内容:"
            ls -la
            exit 1
          fi
          
          # 清理临时文件
          cd /tmp
          rm -rf openwrt-source
          echo "✅ Git Archive API下载完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 1 完成"
      
      # 步骤 2: 上传源代码Artifacts
      - name: "2. 上传源代码Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: source-${{ env.TIMESTAMP }}
          path: /tmp/build-artifacts/source-archive/
          retention-days: 7
          if-no-files-found: error
      
      # 步骤 3: 修复权限问题
      - name: "3. 修复权限问题"
        run: |
          echo "=== 步骤 3: 修复权限问题 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 3 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔧 修复所有脚本的执行权限..."
          
          if [ -f "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" ]; then
            chmod +x "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh"
            echo "✅ 修复主脚本权限: firmware-config/scripts/build_firmware_main.sh"
          else
            echo "❌ 错误: 主脚本不存在: firmware-config/scripts/build_firmware_main.sh"
            exit 1
          fi
          
          if [ -f "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh" ]; then
            chmod +x "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh"
            echo "✅ 修复错误分析脚本权限: firmware-config/scripts/error_analysis.sh"
          fi
          
          # 修复其他脚本权限
          find "${{ github.workspace }}/firmware-config/scripts" -name "*.sh" -exec chmod +x {} \;
          echo "✅ 修复所有脚本权限完成"
          echo "🟢 步骤 3 完成"
      
      # 步骤 4: 安装基础工具（优化版）
      - name: "4. 安装基础工具（优化版）"
        run: |
          echo "=== 步骤 4: 安装基础工具（优化版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 4 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔄 更新软件包列表..."
          sudo apt-get update -q
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: apt-get update 失败"
            exit 1
          fi
          
          echo "📦 安装编译必需工具 (分组安装，提高效率)..."
          
          # 分组1: 核心编译工具
          echo "🔧 安装核心编译工具..."
          sudo apt-get install -y -q \
            build-essential \
            clang \
            flex \
            bison \
            g++ \
            gawk \
            gcc-multilib \
            g++-multilib \
            gettext \
            git \
            libncurses5-dev \
            libssl-dev \
            python3-distutils \
            rsync \
            unzip \
            zlib1g-dev \
            file \
            wget \
            libelf-dev \
            cmake \
            ninja-build
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 核心编译工具安装失败"
            exit 1
          fi
          
          # 分组2: Python和脚本工具
          echo "🐍 安装Python和脚本工具..."
          sudo apt-get install -y -q \
            python3 \
            python3-dev \
            python3-pip \
            python3-setuptools \
            python3-yaml \
            xsltproc \
            zip \
            subversion \
            automake \
            autoconf \
            libtool \
            pkg-config \
            help2man \
            texinfo \
            groff \
            texlive \
            texinfo
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: Python和脚本工具安装失败"
            exit 1
          fi
          
          # 分组3: 网络和下载工具
          echo "🌐 安装网络和下载工具..."
          sudo apt-get install -y -q \
            curl \
            net-tools \
            iputils-ping \
            dnsutils \
            openssh-client \
            ca-certificates \
            gnupg \
            lsb-release \
            aria2 \
            libcurl4-openssl-dev
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 网络和下载工具安装失败"
            exit 1
          fi
          
          # 分组4: 文件系统工具
          echo "💿 安装文件系统工具..."
          sudo apt-get install -y -q \
            squashfs-tools \
            dosfstools \
            e2fsprogs \
            mtools \
            parted \
            fdisk \
            gdisk \
            hdparm \
            smartmontools
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 文件系统工具安装失败"
            exit 1
          fi
          
          # 分组5: 调试和开发工具
          echo "🔍 安装调试和开发工具..."
          sudo apt-get install -y -q \
            gdb \
            strace \
            ltrace \
            valgrind \
            binutils-dev \
            libdw-dev \
            libiberty-dev \
            ecj \
            fastjar \
            java-propose-classpath \
            libpython3-dev \
            liblz4-dev \
            zstd
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 调试和开发工具安装失败"
            exit 1
          fi
          
          echo "✅ 基础工具安装完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 验证重要工具
          echo "🔍 验证重要工具安装..."
          echo "📋 检查以下重要工具是否安装成功:"
          
          # 定义要检查的工具数组
          tools_to_check=("gcc" "g++" "make" "git" "python3" "cmake" "flex" "bison")
          missing_tools=()
          
          # 检查每个工具
          for tool in "${tools_to_check[@]}"; do
            if command -v $tool >/dev/null 2>&1; then
              echo "✅ $tool 已安装: $(which $tool)"
            else
              echo "❌ $tool 未安装"
              missing_tools+=("$tool")
            fi
          done
          
          if [ ${#missing_tools[@]} -gt 0 ]; then
            echo "❌ 错误: 以下重要工具缺失: ${missing_tools[*]}"
            exit 1
          fi
          
          echo "🔍 额外检查:"
          # 检查gcc版本
          if command -v gcc >/dev/null 2>&1; then
            GCC_VERSION=$(gcc --version | head -1)
            echo "🔧 系统GCC版本: $GCC_VERSION"
            echo "💡 系统GCC用于编译工具链，SDK GCC用于交叉编译固件"
          fi
          
          # 检查make版本
          if command -v make >/dev/null 2>&1; then
            MAKE_VERSION=$(make --version | head -1)
            echo "🔨 Make版本: $MAKE_VERSION"
          fi
          
          echo "✅ 工具验证完成"
          echo "🟢 步骤 4 完成"
      
      # 步骤 5: 初始空间检查
      - name: "5. 初始空间检查"
        run: |
          echo "=== 步骤 5: 初始磁盘空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 5 失败，退出代码: $?"; exit 1' ERR
          
          echo "📊 /mnt 分区详细信息:"
          df -h /mnt
          
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "/mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 50 ]; then
            echo "❌ 错误: /mnt 空间不足50G，当前只有${AVAILABLE_GB}G"
            exit 1
          else
            echo "✅ 初始空间检查通过 - ${AVAILABLE_GB}G 可用"
          fi
          
          echo "🟢 步骤 5 完成"
      
      # 步骤 6: 设置编译环境和构建目录
      - name: "6. 设置编译环境和构建目录"
        run: |
          echo "=== 步骤 6: 设置编译环境和构建目录 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 6 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔄 步骤 6.1: 设置编译环境"
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" setup_environment
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 设置编译环境失败"
            exit 1
          fi
          
          echo "🔄 步骤 6.2: 创建构建目录"
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" create_build_dir
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 创建构建目录失败"
            exit 1
          fi
          
          echo "🔄 步骤 6.3: 初始化构建环境"
          echo "📱 设备: ${{ github.event.inputs.device_name }}"
          echo "🔄 版本: ${{ github.event.inputs.version_selection }}"
          echo "⚙️ 配置模式: ${{ github.event.inputs.config_mode }}"
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" initialize_build_env "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_selection }}" "${{ github.event.inputs.config_mode }}"
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 初始化构建环境失败"
            exit 1
          fi
          
          echo "✅ 编译环境和构建目录设置完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 6 完成"
      
      # 步骤 7: 下载OpenWrt官方SDK（修复版）
      - name: "7. 下载OpenWrt官方SDK（修复版）"
        run: |
          echo "=== 步骤 7: 下载OpenWrt官方SDK（修复版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 7 失败，退出代码: $?"; exit 1' ERR
          
          echo "🚀 开始下载OpenWrt官方SDK工具链..."
          
          # 先检查环境文件是否已经存在
          echo "🔍 检查环境文件..."
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            echo "✅ 环境文件已存在（由步骤6.3创建）"
            echo "📊 环境文件内容摘要:"
            head -15 /mnt/openwrt-build/build_env.sh
            
            # 加载现有环境变量
            source /mnt/openwrt-build/build_env.sh
            echo "✅ 从现有环境文件加载变量:"
            echo "  SELECTED_BRANCH: $SELECTED_BRANCH"
            echo "  TARGET: $TARGET"
            echo "  SUBTARGET: $SUBTARGET"
            echo "  DEVICE: $DEVICE"
            echo "  CONFIG_MODE: $CONFIG_MODE"
            echo "  REPO_ROOT: $REPO_ROOT"
            echo "  COMPILER_DIR: $COMPILER_DIR"
            echo ""
            
            echo "💡 使用步骤6.3已设置的环境变量进行SDK下载"
          else
            echo "⚠️ 环境文件不存在，可能是步骤6.3失败"
            echo "📝 重新创建环境变量..."
            
            # 根据设备设置基础环境变量
            DEVICE_NAME="${{ github.event.inputs.device_name }}"
            case "$DEVICE_NAME" in
              "ac42u"|"acrh17")
                TARGET="ipq40xx"
                SUBTARGET="generic"
                DEVICE="asus_rt-ac42u"
                ;;
              "mi_router_4a_gigabit"|"r4ag")
                TARGET="ramips"
                SUBTARGET="mt76x8"
                DEVICE="xiaomi_mi-router-4a-gigabit"
                ;;
              "mi_router_3g"|"r3g")
                TARGET="ramips"
                SUBTARGET="mt7621"
                DEVICE="xiaomi_mi-router-3g"
                ;;
              *)
                TARGET="ipq40xx"
                SUBTARGET="generic"
                DEVICE="$DEVICE_NAME"
                ;;
            esac
            
            # 创建环境文件
            echo "#!/bin/bash" > /mnt/openwrt-build/build_env.sh
            echo "export SELECTED_REPO_URL=\"https://github.com/immortalwrt/immortalwrt.git\"" >> /mnt/openwrt-build/build_env.sh
            echo "export SELECTED_BRANCH=\"${{ github.event.inputs.version_selection == '23.05' && 'openwrt-23.05' || 'openwrt-21.02' }}\"" >> /mnt/openwrt-build/build_env.sh
            echo "export TARGET=\"$TARGET\"" >> /mnt/openwrt-build/build_env.sh
            echo "export SUBTARGET=\"$SUBTARGET\"" >> /mnt/openwrt-build/build_env.sh
            echo "export DEVICE=\"$DEVICE\"" >> /mnt/openwrt-build/build_env.sh
            echo "export CONFIG_MODE=\"${{ github.event.inputs.config_mode }}\"" >> /mnt/openwrt-build/build_env.sh
            echo "export REPO_ROOT=\"${{ github.workspace }}\"" >> /mnt/openwrt-build/build_env.sh
            echo "export COMPILER_DIR=\"\"" >> /mnt/openwrt-build/build_env.sh
            chmod +x /mnt/openwrt-build/build_env.sh
            echo "✅ 已创建环境文件"
          fi
          
          # 执行SDK下载
          echo "🔄 开始执行SDK下载..."
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" initialize_compiler_env "${{ github.event.inputs.device_name }}"
          
          SDK_EXIT_CODE=$?
          if [ $SDK_EXIT_CODE -ne 0 ]; then
            echo "⚠️ 警告: SDK下载可能有问题，退出代码: $SDK_EXIT_CODE"
            echo "💡 将使用OpenWrt自动构建的编译器作为后备"
          fi
          
          echo "✅ SDK下载步骤完成，时间: $(date '+%Y-%m%d %H:%M:%S')"
          echo "🟢 步骤 7 完成"
      
      # 步骤 8: 验证SDK下载结果
      - name: "8. 验证SDK下载结果"
        run: |
          echo "=== 步骤 8: 验证SDK下载结果 ==="
          echo "🕐 验证时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是验证
          trap 'echo "⚠️ 步骤 8 验证过程中出现错误，继续执行..."' ERR
          
          echo "🔍 检查SDK下载结果..."
          
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            source /mnt/openwrt-build/build_env.sh
            echo "✅ 从环境文件加载变量: COMPILER_DIR=$COMPILER_DIR"
          else
            echo "⚠️ 环境文件不存在"
          fi
          
          if [ -d "/mnt/openwrt-build/sdk" ]; then
            echo "✅ SDK目录存在: /mnt/openwrt-build/sdk"
            echo "📊 SDK目录大小: $(du -sh /mnt/openwrt-build/sdk 2>/dev/null | cut -f1 || echo '未知')"
            
            # 查找真正的GCC，排除虚假编译器
            GCC_FILE=$(find "/mnt/openwrt-build/sdk" -type f -executable \
              -name "*gcc" \
              ! -name "*gcc-ar" \
              ! -name "*gcc-ranlib" \
              ! -name "*gcc-nm" \
              ! -path "*dummy-tools*" \
              ! -path "*scripts*" \
              2>/dev/null | head -1)
            
            if [ -n "$GCC_FILE" ] && [ -x "$GCC_FILE" ]; then
              echo "✅ 找到可执行GCC编译器: $(basename "$GCC_FILE")"
              echo "🔧 GCC版本测试:"
              "$GCC_FILE" --version 2>&1 | head -1
              
              # 动态显示SDK GCC版本信息
              SDK_VERSION=$("$GCC_FILE" --version 2>&1 | head -1)
              MAJOR_VERSION=$(echo "$SDK_VERSION" | grep -o "[0-9]\+" | head -1)
              
              echo "💡 这是OpenWrt官方SDK交叉编译器，用于编译目标平台固件"
              
              if [ "$MAJOR_VERSION" = "12" ]; then
                echo "💡 SDK GCC版本: 12.3.0 (OpenWrt 23.05 SDK)"
              elif [ "$MAJOR_VERSION" = "8" ]; then
                echo "💡 SDK GCC版本: 8.4.0 (OpenWrt 21.02 SDK)"
              else
                echo "💡 SDK GCC版本: $MAJOR_VERSION.x"
              fi
              
              echo "💡 系统GCC (11.4.0) 用于编译工具链，SDK GCC ($MAJOR_VERSION.x) 用于交叉编译固件"
            else
              echo "⚠️ 未找到可执行的GCC编译器（可能是虚假的dummy-tools）"
              
              # 检查是否有虚假的编译器
              DUMMY_GCC=$(find "/mnt/openwrt-build/sdk" -type f -executable \
                -name "*gcc" \
                -path "*dummy-tools*" \
                2>/dev/null | head -1)
              
              if [ -n "$DUMMY_GCC" ]; then
                echo "⚠️ 检测到虚假的dummy-tools编译器: $DUMMY_GCC"
                echo "💡 这是OpenWrt构建系统的占位符，不是真正的编译器"
              fi
            fi
          else
            echo "❌ SDK目录不存在"
            echo "💡 将使用OpenWrt自动构建的编译器"
          fi
          
          echo "✅ SDK验证完成"
          echo "🟢 步骤 8 完成"
      
      # 步骤 9: 添加 TurboACC 支持
      - name: "9. 添加 TurboACC 支持"
        run: |
          echo "=== 步骤 9: 添加 TurboACC 支持 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 9 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" add_turboacc_support
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 添加TurboACC支持失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 9 完成"
      
      # 步骤 10: 配置Feeds
      - name: "10. 配置Feeds"
        run: |
          echo "=== 步骤 10: 配置Feeds ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 10 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" configure_feeds
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 配置Feeds失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 10 完成"
      
      # 步骤 11: 安装 TurboACC 包
      - name: "11. 安装 TurboACC 包"
        if: env.SELECTED_BRANCH == 'openwrt-23.05' && github.event.inputs.config_mode == 'normal'
        run: |
          echo "=== 步骤 11: 安装 TurboACC 包 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 11 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" install_turboacc_packages
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 安装TurboACC包失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 11 完成"
      
      # 步骤 12: 编译前空间检查
      - name: "12. 编译前空间检查"
        run: |
          echo "=== 步骤 12: 编译前空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 12 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" pre_build_space_check
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 编译前空间检查失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 12 完成"
      
      # 步骤 13: 智能配置生成
      - name: "13. 智能配置生成"
        run: |
          echo "=== 步骤 13: 智能配置生成 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 13 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" generate_config "${{ github.event.inputs.extra_packages }}"
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 智能配置生成失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 13 完成"
      
      # 步骤 14: 验证USB配置
      - name: "14. 验证USB配置"
        run: |
          echo "=== 步骤 14: 验证USB配置 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是验证
          trap 'echo "⚠️ 步骤 14 验证过程中出现错误，继续执行..."' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" verify_usb_config
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 14 完成"
      
      # 步骤 15: USB驱动完整性检查
      - name: "15. USB驱动完整性检查"
        run: |
          echo "=== 步骤 15: USB驱动完整性检查 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是检查
          trap 'echo "⚠️ 步骤 15 检查过程中出现错误，继续执行..."' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" check_usb_drivers_integrity
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 15 完成"
      
      # 步骤 16: 应用配置并显示详情（完整版）
      - name: "16. 应用配置并显示详情（完整版）"
        run: |
          echo "=== 步骤 16: 应用配置并显示详情（完整版）==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 16 失败，退出代码: $?"; exit 1' ERR
          
          if [ -f "/mnt/openwrt-build/.config" ]; then
            cp "/mnt/openwrt-build/.config" "/mnt/openwrt-build/.config.original"
            echo "✅ 已备份原始配置文件"
          fi
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" apply_config
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 应用配置失败"
            exit 1
          fi
          
          echo "=== 🚨 最终配置状态检查（完整详细版）==="
          if [ -f "/mnt/openwrt-build/.config" ]; then
            echo "✅ 配置文件存在"
            echo "📊 文件大小: $(ls -lh "/mnt/openwrt-build/.config" | awk '{print $5}')"
            echo "📝 文件行数: $(wc -l < "/mnt/openwrt-build/.config")"
            
            echo ""
            echo "🔧 关键配置检查:"
            echo "1. ✅ 目标平台配置:"
            grep "CONFIG_TARGET_" "/mnt/openwrt-build/.config" | head -5
            
            echo ""
            echo "2. ✅ USB 3.0驱动配置:"
            grep "CONFIG_PACKAGE_kmod-usb-xhci" "/mnt/openwrt-build/.config"
            
            echo ""
            echo "3. ✅ 关键USB驱动状态:"
            grep -E "CONFIG_PACKAGE_kmod-usb-core|CONFIG_PACKAGE_kmod-usb2|CONFIG_PACKAGE_kmod-usb3|CONFIG_PACKAGE_kmod-usb-storage" "/mnt/openwrt-build/.config"
            
            echo ""
            echo "4. ✅ 插件配置统计:"
            enabled=$(grep -c "CONFIG_PACKAGE_.*=y" "/mnt/openwrt-build/.config")
            disabled=$(grep -c "# CONFIG_PACKAGE_.* is not set" "/mnt/openwrt-build/.config")
            echo "   ✅ 已启用插件: $enabled 个"
            echo "   ❌ 已禁用插件: $disabled 个"
            
            echo ""
            echo "=== 🎯 详细配置状态标识（完整版）==="
            echo "📋 USB配置状态:"
            
            # USB配置检查
            echo "  CONFIG_PACKAGE_kmod-usb-core: $(grep -q "^CONFIG_PACKAGE_kmod-usb-core=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  CONFIG_PACKAGE_kmod-usb2: $(grep -q "^CONFIG_PACKAGE_kmod-usb2=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  CONFIG_PACKAGE_kmod-usb3: $(grep -q "^CONFIG_PACKAGE_kmod-usb3=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  CONFIG_PACKAGE_kmod-usb-xhci-hcd: $(grep -q "^CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  CONFIG_PACKAGE_kmod-usb-storage: $(grep -q "^CONFIG_PACKAGE_kmod-usb-storage=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  CONFIG_PACKAGE_kmod-scsi-core: $(grep -q "^CONFIG_PACKAGE_kmod-scsi-core=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            
            echo ""
            echo "📦 功能性插件状态:"
            
            # 功能性插件状态
            echo "  TurboACC 网络加速 (luci-app-turboacc): $(grep -q "^CONFIG_PACKAGE_luci-app-turboacc=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  UPnP 自动端口转发 (luci-app-upnp): $(grep -q "^CONFIG_PACKAGE_luci-app-upnp=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  Samba 文件共享 (luci-app-samba4): $(grep -q "^CONFIG_PACKAGE_luci-app-samba4=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  磁盘管理 (luci-app-diskman): $(grep -q "^CONFIG_PACKAGE_luci-app-diskman=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  KMS 激活服务 (luci-app-vlmcsd): $(grep -q "^CONFIG_PACKAGE_luci-app-vlmcsd=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  SmartDNS 智能DNS (luci-app-smartdns): $(grep -q "^CONFIG_PACKAGE_luci-app-smartdns=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  家长控制 (luci-app-accesscontrol): $(grep -q "^CONFIG_PACKAGE_luci-app-accesscontrol=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  微信推送 (luci-app-wechatpush): $(grep -q "^CONFIG_PACKAGE_luci-app-wechatpush=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  流量控制 (SQM) (luci-app-sqm): $(grep -q "^CONFIG_PACKAGE_luci-app-sqm=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  FTP 服务器 (luci-app-vsftpd): $(grep -q "^CONFIG_PACKAGE_luci-app-vsftpd=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  ARP 绑定 (luci-app-arpbind): $(grep -q "^CONFIG_PACKAGE_luci-app-arpbind=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  CPU 限制 (luci-app-cpulimit): $(grep -q "^CONFIG_PACKAGE_luci-app-cpulimit=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            echo "  硬盘休眠 (luci-app-hd-idle): $(grep -q "^CONFIG_PACKAGE_luci-app-hd-idle=y" "/mnt/openwrt-build/.config" && echo "✅" || echo "❌")"
            
            echo ""
            echo "🎯 配置模式: ${{ github.event.inputs.config_mode }}"
            if [ "${{ github.event.inputs.config_mode }}" = "normal" ]; then
              echo "✅ 当前为正常模式（完整功能）"
              echo "📊 正常模式包含所有功能性插件"
            else
              echo "🔧 当前为基础模式（最小化配置）"
              echo "📊 基础模式仅包含核心功能，用于测试编译"
            fi
            
            echo ""
            echo "🔍 配置摘要:"
            echo "  - 目标平台: $TARGET/$SUBTARGET"
            echo "  - 目标设备: $DEVICE"
            echo "  - OpenWrt版本: $SELECTED_BRANCH"
            echo "  - USB驱动: 已启用所有关键驱动"
            echo "  - 插件数量: $enabled 个已启用"
            
            # 显示前10个启用的插件
            echo ""
            echo "📋 启用的插件 (前10个):"
            grep "^CONFIG_PACKAGE_.*=y" "/mnt/openwrt-build/.config" | head -10 | sed 's/CONFIG_PACKAGE_//g' | sed 's/=y//g' | while read pkg; do
              echo "  ✅ $pkg"
            done
          else
            echo "❌ 配置文件不存在"
          fi
          
          echo ""
          echo "✅ 配置应用完成"
          echo "🟢 步骤 16 完成"
      
      # 步骤 17: 检查并备份配置文件
      - name: "17. 检查并备份配置文件"
        run: |
          echo "=== 步骤 17: 检查并备份配置文件 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 17 失败，退出代码: $?"; exit 1' ERR
          
          # 检查配置文件
          if [ -f "/mnt/openwrt-build/.config" ]; then
            echo "✅ .config 文件存在"
            echo "📊 文件大小: $(ls -lh "/mnt/openwrt-build/.config" | awk '{print $5}')"
            echo "📝 文件行数: $(wc -l < "/mnt/openwrt-build/.config")"
            
            # 确保备份目录存在
            mkdir -p "${{ github.workspace }}/firmware-config/config-backup"
            
            # 备份到仓库目录
            BACKUP_FILE="${{ github.workspace }}/firmware-config/config-backup/config_${{ env.TIMESTAMP }}.config"
            
            cp "/mnt/openwrt-build/.config" "$BACKUP_FILE"
            echo "✅ 配置文件备份到仓库目录: $BACKUP_FILE"
            echo "📊 备份文件大小: $(ls -lh "$BACKUP_FILE" | awk '{print $5}')"
          else
            echo "❌ 错误: .config 文件不存在"
            exit 1
          fi
          
          echo "🟢 步骤 17 完成"
      
      # 步骤 18: 修复网络环境
      - name: "18. 修复网络环境"
        run: |
          echo "=== 步骤 18: 修复网络环境 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是尝试修复
          trap 'echo "⚠️ 步骤 18 修复过程中出现错误，继续执行..."' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" fix_network
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 18 完成"
      
      # 步骤 19: 下载依赖包（优化版）
      - name: "19. 下载依赖包（优化版）"
        run: |
          echo "=== 步骤 19: 下载依赖包（优化版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 19 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          echo "🔧 检查依赖包目录..."
          if [ ! -d "dl" ]; then
            mkdir -p dl
            echo "✅ 创建依赖包目录: dl"
          fi
          
          DEP_COUNT=$(find dl -type f 2>/dev/null | wc -l)
          echo "📊 当前依赖包数量: $DEP_COUNT 个"
          
          echo "🚀 开始下载依赖包（启用并行下载）..."
          # 使用并行下载加速，设置输出缓冲区更大防止stdout错误
          stdbuf -oL -eL make -j4 download V=s 2>&1 | tee download.log
          
          DOWNLOAD_EXIT_CODE=${PIPESTATUS[0]}
          if [ $DOWNLOAD_EXIT_CODE -ne 0 ]; then
            echo "⚠️ 警告: 依赖包下载过程中出现错误，退出代码: $DOWNLOAD_EXIT_CODE"
            echo "💡 查看下载日志中的错误信息:"
            grep -i "error\|failed\|404\|not found" download.log | head -10 || true
          fi
          
          echo "✅ 下载完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 检查下载结果
          NEW_DEP_COUNT=$(find dl -type f 2>/dev/null | wc -l)
          echo "📊 下载后依赖包数量: $NEW_DEP_COUNT 个"
          echo "📈 新增依赖包: $((NEW_DEP_COUNT - DEP_COUNT)) 个"
          
          echo "🟢 步骤 19 完成"
      
      # 步骤 20: 集成自定义文件（增强版）- 递归查找、详细日志、保持原文件名
      - name: "20. 集成自定义文件（增强版）"
        run: |
          echo "=== 步骤 20: 集成自定义文件（增强版）- 递归查找、详细日志、保持原文件名 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是尝试集成
          trap 'echo "⚠️ 步骤 20 集成过程中出现错误，继续执行..."' ERR
          
          echo "🔍 检查自定义文件目录..."
          CUSTOM_DIR="${{ github.workspace }}/firmware-config/custom-files"
          
          if [ -d "$CUSTOM_DIR" ]; then
            echo "✅ 自定义文件目录存在: $CUSTOM_DIR"
            
            # 递归查找所有文件
            echo "📁 递归查找所有自定义文件..."
            
            # 定义英文文件名检查函数
            is_english_name() {
              local filename="$1"
              if [[ "$filename" =~ ^[a-zA-Z0-9_\-\.]+$ ]]; then
                return 0  # 英文文件名
              else
                return 1  # 非英文文件名
              fi
            }
            
            # 递归查找所有文件
            ALL_FILES=$(find "$CUSTOM_DIR" -type f 2>/dev/null | sort)
            FILE_COUNT=$(echo "$ALL_FILES" | wc -l)
            
            if [ $FILE_COUNT -eq 0 ]; then
              echo "ℹ️ 目录为空"
            else
              echo "📊 找到 $FILE_COUNT 个自定义文件"
              
              # 分类统计
              IPK_COUNT=0
              SCRIPT_COUNT=0
              CONFIG_COUNT=0
              OTHER_COUNT=0
              ENGLISH_COUNT=0
              NON_ENGLISH_COUNT=0
              
              # 详细显示所有文件
              echo ""
              echo "📋 详细文件列表:"
              echo "================================================"
              
              while IFS= read -r file; do
                [ -z "$file" ] && continue
                
                REL_PATH="${file#$CUSTOM_DIR/}"
                FILE_NAME=$(basename "$file")
                FILE_SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                
                # 检查是否为英文文件名
                if is_english_name "$FILE_NAME"; then
                  NAME_STATUS="✅ 英文"
                  ENGLISH_COUNT=$((ENGLISH_COUNT + 1))
                else
                  NAME_STATUS="⚠️ 非英文"
                  NON_ENGLISH_COUNT=$((NON_ENGLISH_COUNT + 1))
                fi
                
                # 文件类型统计
                if [[ "$FILE_NAME" =~ \.ipk$ ]] || [[ "$FILE_NAME" =~ \.IPK$ ]] || [[ "$FILE_NAME" =~ \.Ipk$ ]]; then
                  TYPE_DESC="📦 IPK包"
                  IPK_COUNT=$((IPK_COUNT + 1))
                elif [[ "$FILE_NAME" =~ \.sh$ ]] || [[ "$FILE_NAME" =~ \.Sh$ ]] || [[ "$FILE_NAME" =~ \.SH$ ]]; then
                  TYPE_DESC="📜 脚本"
                  SCRIPT_COUNT=$((SCRIPT_COUNT + 1))
                elif [[ "$FILE_NAME" =~ \.conf$ ]] || [[ "$FILE_NAME" =~ \.config$ ]] || [[ "$FILE_NAME" =~ \.CONF$ ]]; then
                  TYPE_DESC="⚙️ 配置"
                  CONFIG_COUNT=$((CONFIG_COUNT + 1))
                else
                  TYPE_DESC="📁 其他"
                  OTHER_COUNT=$((OTHER_COUNT + 1))
                fi
                
                printf "%-45s %-8s %-12s %s\n" "$REL_PATH" "$FILE_SIZE" "$TYPE_DESC" "$NAME_STATUS"
                
              done <<< "$ALL_FILES"
              
              echo "================================================"
              
              # 统计信息
              echo ""
              echo "📊 文件统计:"
              echo "  文件总数: $FILE_COUNT 个"
              echo "  📦 IPK文件: $IPK_COUNT 个"
              echo "  📜 脚本文件: $SCRIPT_COUNT 个"
              echo "  ⚙️ 配置文件: $CONFIG_COUNT 个"
              echo "  📁 其他文件: $OTHER_COUNT 个"
              echo "  ✅ 英文文件名: $ENGLISH_COUNT 个"
              echo "  ⚠️ 非英文文件名: $NON_ENGLISH_COUNT 个"
              
              # 文件名建议
              if [ $NON_ENGLISH_COUNT -gt 0 ]; then
                echo ""
                echo "💡 文件名兼容性建议:"
                echo "  为了更好的兼容性，建议使用英文文件名"
                echo "  常见的文件名转换建议:"
                echo "  中文名          -> 英文名"
                echo "  '备份.sh'      -> 'backup.sh'"
                echo "  '安装脚本.sh'  -> 'install.sh'"
                echo "  '配置文件.conf' -> 'config.conf'"
                echo "  '固件文件.bin'  -> 'firmware.bin'"
                echo ""
                echo "⚠️ 注意: 当前系统会自动处理非英文文件名，但英文名有更好的兼容性"
                echo "💡 系统提供了文件名检查脚本: /etc/custom-files/check_filenames.sh"
              fi
              
              echo ""
              echo "🚀 开始执行自定义文件集成（增强版）..."
              "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" integrate_custom_files
              
              # 验证集成结果
              echo ""
              echo "🔍 验证集成结果..."
              cd /mnt/openwrt-build
              
              # 检查自定义文件目录
              if [ -d "files/etc/custom-files" ]; then
                echo "✅ 自定义文件已复制到: files/etc/custom-files"
                
                # 统计复制后的文件
                FINAL_FILES=$(find "files/etc/custom-files" -type f 2>/dev/null | wc -l)
                echo "📊 复制后文件总数: $FINAL_FILES 个"
                
                # 显示目录结构
                if [ $FINAL_FILES -gt 0 ]; then
                  echo "📁 复制后的目录结构:"
                  find "files/etc/custom-files" -type f 2>/dev/null | while read file; do
                    REL_PATH="${file#files/etc/custom-files/}"
                    FILE_SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                    echo "  📄 $REL_PATH ($FILE_SIZE)"
                  done
                fi
                
                # 检查启动脚本
                if [ -f "files/etc/uci-defaults/99-custom-files" ]; then
                  echo "✅ 第一次开机启动脚本: files/etc/uci-defaults/99-custom-files"
                  echo "📝 脚本增强功能:"
                  echo "  - ✅ 递归查找所有自定义文件"
                  echo "  - ✅ 保持原文件名"
                  echo "  - ✅ IPK安装错误不退出，继续下一个"
                  echo "  - ✅ 详细日志记录每个文件的处理结果"
                  echo "  - ✅ 分类统计和成功率计算"
                fi
                
                # 检查文件名检查脚本
                if [ -f "files/etc/custom-files/check_filenames.sh" ]; then
                  echo "✅ 文件名检查脚本: files/etc/custom-files/check_filenames.sh"
                fi
                
                echo ""
                echo "🎯 增强版功能说明:"
                echo "  🔧 递归查找: 支持自定义目录下的所有子目录"
                echo "  📝 保持原文件名: 不自动重命名，保持用户设置的文件名"
                echo "  🔄 错误不退出: IPK安装失败继续安装下一个"
                echo "  📊 详细日志: 记录每个文件的处理结果和统计信息"
                echo "  💡 文件名建议: 建议使用英文文件名以获得更好的兼容性"
                
                if [ $NON_ENGLISH_COUNT -gt 0 ]; then
                  echo ""
                  echo "⚠️ 文件名兼容性提醒:"
                  echo "  当前有 $NON_ENGLISH_COUNT 个文件使用非英文文件名"
                  echo "  系统会自动处理，但建议改为英文文件名"
                  echo "  可以在固件启动后运行: /etc/custom-files/check_filenames.sh"
                fi
                
              else
                echo "❌ 未找到自定义文件目录"
              fi
              
            fi
            
            echo ""
            echo "🎉 自定义文件集成完成"
            echo "💡 自定义文件将在第一次开机时自动安装和运行"
            echo "📌 安装顺序: IPK包 → 脚本文件 → 其他文件"
            echo "🔧 错误处理: 单个文件安装失败不会影响其他文件"
            
          else
            echo "ℹ️ 自定义文件目录不存在: $CUSTOM_DIR"
            echo "📁 跳过自定义文件集成"
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 20 完成"
      
      # 步骤 21: 前置错误检查（修复23.05 SDK验证）- 关键修复
      - name: "21. 前置错误检查（修复23.05 SDK验证）"
        run: |
          echo "=== 步骤 21: 前置错误检查（修复23.05 SDK验证） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 21 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔍 检查当前环境..."
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            source /mnt/openwrt-build/build_env.sh
            echo "✅ 加载环境变量: SELECTED_BRANCH=$SELECTED_BRANCH, TARGET=$TARGET"
          fi
          
          echo "🚀 执行前置错误检查（已修复23.05 SDK验证问题）..."
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" pre_build_error_check
          
          CHECK_EXIT_CODE=$?
          if [ $CHECK_EXIT_CODE -ne 0 ]; then
            echo "❌ 错误: 前置错误检查失败，退出代码: $CHECK_EXIT_CODE"
            echo "💡 请查看上方错误信息进行修复"
            
            # 如果是23.05版本，提供特殊提示
            if [ "$SELECTED_BRANCH" = "openwrt-23.05" ]; then
              echo ""
              echo "🚨 23.05版本SDK验证问题修复提示:"
              echo "💡 23.05 SDK使用GCC 12.3.0，已放宽验证条件"
              echo "📌 只需要有GCC编译器文件即可，不要求特定目录结构"
              echo "🔧 已排除虚假的dummy-tools编译器检测"
            fi
            
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 21 完成"
      
      # 步骤 22: 编译固件前的空间检查
      - name: "22. 编译固件前的空间检查"
        run: |
          echo "=== 步骤 22: 编译固件前的空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 22 失败，退出代码: $?"; exit 1' ERR
          
          df -h /mnt
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "/mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 10 ]; then
            echo "❌ 错误: 编译前空间不足 (需要至少10G，当前${AVAILABLE_GB}G)"
            exit 1
          elif [ $AVAILABLE_GB -lt 20 ]; then
            echo "⚠️ 警告: 编译前空间较低 (建议至少20G，当前${AVAILABLE_GB}G)"
          else
            echo "✅ 编译前空间充足"
          fi
          
          echo "🟢 步骤 22 完成"
      
      # 步骤 23: 编译固件（智能并行优化版）
      - name: "23. 编译固件（智能并行优化版）"
        run: |
          echo "=== 步骤 23: 编译固件（智能并行优化版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 23 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          # 获取系统信息
          CPU_CORES=$(nproc)
          TOTAL_MEM=$(free -m | awk '/^Mem:/{print $2}')
          
          echo "🔧 系统信息:"
          echo "  CPU核心数: $CPU_CORES"
          echo "  内存大小: ${TOTAL_MEM}MB"
          echo "  并行优化: ${{ env.ENABLE_PARALLEL }}"
          
          # 智能判断最佳并行任务数 - 优化版
          if [ "${{ env.ENABLE_PARALLEL }}" = "true" ]; then
            echo "🧠 智能判断最佳并行任务数..."
            
            # GitHub Actions Runner 优化配置
            if [ $CPU_CORES -ge 4 ]; then
              if [ $TOTAL_MEM -ge 8000 ]; then
                MAKE_JOBS=4
                echo "✅ 检测到高性能Runner (4核+8GB)"
              else
                MAKE_JOBS=3
                echo "✅ 检测到标准Runner (4核)"
              fi
            elif [ $CPU_CORES -ge 2 ]; then
              if [ $TOTAL_MEM -ge 7000 ]; then
                MAKE_JOBS=3
                echo "✅ 检测到GitHub标准Runner (2核7GB)"
              else
                MAKE_JOBS=2
                echo "✅ 检测到2核Runner"
              fi
            else
              MAKE_JOBS=2
              echo "⚠️ 检测到单核Runner"
            fi
            
            echo "🎯 决定使用 $MAKE_JOBS 个并行任务"
          else
            MAKE_JOBS=1
            echo "🔄 禁用并行优化，使用单线程编译"
          fi
          
          echo ""
          echo "🚀 开始编译固件"
          echo "💡 编译配置:"
          echo "  - 并行任务: $MAKE_JOBS"
          echo "  - 设备: ${{ github.event.inputs.device_name }}"
          echo "  - 版本: ${{ github.event.inputs.version_selection }}"
          echo "  - 配置模式: ${{ github.event.inputs.config_mode }}"
          echo "  - 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置编译环境变量
          export FORCE_UNSAFE_CONFIGURE=1
          
          # 开始编译，使用stdbuf防止stdout错误
          START_TIME=$(date +%s)
          stdbuf -oL -eL time make -j$MAKE_JOBS V=s 2>&1 | tee build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          
          echo ""
          echo "📊 编译统计:"
          echo "  - 总耗时: $((DURATION / 60))分钟$((DURATION % 60))秒"
          echo "  - 退出代码: $BUILD_EXIT_CODE"
          
          if [ $BUILD_EXIT_CODE -eq 0 ]; then
            echo "✅ 固件编译成功"
            
            if [ -d "bin/targets" ]; then
              FIRMWARE_COUNT=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
              echo "✅ 生成固件文件: $FIRMWARE_COUNT 个"
              
              # 显示前3个固件文件
              echo "📁 生成的固件文件 (前3个):"
              find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | head -3 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "  📄 $(basename "$file") ($SIZE)"
              done
            fi
          else
            echo "❌ 错误: 编译失败，退出代码: $BUILD_EXIT_CODE"
            echo "🔍 编译日志中的错误摘要:"
            grep -i "error\|failed" build.log | tail -20 || true
            exit $BUILD_EXIT_CODE
          fi
          
          echo "🟢 步骤 23 完成"
      
      # 步骤 24: 检查构建产物（修复版）
      - name: "24. 检查构建产物（修复版）"
        if: success()
        run: |
          echo "=== 步骤 24: 检查构建产物（修复版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 24 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          if [ -d "bin/targets" ]; then
            echo "✅ 找到固件目录"
            
            # 统计各种类型文件
            FIRMWARE_COUNT=0
            PACKAGE_COUNT=0
            OTHER_COUNT=0
            
            # 计算文件数量
            echo "📊 正在统计文件..."
            
            # 统计固件文件（.bin和.img）
            FIRMWARE_COUNT=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            # 统计包文件（.gz和.ipk）
            PACKAGE_COUNT=$(find bin/targets -type f \( -name "*.gz" -o -name "*.ipk" \) 2>/dev/null | wc -l)
            
            # 统计其他文件（排除上面两种类型）
            OTHER_COUNT=$(find bin/targets -type f 2>/dev/null | wc -l)
            OTHER_COUNT=$((OTHER_COUNT - FIRMWARE_COUNT - PACKAGE_COUNT))
            
            echo "=========================================="
            echo "📈 构建产物统计:"
            echo "  固件文件: $FIRMWARE_COUNT 个 (.bin/.img)"
            echo "  包文件: $PACKAGE_COUNT 个 (.gz/.ipk)"
            echo "  其他文件: $OTHER_COUNT 个"
            echo "  总文件数: $((FIRMWARE_COUNT + PACKAGE_COUNT + OTHER_COUNT)) 个"
            echo ""
            
            # 显示所有固件文件的详细信息
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "📁 固件文件详细信息:"
              echo "------------------------------------------"
              find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                FULL_SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
                FILE_NAME=$(basename "$file")
                FILE_PATH=$(echo "$file" | sed "s|/mnt/openwrt-build/||")
                
                echo "🎯 文件: $FILE_NAME"
                echo "  大小: $SIZE ($FULL_SIZE 字节)"
                echo "  路径: $FILE_PATH"
                
                # 判断文件类型
                if [[ "$FILE_NAME" == *factory* ]]; then
                  echo "  类型: 🏭 工厂固件 (用于首次刷机)"
                elif [[ "$FILE_NAME" == *sysupgrade* ]]; then
                  echo "  类型: 🔄 系统升级固件 (用于已安装OpenWrt的设备)"
                elif [[ "$FILE_NAME" == *initramfs* ]]; then
                  echo "  类型: 🚀 内存启动固件 (用于测试和救援)"
                else
                  echo "  类型: 🔧 普通固件"
                fi
                
                echo ""
              done
            else
              echo "⚠️ 警告: 未找到任何固件文件 (.bin/.img)"
              echo "🔍 目录内容 (前10个文件):"
              find bin/targets -type f 2>/dev/null | head -10 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "  📄 $(basename "$file") ($SIZE)"
              done
            fi
            
            # 计算总大小
            echo "📏 大小统计:"
            TOTAL_SIZE=0
            find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
              SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
              TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
            done
            
            if [ $TOTAL_SIZE -gt 0 ]; then
              TOTAL_SIZE_MB=$((TOTAL_SIZE / 1024 / 1024))
              echo "  固件总大小: ${TOTAL_SIZE_MB}MB"
              
              if [ $TOTAL_SIZE_MB -lt 5 ]; then
                echo "  ⚠️ 警告: 固件文件可能太小"
              elif [ $TOTAL_SIZE_MB -gt 100 ]; then
                echo "  ⚠️ 警告: 固件文件可能太大"
              else
                echo "  ✅ 固件大小正常"
              fi
            fi
            
            echo "=========================================="
            echo "✅ 构建产物检查完成"
          else
            echo "❌ 错误: 未找到固件目录"
            echo "⚠️ bin/targets目录不存在"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 24 完成"
      
      # 步骤 25: 上传固件原始目录
      - name: "25. 上传固件原始目录"
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ env.TIMESTAMP }}
          path: /mnt/openwrt-build/bin/targets/
          retention-days: 7
          if-no-files-found: error
      
      # 步骤 26: 上传配置文件
      - name: "26. 上传配置文件"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: config-${{ env.TIMESTAMP }}
          path: ${{ github.workspace }}/firmware-config/config-backup/
          retention-days: 7
          if-no-files-found: error
      
      # 步骤 27: 编译后空间检查
      - name: "27. 编译后空间检查"
        if: always()
        run: |
          echo "=== 步骤 27: 编译后空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是检查
          trap 'echo "⚠️ 步骤 27 检查过程中出现错误，继续执行..."' ERR
          
          echo "📊 磁盘使用情况:"
          df -h /mnt
          
          AVAILABLE_SPACE=$(df /mnt --output=avill | tail -1)
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "/mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 5 ]; then
            echo "⚠️ 警告: 磁盘空间较低，建议清理"
          else
            echo "✅ 磁盘空间充足"
          fi
          
          echo "🟢 步骤 27 完成"
      
      # 步骤 28: 编译后总结（增强版）
      - name: "28. 编译后总结（增强版）"
        if: always()
        run: |
          echo "=== 步骤 28: 编译后总结（增强版） ==="
          echo "🕐 总结时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，总结不应该失败
          trap 'echo "⚠️ 步骤 28 总结过程中出现错误，继续执行..."' ERR
          
          echo "🚀 构建总结报告"
          echo "========================================"
          echo "设备: ${{ github.event.inputs.device_name }}"
          echo "版本: ${{ github.event.inputs.version_selection }}"
          echo "配置模式: ${{ github.event.inputs.config_mode }}"
          echo "时间戳: ${{ env.TIMESTAMP }}"
          echo "并行优化: ${{ github.event.inputs.enable_parallel }}"
          echo ""
          
          # 检查构建产物
          if [ -d "/mnt/openwrt-build/bin/targets" ]; then
            # 修复：正确统计固件文件
            FIRMWARE_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            echo "📦 构建产物:"
            echo "  固件数量: $FIRMWARE_COUNT 个 (.bin/.img)"
            
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "  产物位置: /mnt/openwrt-build/bin/targets/"
              echo "  下载名称: firmware-${{ env.TIMESTAMP }}"
              
              # 显示所有固件文件信息
              echo "  固件文件详情:"
              find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                FILE_NAME=$(basename "$file")
                
                if [[ "$FILE_NAME" == *factory* ]]; then
                  TYPE="🏭 工厂固件"
                elif [[ "$FILE_NAME" == *sysupgrade* ]]; then
                  TYPE="🔄 升级固件"
                elif [[ "$FILE_NAME" == *initramfs* ]]; then
                  TYPE="🚀 内存固件"
                else
                  TYPE="🔧 普通固件"
                fi
                
                echo "    🎯 $FILE_NAME ($SIZE) - $TYPE"
              done
              
              # 统计包文件
              PACKAGE_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.gz" -o -name "*.ipk" \) 2>/dev/null | wc -l)
              OTHER_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f 2>/dev/null | wc -l)
              OTHER_COUNT=$((OTHER_COUNT - FIRMWARE_COUNT - PACKAGE_COUNT))
              
              echo "  包文件数量: $PACKAGE_COUNT 个 (.gz/.ipk)"
              echo "  其他文件数量: $OTHER_COUNT 个"
            else
              echo "  ⚠️ 构建结果: 编译完成但未生成固件文件"
              echo "  🔍 已生成的其他文件:"
              find "/mnt/openwrt-build/bin/targets" -type f 2>/dev/null | head -5 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "    📄 $(basename "$file") ($SIZE)"
              done
            fi
          else
            echo "📦 构建产物: 未生成任何文件"
          fi
          
          # 构建状态总结
          echo ""
          echo "📊 构建状态总结:"
          if [ -d "/mnt/openwrt-build/bin/targets" ]; then
            FIRMWARE_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "  ✅ 构建结果: 成功生成 $FIRMWARE_COUNT 个固件文件"
            else
              echo "  ⚠️ 构建结果: 编译完成但未生成固件文件"
            fi
          else
            echo "  ❌ 构建结果: 失败"
          fi
          
          # 编译器信息
          echo ""
          echo "🔧 编译器信息:"
          
          # 检查SDK编译器版本
          if [ -d "/mnt/openwrt-build/sdk" ]; then
            # 查找真正的GCC，排除虚假编译器
            GCC_FILE=$(find "/mnt/openwrt-build/sdk" -type f -executable \
              -name "*gcc" \
              ! -name "*gcc-ar" \
              ! -name "*gcc-ranlib" \
              ! -name "*gcc-nm" \
              ! -path "*dummy-tools*" \
              ! -path "*scripts*" \
              2>/dev/null | head -1)
            
            if [ -n "$GCC_FILE" ] && [ -x "$GCC_FILE" ]; then
              SDK_VERSION=$("$GCC_FILE" --version 2>&1 | head -1)
              MAJOR_VERSION=$(echo "$SDK_VERSION" | grep -o "[0-9]\+" | head -1)
              
              if [ "$MAJOR_VERSION" = "12" ]; then
                echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
                echo "  🎯 SDK GCC: 12.3.0 (OpenWrt 23.05 SDK，用于交叉编译固件)"
              elif [ "$MAJOR_VERSION" = "8" ]; then
                echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
                echo "  🎯 SDK GCC: 8.4.0 (OpenWrt 21.02 SDK，用于交叉编译固件)"
              else
                echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
                echo "  🎯 SDK GCC: $MAJOR_VERSION.x (用于交叉编译固件)"
              fi
            else
              echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
              echo "  🎯 SDK GCC: 未检测到版本（可能检测到虚假的dummy-tools编译器）"
            fi
          else
            echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
            echo "  🎯 SDK GCC: 未下载SDK，使用自动构建的编译器"
          fi
          
          echo "  💡 这是正常的：系统编译器编译工具链，SDK编译器编译固件"
          
          # 自定义文件集成状态（增强版）
          echo ""
          echo "📁 自定义文件集成状态（增强版）:"
          
          if [ -d "/mnt/openwrt-build/files/etc/custom-files" ]; then
            # 递归统计文件
            CUSTOM_IPK_COUNT=0
            CUSTOM_SCRIPT_COUNT=0
            CUSTOM_CONFIG_COUNT=0
            CUSTOM_OTHER_COUNT=0
            CUSTOM_ENGLISH_COUNT=0
            CUSTOM_NON_ENGLISH_COUNT=0
            
            # 使用find递归查找
            find "/mnt/openwrt-build/files/etc/custom-files" -type f 2>/dev/null | while read file; do
              file_name=$(basename "$file")
              
              # 检查是否为英文文件名
              if [[ "$file_name" =~ ^[a-zA-Z0-9_\-\.]+$ ]]; then
                CUSTOM_ENGLISH_COUNT=$((CUSTOM_ENGLISH_COUNT + 1))
              else
                CUSTOM_NON_ENGLISH_COUNT=$((CUSTOM_NON_ENGLISH_COUNT + 1))
              fi
              
              # 文件类型统计
              if [[ "$file_name" =~ \.ipk$ ]] || [[ "$file_name" =~ \.IPK$ ]] || [[ "$file_name" =~ \.Ipk$ ]]; then
                CUSTOM_IPK_COUNT=$((CUSTOM_IPK_COUNT + 1))
              elif [[ "$file_name" =~ \.sh$ ]] || [[ "$file_name" =~ \.Sh$ ]] || [[ "$file_name" =~ \.SH$ ]]; then
                CUSTOM_SCRIPT_COUNT=$((CUSTOM_SCRIPT_COUNT + 1))
              elif [[ "$file_name" =~ \.conf$ ]] || [[ "$file_name" =~ \.config$ ]] || [[ "$file_name" =~ \.CONF$ ]]; then
                CUSTOM_CONFIG_COUNT=$((CUSTOM_CONFIG_COUNT + 1))
              else
                CUSTOM_OTHER_COUNT=$((CUSTOM_OTHER_COUNT + 1))
              fi
            done
            
            TOTAL_CUSTOM_FILES=$((CUSTOM_IPK_COUNT + CUSTOM_SCRIPT_COUNT + CUSTOM_CONFIG_COUNT + CUSTOM_OTHER_COUNT))
            
            echo "  ✅ 自定义文件总数: $TOTAL_CUSTOM_FILES 个"
            echo "  📦 IPK包: $CUSTOM_IPK_COUNT 个"
            echo "  📜 脚本: $CUSTOM_SCRIPT_COUNT 个"
            echo "  ⚙️ 配置文件: $CUSTOM_CONFIG_COUNT 个"
            echo "  📁 其他文件: $CUSTOM_OTHER_COUNT 个"
            echo "  ✅ 英文文件名: $CUSTOM_ENGLISH_COUNT 个"
            echo "  ⚠️ 非英文文件名: $CUSTOM_NON_ENGLISH_COUNT 个"
            echo "  📌 位置: /etc/custom-files/"
            
            if [ -f "/mnt/openwrt-build/files/etc/uci-defaults/99-custom-files" ]; then
              echo "  ✅ 第一次开机安装脚本: 已创建（增强版）"
              echo "  💡 安装顺序: IPK包 → 脚本文件 → 其他文件"
              echo "  🔧 错误处理: 单个文件失败不影响其他文件"
              echo "  📊 详细日志: 记录每个文件的处理结果"
            fi
            
            if [ $CUSTOM_NON_ENGLISH_COUNT -gt 0 ]; then
              echo ""
              echo "💡 文件名兼容性提示:"
              echo "  当前有 $CUSTOM_NON_ENGLISH_COUNT 个文件使用非英文文件名"
              echo "  建议改为英文文件名以获得更好的兼容性"
              echo "  可以在固件启动后运行: /etc/custom-files/check_filenames.sh"
            fi
            
            # 显示部分文件示例
            if [ $TOTAL_CUSTOM_FILES -gt 0 ]; then
              echo ""
              echo "📋 文件示例 (前5个):"
              find "/mnt/openwrt-build/files/etc/custom-files" -type f 2>/dev/null | head -5 | while read file; do
                rel_path="${file#/mnt/openwrt-build/files/etc/custom-files/}"
                size=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "    📄 $rel_path ($size)"
              done
            fi
            
            echo ""
            echo "🎯 增强功能说明:"
            echo "  🔧 递归查找: 支持自定义目录下的所有子目录"
            echo "  📝 保持原文件名: 不自动重命名，保持用户设置的文件名"
            echo "  🔄 错误不退出: IPK安装失败继续安装下一个"
            echo "  📊 详细日志: 记录每个文件的处理结果和统计信息"
            
          else
            echo "  ⚪ 自定义文件: 未集成"
          fi
          
          # 文件名兼容性建议
          echo ""
          echo "💡 文件名兼容性建议:"
          echo "  为了更好的兼容性，建议自定义文件使用英文文件名"
          echo "  常见的文件名转换建议:"
          echo "    backup.sh      (备份脚本)"
          echo "    install.sh     (安装脚本)"
          echo "    config.conf    (配置文件)"
          echo "    firmware.bin   (固件文件)"
          echo "    plugin.ipk     (插件包)"
          echo ""
          echo "⚠️ 注意: 当前系统支持非英文文件名，但英文名有更好的兼容性"
          
          echo ""
          echo "✅ 构建流程完成"
          echo "========================================"
          echo "🟢 步骤 28 完成"

# .github/workflows/firmware-build.yml
name: OpenWrt 智能固件构建工作流

# 关键：添加权限设置以便能够被网页触发
permissions:
  contents: write    # 允许写入仓库（上传Artifacts）
  actions: write     # 允许触发工作流（如果需要递归触发）
  checks: write      # 允许创建检查状态
  deployments: write # 允许创建部署状态

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: "📱 设备名称 (自动从 support.sh 同步设备列表)"
        required: true
        default: "ac42u"
        type: string
      version_selection:
        description: "🔄 版本选择"
        required: true
        type: choice
        default: "23.05"
        options: ["23.05", "21.02"]
      config_mode:
        description: "⚙️ 配置模式选择 - 🟣 基础模式 - 最小化配置，用于测试编译。🟠 正常模式 - 完整功能配置"
        required: true
        type: choice
        default: "normal"
        options: ["base", "normal", "full"]
      extra_packages:
        description: "额外安装插件 - 格式：用分号;分隔。启用插件：+插件名。禁用插件：-插件名。"
        required: false
        type: string
        default: ""
      enable_parallel:
        description: "⚡ 启用智能并行优化 (自动判断最佳任务数)"
        required: false
        type: choice
        default: "true"
        options: ["true", "false"]
      # 添加新的输入参数用于网页自动触发
      build_source:
        description: "构建来源"
        required: false
        type: string
        default: "manual"
      build_timestamp:
        description: "构建时间戳"
        required: false
        type: string
        default: ""

env:
  BUILD_DIR: "/mnt/openwrt-build"
  REPO_ROOT: "${{ github.workspace }}"
  ENABLE_PARALLEL: "${{ github.event.inputs.enable_parallel }}"
  BUILD_SOURCE: "${{ github.event.inputs.build_source }}"
  BUILD_TIMESTAMP: "${{ github.event.inputs.build_timestamp }}"

jobs:
  build-firmware:
    runs-on: ubuntu-22.04
    
    # 添加输出，供其他步骤使用
    outputs:
      build_id: ${{ steps.generate-build-id.outputs.build_id }}
      build_status: ${{ steps.final-summary.outputs.build_status }}
    
    steps:
      # 步骤 0: 生成构建ID和时间戳
      - name: "0. 生成构建ID和时间戳"
        id: generate-build-id
        run: |
          echo "=== 步骤 0: 生成构建ID和时间戳 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 如果有网页传递的时间戳，使用它
          if [ -n "${{ env.BUILD_TIMESTAMP }}" ] && [ "${{ env.BUILD_TIMESTAMP }}" != "" ]; then
            TIMESTAMP="${{ env.BUILD_TIMESTAMP }}"
            echo "✅ 使用网页传递的时间戳: $TIMESTAMP"
          else
            # 生成新的时间戳
            BASE_DATE=$(date -u +'%Y%m%d')
            TIMESTAMP="${{ github.event.inputs.device_name }}-${{ github.event.inputs.version_selection }}-${{ github.event.inputs.config_mode }}-$BASE_DATE-$(date +%H%M%S)"
          fi
          
          # 生成唯一的构建ID
          BUILD_ID="build_${TIMESTAMP}_$(openssl rand -hex 4)"
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          
          # 设置步骤输出
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
          
          echo "✅ 生成构建ID: $BUILD_ID"
          echo "📋 构建配置:"
          echo "  设备: ${{ github.event.inputs.device_name }}"
          echo "  版本: ${{ github.event.inputs.version_selection }}"
          echo "  模式: ${{ github.event.inputs.config_mode }}"
          echo "  并行优化: ${{ env.ENABLE_PARALLEL }}"
          echo "  构建来源: ${{ env.BUILD_SOURCE }}"
          
          echo "🟢 步骤 0 完成"
      
      # 步骤 1: 显示构建来源信息
      - name: "1. 显示构建来源信息"
        run: |
          echo "=== 步骤 1: 显示构建来源信息 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          echo "📱 构建信息面板"
          echo "========================================"
          echo "🎯 构建ID: ${{ env.BUILD_ID }}"
          echo "📱 设备: ${{ github.event.inputs.device_name }}"
          echo "🔄 版本: ${{ github.event.inputs.version_selection }}"
          echo "⚙️ 模式: ${{ github.event.inputs.config_mode }}"
          echo "📦 额外插件: ${{ github.event.inputs.extra_packages }}"
          echo "⚡ 并行优化: ${{ env.ENABLE_PARALLEL }}"
          
          if [ "${{ env.BUILD_SOURCE }}" = "web" ]; then
            echo "🌐 构建来源: 🎨 网页自动触发"
            echo "💡 这是通过网页界面自动触发的构建"
          else
            echo "🌐 构建来源: 👆 手动触发"
            echo "💡 这是在GitHub Actions页面手动触发的构建"
          fi
          
          echo "📅 时间戳: ${{ env.TIMESTAMP }}"
          echo "========================================"
          
          # 创建构建信息文件，用于后续步骤和网页显示
          mkdir -p /tmp/build-info
          echo "{
            \"build_id\": \"${{ env.BUILD_ID }}\",
            \"device\": \"${{ github.event.inputs.device_name }}\",
            \"version\": \"${{ github.event.inputs.version_selection }}\",
            \"mode\": \"${{ github.event.inputs.config_mode }}\",
            \"packages\": \"${{ github.event.inputs.extra_packages }}\",
            \"parallel\": \"${{ env.ENABLE_PARALLEL }}\",
            \"source\": \"${{ env.BUILD_SOURCE }}\",
            \"timestamp\": \"${{ env.TIMESTAMP }}\",
            \"start_time\": \"$(date -u +'%Y-%m-%dT%H:%M:%SZ')\",
            \"workflow_url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
            \"commit_sha\": \"${{ github.sha }}\",
            \"repository\": \"${{ github.repository }}\"
          }" > /tmp/build-info/build-info.json
          
          echo "✅ 构建信息已保存"
          echo "🟢 步骤 1 完成"
      
      # 步骤 2: 使用Git Archive API下载源代码（修复权限版）
      - name: "2. 使用Git Archive API下载源代码（修复权限版）"
        run: |
          echo "=== 步骤 2: 使用Git Archive API下载源代码（修复权限版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 2 失败，退出代码: $?"; exit 1' ERR
          
          # 创建临时目录
          mkdir -p /tmp/openwrt-source
          cd /tmp/openwrt-source
          
          # 获取默认分支
          echo "🔍 获取仓库默认分支..."
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}" | jq -r '.default_branch')
          echo "✅ 默认分支: $DEFAULT_BRANCH"
          
          # 使用Git Archive API下载压缩包
          echo "📥 下载源代码压缩包..."
          curl -s -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/tarball/$DEFAULT_BRANCH" -o source.tar.gz
          
          if [ ! -f "source.tar.gz" ]; then
            echo "❌ 错误: 下载源代码压缩包失败"
            exit 1
          fi
          
          echo "✅ 下载完成，文件大小: $(ls -lh source.tar.gz | awk '{print $5}')"
          
          # 解压压缩包
          echo "📦 解压源代码..."
          tar -xzf source.tar.gz --strip-components=1
          
          # 检查解压结果
          echo "🔍 检查解压结果..."
          
          # 必须存在的文件
          REQUIRED_FILES=("firmware-config/scripts/build_firmware_main.sh" "support.sh")
          for file in "${REQUIRED_FILES[@]}"; do
            if [ -f "$file" ]; then
              echo "✅ 关键文件存在: $file"
            else
              echo "❌ 错误: 关键文件不存在: $file"
              echo "📁 当前目录内容:"
              ls -la
              exit 1
            fi
          done
          
          echo "📁 复制文件到多个位置..."
          
          # 1. 复制到 GitHub 工作区（保持原有逻辑）
          echo "🔧 复制到 GitHub 工作区..."
          mkdir -p ${{ github.workspace }}
          cp -r ./* ${{ github.workspace }}/ 2>/dev/null || true
          echo "✅ GitHub 工作区复制完成"
          
          # 2. 关键文件复制到构建目录 - 使用备用方案
          echo "🔧 准备复制关键文件到构建目录..."
          
          # 首先尝试在 /mnt 下创建目录，如果失败则使用 /tmp
          if sudo mkdir -p /mnt/openwrt-build 2>/dev/null; then
            echo "✅ 使用 sudo 在 /mnt 创建构建目录成功"
            sudo chmod 777 /mnt/openwrt-build
            BUILD_DIR="/mnt/openwrt-build"
          else
            echo "⚠️ 无法在 /mnt 下创建目录，将使用 /tmp 目录"
            BUILD_DIR="/tmp/openwrt-build"
            mkdir -p "$BUILD_DIR"
            echo "📌 使用备用构建目录: $BUILD_DIR"
          fi
          
          # 更新环境变量
          echo "BUILD_DIR=$BUILD_DIR" >> $GITHUB_ENV
          echo "📌 最终构建目录: $BUILD_DIR"
          
          # 复制 support.sh 到构建目录
          if [ -f "support.sh" ]; then
            cp support.sh "$BUILD_DIR/"
            chmod +x "$BUILD_DIR/support.sh"
            echo "✅ support.sh 已复制到 $BUILD_DIR/"
          else
            echo "❌ 错误: support.sh 不存在"
            exit 1
          fi
          
          # 复制 build_firmware_main.sh 到构建目录
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            mkdir -p "$BUILD_DIR/firmware-config/scripts"
            cp firmware-config/scripts/build_firmware_main.sh "$BUILD_DIR/firmware-config/scripts/"
            chmod +x "$BUILD_DIR/firmware-config/scripts/build_firmware_main.sh"
            echo "✅ build_firmware_main.sh 已复制到 $BUILD_DIR/firmware-config/scripts/"
          else
            echo "❌ 错误: build_firmware_main.sh 不存在"
            exit 1
          fi
          
          # 保存源代码压缩包作为构建产物
          mkdir -p /tmp/build-artifacts/source-archive
          cp source.tar.gz /tmp/build-artifacts/source-archive/
          echo "📦 源代码已保存到: /tmp/build-artifacts/source-archive/"
          
          # 清理临时文件
          cd /tmp
          rm -rf openwrt-source
          echo "✅ Git Archive API下载完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 2 完成"
      
      # 步骤 3: 上传源代码Artifacts
      - name: "3. 上传源代码Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: source-${{ env.TIMESTAMP }}
          path: /tmp/build-artifacts/source-archive/
          retention-days: 7
          if-no-files-found: error
      
      # 步骤 4: 修复权限问题
      - name: "4. 修复权限问题"
        run: |
          echo "=== 步骤 4: 修复权限问题 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 4 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔧 修复所有脚本的执行权限..."
          
          if [ -f "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" ]; then
            chmod +x "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh"
            echo "✅ 修复主脚本权限: firmware-config/scripts/build_firmware_main.sh"
          else
            echo "❌ 错误: 主脚本不存在: firmware-config/scripts/build_firmware_main.sh"
            exit 1
          fi
          
          if [ -f "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh" ]; then
            chmod +x "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh"
            echo "✅ 修复错误分析脚本权限: firmware-config/scripts/error_analysis.sh"
          fi
          
          # 修复其他脚本权限
          find "${{ github.workspace }}/firmware-config/scripts" -name "*.sh" -exec chmod +x {} \;
          echo "✅ 修复所有脚本权限完成"
          echo "🟢 步骤 4 完成"
      
      # 步骤 5: 安装基础工具（优化版）
      - name: "5. 安装基础工具（优化版）"
        run: |
          echo "=== 步骤 5: 安装基础工具（优化版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 5 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔄 更新软件包列表..."
          sudo apt-get update -q
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: apt-get update 失败"
            exit 1
          fi
          
          echo "📦 安装编译必需工具 (分组安装，提高效率)..."
          
          # 分组1: 核心编译工具
          echo "🔧 安装核心编译工具..."
          sudo apt-get install -y -q \
            build-essential \
            clang \
            flex \
            bison \
            g++ \
            gawk \
            gcc-multilib \
            g++-multilib \
            gettext \
            git \
            libncurses5-dev \
            libssl-dev \
            python3-distutils \
            rsync \
            unzip \
            zlib1g-dev \
            file \
            wget \
            libelf-dev \
            cmake \
            ninja-build
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 核心编译工具安装失败"
            exit 1
          fi
          
          # 分组2: Python和脚本工具
          echo "🐍 安装Python和脚本工具..."
          sudo apt-get install -y -q \
            python3 \
            python3-dev \
            python3-pip \
            python3-setuptools \
            python3-yaml \
            xsltproc \
            zip \
            subversion \
            automake \
            autoconf \
            libtool \
            pkg-config \
            help2man \
            texinfo \
            groff \
            texlive \
            texinfo
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: Python和脚本工具安装失败"
            exit 1
          fi
          
          # 分组3: 网络和下载工具
          echo "🌐 安装网络和下载工具..."
          sudo apt-get install -y -q \
            curl \
            net-tools \
            iputils-ping \
            dnsutils \
            openssh-client \
            ca-certificates \
            gnupg \
            lsb-release \
            aria2 \
            libcurl4-openssl-dev
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 网络和下载工具安装失败"
            exit 1
          fi
          
          # 分组4: 文件系统工具
          echo "💿 安装文件系统工具..."
          sudo apt-get install -y -q \
            squashfs-tools \
            dosfstools \
            e2fsprogs \
            mtools \
            parted \
            fdisk \
            gdisk \
            hdparm \
            smartmontools
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 文件系统工具安装失败"
            exit 1
          fi
          
          # 分组5: 调试和开发工具
          echo "🔍 安装调试和开发工具..."
          sudo apt-get install -y -q \
            gdb \
            strace \
            ltrace \
            valgrind \
            binutils-dev \
            libdw-dev \
            libiberty-dev \
            ecj \
            fastjar \
            java-propose-classpath \
            libpython3-dev \
            liblz4-dev \
            zstd
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 调试和开发工具安装失败"
            exit 1
          fi
          
          echo "✅ 基础工具安装完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 验证重要工具
          echo "🔍 验证重要工具安装..."
          echo "📋 检查以下重要工具是否安装成功:"
          
          # 定义要检查的工具数组
          tools_to_check=("gcc" "g++" "make" "git" "python3" "cmake" "flex" "bison")
          missing_tools=()
          
          # 检查每个工具
          for tool in "${tools_to_check[@]}"; do
            if command -v $tool >/dev/null 2>&1; then
              echo "✅ $tool 已安装: $(which $tool)"
            else
              echo "❌ $tool 未安装"
              missing_tools+=("$tool")
            fi
          done
          
          if [ ${#missing_tools[@]} -gt 0 ]; then
            echo "❌ 错误: 以下重要工具缺失: ${missing_tools[*]}"
            exit 1
          fi
          
          echo "🔍 额外检查:"
          # 检查gcc版本
          if command -v gcc >/dev/null 2>&1; then
            GCC_VERSION=$(gcc --version | head -1)
            echo "🔧 系统GCC版本: $GCC_VERSION"
            echo "💡 系统GCC用于编译工具链，SDK GCC用于交叉编译固件"
          fi
          
          # 检查make版本
          if command -v make >/dev/null 2>&1; then
            MAKE_VERSION=$(make --version | head -1)
            echo "🔨 Make版本: $MAKE_VERSION"
          fi
          
          echo "✅ 工具验证完成"
          echo "🟢 步骤 5 完成"
      
      # 步骤 6: 初始空间检查
      - name: "6. 初始空间检查"
        run: |
          echo "=== 步骤 6: 初始磁盘空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 6 失败，退出代码: $?"; exit 1' ERR
          
          echo "📊 磁盘使用情况:"
          df -h
          
          # 检查构建目录所在分区的空间
          BUILD_DIR="${{ env.BUILD_DIR }}"
          echo "🔍 检查构建目录: $BUILD_DIR"
          
          # 确定构建目录所在的分区
          if [ -d "$BUILD_DIR" ]; then
            PARTITION=$(df "$BUILD_DIR" | tail -1 | awk '{print $6}')
            echo "📌 构建目录所在分区: $PARTITION"
            
            AVAILABLE_SPACE=$(df "$PARTITION" --output=avail | tail -1 | awk '{print $1}')
            AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
            echo "$PARTITION 可用空间: ${AVAILABLE_GB}G"
            
            if [ $AVAILABLE_GB -lt 50 ]; then
              echo "❌ 错误: $PARTITION 空间不足50G，当前只有${AVAILABLE_GB}G"
              exit 1
            else
              echo "✅ 初始空间检查通过 - ${AVAILABLE_GB}G 可用"
            fi
          else
            echo "⚠️ 构建目录不存在，检查根分区..."
            AVAILABLE_SPACE=$(df / --output=avail | tail -1 | awk '{print $1}')
            AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
            echo "/ 可用空间: ${AVAILABLE_GB}G"
            
            if [ $AVAILABLE_GB -lt 50 ]; then
              echo "❌ 错误: 根分区空间不足50G，当前只有${AVAILABLE_GB}G"
              exit 1
            else
              echo "✅ 初始空间检查通过 - ${AVAILABLE_GB}G 可用"
            fi
          fi
          
          echo "🟢 步骤 6 完成"
      
      # 步骤 7: 设置编译环境和构建目录（修复版）
      - name: "7. 设置编译环境和构建目录（修复版）"
        run: |
          echo "=== 步骤 7: 设置编译环境和构建目录（修复版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 7 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          echo "📌 使用构建目录: $BUILD_DIR"
          
          # 验证关键文件在构建目录中存在
          echo "🔍 验证构建目录中的文件..."
          if [ -f "$BUILD_DIR/support.sh" ]; then
            echo "✅ support.sh 存在于构建目录"
          else
            echo "❌ 错误: support.sh 不存在于构建目录"
            exit 1
          fi
          
          if [ -f "$BUILD_DIR/firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "✅ build_firmware_main.sh 存在于构建目录"
          else
            echo "❌ 错误: build_firmware_main.sh 不存在于构建目录"
            exit 1
          fi
          
          echo "🔄 步骤 7.1: 设置编译环境"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh setup_environment
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 设置编译环境失败"
            exit 1
          fi
          
          echo "🔄 步骤 7.2: 创建构建目录"
          ./firmware-config/scripts/build_firmware_main.sh create_build_dir
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 创建构建目录失败"
            exit 1
          fi
          
          echo "🔄 步骤 7.3: 初始化构建环境"
          echo "📱 设备: ${{ github.event.inputs.device_name }}"
          echo "🔄 版本: ${{ github.event.inputs.version_selection }}"
          echo "⚙️ 配置模式: ${{ github.event.inputs.config_mode }}"
          
          ./firmware-config/scripts/build_firmware_main.sh initialize_build_env "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_selection }}" "${{ github.event.inputs.config_mode }}"
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 初始化构建环境失败"
            exit 1
          fi
          
          echo "✅ 编译环境和构建目录设置完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 7 完成"
      
      # 步骤 8: 下载OpenWrt官方SDK（修复版）- 重新复制支持文件
      - name: "8. 下载OpenWrt官方SDK（修复版）- 重新复制支持文件"
        run: |
          echo "=== 步骤 8: 下载OpenWrt官方SDK（修复版）- 重新复制支持文件 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 8 失败，退出代码: $?"; exit 1' ERR
          
          echo "🚀 开始下载OpenWrt官方SDK工具链..."
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          echo "📌 使用构建目录: $BUILD_DIR"
          
          # 步骤7.3会清空构建目录，这里需要重新复制支持文件
          echo "🔧 重新复制支持文件到构建目录..."
          
          # 1. 复制 support.sh
          SOURCE_SUPPORT="${{ github.workspace }}/support.sh"
          if [ -f "$SOURCE_SUPPORT" ]; then
            cp "$SOURCE_SUPPORT" "$BUILD_DIR/support.sh"
            chmod +x "$BUILD_DIR/support.sh"
            echo "✅ support.sh 已重新复制到构建目录"
          else
            echo "❌ 错误: 源代码中找不到 support.sh"
            exit 1
          fi
          
          # 2. 复制 build_firmware_main.sh
          SOURCE_SCRIPT="${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh"
          if [ -f "$SOURCE_SCRIPT" ]; then
            mkdir -p "$BUILD_DIR/firmware-config/scripts"
            cp "$SOURCE_SCRIPT" "$BUILD_DIR/firmware-config/scripts/"
            chmod +x "$BUILD_DIR/firmware-config/scripts/build_firmware_main.sh"
            echo "✅ build_firmware_main.sh 已重新复制到构建目录"
          else
            echo "❌ 错误: 源代码中找不到 build_firmware_main.sh"
            exit 1
          fi
          
          echo "📋 验证支持文件..."
          if [ ! -f "$BUILD_DIR/support.sh" ]; then
            echo "❌ 错误: 复制后仍然找不到 support.sh"
            exit 1
          fi
          
          if [ ! -f "$BUILD_DIR/firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "❌ 错误: 复制后仍然找不到 build_firmware_main.sh"
            exit 1
          fi
          
          echo "📁 当前构建目录内容:"
          ls -la "$BUILD_DIR/" || echo "无法列出目录内容"
          
          echo "📋 加载 support.sh..."
          source "$BUILD_DIR/support.sh"
          echo "✅ support.sh 加载成功"
          
          # 检查环境文件是否已经存在
          echo "🔍 检查环境文件..."
          if [ -f "$BUILD_DIR/build_env.sh" ]; then
            echo "✅ 环境文件已存在（由步骤7.3创建）"
            
            # 加载现有环境变量
            source "$BUILD_DIR/build_env.sh"
            echo "✅ 从现有环境文件加载变量:"
            echo "  SELECTED_BRANCH: $SELECTED_BRANCH"
            echo "  TARGET: $TARGET"
            echo "  SUBTARGET: $SUBTARGET"
            echo "  DEVICE: $DEVICE"
            echo "  CONFIG_MODE: $CONFIG_MODE"
            echo "  REPO_ROOT: $REPO_ROOT"
            echo "  DEVICE_NAME: $DEVICE_NAME"
            echo ""
            
            echo "💡 使用步骤7.3已设置的环境变量进行SDK下载"
          else
            echo "❌ 错误: 环境文件不存在，可能是步骤7.3失败"
            exit 1
          fi
          
          # 执行SDK下载
          echo "🔄 开始执行SDK下载..."
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh initialize_compiler_env "${{ github.event.inputs.device_name }}"
          
          SDK_EXIT_CODE=$?
          if [ $SDK_EXIT_CODE -ne 0 ]; then
            echo "⚠️ 警告: SDK下载可能有问题，退出代码: $SDK_EXIT_CODE"
            echo "💡 将使用OpenWrt自动构建的编译器作为后备"
          fi
          
          echo "✅ SDK下载步骤完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 8 完成"
      
      # 步骤 9: 验证SDK下载结果
      - name: "9. 验证SDK下载结果"
        run: |
          echo "=== 步骤 9: 验证SDK下载结果 ==="
          echo "🕐 验证时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是验证
          trap 'echo "⚠️ 步骤 9 验证过程中出现错误，继续执行..."' ERR
          
          echo "🔍 检查SDK下载结果..."
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          
          if [ -f "$BUILD_DIR/build_env.sh" ]; then
            source "$BUILD_DIR/build_env.sh"
            echo "✅ 从环境文件加载变量: COMPILER_DIR=$COMPILER_DIR"
          else
            echo "⚠️ 环境文件不存在"
          fi
          
          if [ -d "$BUILD_DIR/sdk" ]; then
            echo "✅ SDK目录存在: $BUILD_DIR/sdk"
            echo "📊 SDK目录大小: $(du -sh "$BUILD_DIR/sdk" 2>/dev/null | cut -f1 || echo '未知')"
            
            # 查找真正的GCC，排除虚假编译器
            GCC_FILE=$(find "$BUILD_DIR/sdk" -type f -executable \
              -name "*gcc" \
              ! -name "*gcc-ar" \
              ! -name "*gcc-ranlib" \
              ! -name "*gcc-nm" \
              ! -path "*dummy-tools*" \
              ! -path "*scripts*" \
              2>/dev/null | head -1)
            
            if [ -n "$GCC_FILE" ] && [ -x "$GCC_FILE" ]; then
              echo "✅ 找到可执行GCC编译器: $(basename "$GCC_FILE")"
              echo "🔧 GCC版本测试:"
              "$GCC_FILE" --version 2>&1 | head -1
              
              # 动态显示SDK GCC版本信息
              SDK_VERSION=$("$GCC_FILE" --version 2>&1 | head -1)
              MAJOR_VERSION=$(echo "$SDK_VERSION" | grep -o "[0-9]\+" | head -1)
              
              echo "💡 这是OpenWrt官方SDK交叉编译器，用于编译目标平台固件"
              
              if [ "$MAJOR_VERSION" = "12" ]; then
                echo "💡 SDK GCC版本: 12.3.0 (OpenWrt 23.05 SDK)"
              elif [ "$MAJOR_VERSION" = "8" ]; then
                echo "💡 SDK GCC版本: 8.4.0 (OpenWrt 21.02 SDK)"
              else
                echo "💡 SDK GCC版本: $MAJOR_VERSION.x"
              fi
              
              echo "💡 系统GCC (11.4.0) 用于编译工具链，SDK GCC ($MAJOR_VERSION.x) 用于交叉编译固件"
            else
              echo "⚠️ 未找到可执行的GCC编译器（可能是虚假的dummy-tools）"
              
              # 检查是否有虚假的编译器
              DUMMY_GCC=$(find "$BUILD_DIR/sdk" -type f -executable \
                -name "*gcc" \
                -path "*dummy-tools*" \
                2>/dev/null | head -1)
              
              if [ -n "$DUMMY_GCC" ]; then
                echo "⚠️ 检测到虚假的dummy-tools编译器: $DUMMY_GCC"
                echo "💡 这是OpenWrt构建系统的占位符，不是真正的编译器"
              fi
            fi
          else
            echo "❌ SDK目录不存在"
            echo "💡 将使用OpenWrt自动构建的编译器"
          fi
          
          echo "✅ SDK验证完成"
          echo "🟢 步骤 9 完成"
      
      # 步骤 10: 添加 TurboACC 支持
      - name: "10. 添加 TurboACC 支持"
        run: |
          echo "=== 步骤 10: 添加 TurboACC 支持 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 10 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh add_turboacc_support
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 添加TurboACC支持失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 10 完成"
      
      # 步骤 11: 配置Feeds
      - name: "11. 配置Feeds"
        run: |
          echo "=== 步骤 11: 配置Feeds ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 11 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh configure_feeds
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 配置Feeds失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 11 完成"
      
      # 步骤 12: 安装 TurboACC 包
      - name: "12. 安装 TurboACC 包"
        if: env.SELECTED_BRANCH == 'openwrt-23.05' && github.event.inputs.config_mode == 'normal'
        run: |
          echo "=== 步骤 12: 安装 TurboACC 包 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 12 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh install_turboacc_packages
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 安装TurboACC包失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 12 完成"
      
      # 步骤 13: 编译前空间检查
      - name: "13. 编译前空间检查"
        run: |
          echo "=== 步骤 13: 编译前空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 13 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh pre_build_space_check
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 编译前空间检查失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 13 完成"
      
      # 步骤 14: 智能配置生成 - 重新复制支持文件
      - name: "14. 智能配置生成 - 重新复制支持文件"
        run: |
          echo "=== 步骤 14: 智能配置生成 - 重新复制支持文件 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 14 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          
          # 重新复制 support.sh 到构建目录（可能被之前的步骤覆盖）
          echo "🔧 重新复制 support.sh..."
          SOURCE_SUPPORT="${{ github.workspace }}/support.sh"
          
          if [ -f "$SOURCE_SUPPORT" ]; then
            cp "$SOURCE_SUPPORT" "$BUILD_DIR/support.sh"
            chmod +x "$BUILD_DIR/support.sh"
            echo "✅ support.sh 已重新复制到构建目录"
          else
            echo "❌ 错误: support.sh 文件不存在于源代码"
            exit 1
          fi
          
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh generate_config "${{ github.event.inputs.extra_packages }}"
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 智能配置生成失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 14 完成"
      
      # 步骤 15: 验证USB配置
      - name: "15. 验证USB配置"
        run: |
          echo "=== 步骤 15: 验证USB配置 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是验证
          trap 'echo "⚠️ 步骤 15 验证过程中出现错误，继续执行..."' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh verify_usb_config
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 15 完成"
      
      # 步骤 16: USB驱动完整性检查
      - name: "16. USB驱动完整性检查"
        run: |
          echo "=== 步骤 16: USB驱动完整性检查 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是检查
          trap 'echo "⚠️ 步骤 16 检查过程中出现错误，继续执行..."' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh check_usb_drivers_integrity
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 16 完成"
      
      # 步骤 17: 应用配置并显示详情（完整版）
      - name: "17. 应用配置并显示详情（完整版）"
        run: |
          echo "=== 步骤 17: 应用配置并显示详情（完整版）==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 17 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          
          if [ -f ".config" ]; then
            cp ".config" ".config.original"
            echo "✅ 已备份原始配置文件"
          fi
          
          ./firmware-config/scripts/build_firmware_main.sh apply_config
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 应用配置失败"
            exit 1
          fi
          
          echo "=== 🚨 最终配置状态检查（完整详细版）==="
          if [ -f ".config" ]; then
            echo "✅ 配置文件存在"
            echo "📊 文件大小: $(ls -lh ".config" | awk '{print $5}')"
            echo "📝 文件行数: $(wc -l < ".config")"
            
            echo ""
            echo "🔧 关键配置检查:"
            echo "1. ✅ 目标平台配置:"
            grep "CONFIG_TARGET_" ".config" | head -5
            
            echo ""
            echo "2. ✅ USB 3.0驱动配置:"
            grep "CONFIG_PACKAGE_kmod-usb-xhci" ".config"
            
            echo ""
            echo "3. ✅ 关键USB驱动状态:"
            grep -E "CONFIG_PACKAGE_kmod-usb-core|CONFIG_PACKAGE_kmod-usb2|CONFIG_PACKAGE_kmod-usb3|CONFIG_PACKAGE_kmod-usb-storage" ".config"
            
            echo ""
            echo "4. ✅ 插件配置统计:"
            enabled=$(grep -c "CONFIG_PACKAGE_.*=y" ".config")
            disabled=$(grep -c "# CONFIG_PACKAGE_.* is not set" ".config")
            echo "   ✅ 已启用插件: $enabled 个"
            echo "   ❌ 已禁用插件: $disabled 个"
          else
            echo "❌ 配置文件不存在"
          fi
          
          echo ""
          echo "✅ 配置应用完成"
          echo "🟢 步骤 17 完成"
      
      # 步骤 18: 检查并备份配置文件
      - name: "18. 检查并备份配置文件"
        run: |
          echo "=== 步骤 18: 检查并备份配置文件 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 18 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          
          # 检查配置文件
          if [ -f ".config" ]; then
            echo "✅ .config 文件存在"
            echo "📊 文件大小: $(ls -lh ".config" | awk '{print $5}')"
            echo "📝 文件行数: $(wc -l < ".config")"
            
            # 确保备份目录存在
            mkdir -p "${{ github.workspace }}/firmware-config/config-backup"
            
            # 备份到仓库目录
            BACKUP_FILE="${{ github.workspace }}/firmware-config/config-backup/config_${{ env.TIMESTAMP }}.config"
            
            cp ".config" "$BACKUP_FILE"
            echo "✅ 配置文件备份到仓库目录: $BACKUP_FILE"
            echo "📊 备份文件大小: $(ls -lh "$BACKUP_FILE" | awk '{print $5}')"
          else
            echo "❌ 错误: .config 文件不存在"
            exit 1
          fi
          
          echo "🟢 步骤 18 完成"
      
      # 步骤 19: 修复网络环境
      - name: "19. 修复网络环境"
        run: |
          echo "=== 步骤 19: 修复网络环境 ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是尝试修复
          trap 'echo "⚠️ 步骤 19 修复过程中出现错误，继续执行..."' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh fix_network
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 19 完成"
      
      # 步骤 20: 下载依赖包（优化版）
      - name: "20. 下载依赖包（优化版）"
        run: |
          echo "=== 步骤 20: 下载依赖包（优化版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 20 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          
          echo "🔧 检查依赖包目录..."
          if [ ! -d "dl" ]; then
            mkdir -p dl
            echo "✅ 创建依赖包目录: dl"
          fi
          
          DEP_COUNT=$(find dl -type f 2>/dev/null | wc -l)
          echo "📊 当前依赖包数量: $DEP_COUNT 个"
          
          echo "🚀 开始下载依赖包（启用并行下载）..."
          # 使用并行下载加速，设置输出缓冲区更大防止stdout错误
          stdbuf -oL -eL make -j4 download V=s 2>&1 | tee download.log
          
          DOWNLOAD_EXIT_CODE=${PIPESTATUS[0]}
          if [ $DOWNLOAD_EXIT_CODE -ne 0 ]; then
            echo "⚠️ 警告: 依赖包下载过程中出现错误，退出代码: $DOWNLOAD_EXIT_CODE"
            echo "💡 查看下载日志中的错误信息:"
            grep -i "error\|failed\|404\|not found" download.log | head -10 || true
          fi
          
          echo "✅ 下载完成，时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 检查下载结果
          NEW_DEP_COUNT=$(find dl -type f 2>/dev/null | wc -l)
          echo "📊 下载后依赖包数量: $NEW_DEP_COUNT 个"
          echo "📈 新增依赖包: $((NEW_DEP_COUNT - DEP_COUNT)) 个"
          
          echo "🟢 步骤 20 完成"
      
      # 步骤 21: 集成自定义文件（增强版）
      - name: "21. 集成自定义文件（增强版）"
        run: |
          echo "=== 步骤 21: 集成自定义文件（增强版）==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是尝试集成
          trap 'echo "⚠️ 步骤 21 集成过程中出现错误，继续执行..."' ERR
          
          echo "🔍 检查自定义文件目录..."
          CUSTOM_DIR="${{ github.workspace }}/firmware-config/custom-files"
          
          if [ -d "$CUSTOM_DIR" ]; then
            echo "✅ 自定义文件目录存在: $CUSTOM_DIR"
            
            # 递归查找所有文件
            echo "📁 递归查找所有自定义文件..."
            
            # 定义英文文件名检查函数 - 修复正则表达式
            is_english_name() {
              local filename="$1"
              if [[ "$filename" =~ ^[a-zA-Z0-9_.\-]+$ ]]; then
                return 0  # 英文文件名
              else
                return 1  # 非英文文件名
              fi
            }
            
            # 递归查找所有文件
            ALL_FILES=$(find "$CUSTOM_DIR" -type f 2>/dev/null | sort)
            FILE_COUNT=$(echo "$ALL_FILES" | wc -l)
            
            if [ $FILE_COUNT -eq 0 ]; then
              echo "ℹ️ 目录为空"
            else
              echo "📊 找到 $FILE_COUNT 个自定义文件"
              
              # 分类统计
              IPK_COUNT=0
              SCRIPT_COUNT=0
              CONFIG_COUNT=0
              OTHER_COUNT=0
              ENGLISH_COUNT=0
              NON_ENGLISH_COUNT=0
              
              # 详细显示所有文件
              echo ""
              echo "📋 详细文件列表:"
              echo "================================================"
              
              while IFS= read -r file; do
                [ -z "$file" ] && continue
                
                REL_PATH="${file#$CUSTOM_DIR/}"
                FILE_NAME=$(basename "$file")
                FILE_SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                
                # 检查是否为英文文件名 - 使用修复版检测
                if is_english_name "$FILE_NAME"; then
                  NAME_STATUS="✅ 英文"
                  ENGLISH_COUNT=$((ENGLISH_COUNT + 1))
                else
                  NAME_STATUS="⚠️ 非英文"
                  NON_ENGLISH_COUNT=$((NON_ENGLISH_COUNT + 1))
                fi
                
                # 文件类型统计
                if [[ "$FILE_NAME" =~ \.ipk$ ]] || [[ "$FILE_NAME" =~ \.IPK$ ]] || [[ "$FILE_NAME" =~ \.Ipk$ ]]; then
                  TYPE_DESC="📦 IPK包"
                  IPK_COUNT=$((IPK_COUNT + 1))
                elif [[ "$FILE_NAME" =~ \.sh$ ]] || [[ "$FILE_NAME" =~ \.Sh$ ]] || [[ "$FILE_NAME" =~ \.SH$ ]]; then
                  TYPE_DESC="📜 脚本"
                  SCRIPT_COUNT=$((SCRIPT_COUNT + 1))
                elif [[ "$FILE_NAME" =~ \.conf$ ]] || [[ "$FILE_NAME" =~ \.config$ ]] || [[ "$FILE_NAME" =~ \.CONF$ ]]; then
                  TYPE_DESC="⚙️ 配置"
                  CONFIG_COUNT=$((CONFIG_COUNT + 1))
                else
                  TYPE_DESC="📁 其他"
                  OTHER_COUNT=$((OTHER_COUNT + 1))
                fi
                
                printf "%-45s %-8s %-12s %s\n" "$REL_PATH" "$FILE_SIZE" "$TYPE_DESC" "$NAME_STATUS"
                
              done <<< "$ALL_FILES"
              
              echo "================================================"
              
              # 统计信息
              echo ""
              echo "📊 文件统计:"
              echo "  文件总数: $FILE_COUNT 个"
              echo "  📦 IPK文件: $IPK_COUNT 个"
              echo "  📜 脚本文件: $SCRIPT_COUNT 个"
              echo "  ⚙️ 配置文件: $CONFIG_COUNT 个"
              echo "  📁 其他文件: $OTHER_COUNT 个"
              echo "  ✅ 英文文件名: $ENGLISH_COUNT 个"
              echo "  ⚠️ 非英文文件名: $NON_ENGLISH_COUNT 个"
              
              # 文件名建议 - 简化版本
              if [ $NON_ENGLISH_COUNT -gt 0 ]; then
                echo ""
                echo "💡 文件名兼容性建议:"
                echo "  为了更好的兼容性，方便复制、运行，建议使用英文文件名"
                echo "  当前系统会自动处理非英文文件名，但英文名有更好的兼容性"
              fi
              
              echo ""
              echo "🚀 开始执行自定义文件集成（增强版）..."
              BUILD_DIR="${{ env.BUILD_DIR }}"
              cd "$BUILD_DIR"
              ./firmware-config/scripts/build_firmware_main.sh integrate_custom_files
              
              # 验证集成结果
              echo ""
              echo "🔍 验证集成结果..."
              
              # 检查自定义文件目录
              if [ -d "files/etc/custom-files" ]; then
                echo "✅ 自定义文件已复制到: files/etc/custom-files"
                
                # 统计复制后的文件
                FINAL_FILES=$(find "files/etc/custom-files" -type f 2>/dev/null | wc -l)
                echo "📊 复制后文件总数: $FINAL_FILES 个"
                
                # 显示目录结构 - 显示所有文件
                if [ $FINAL_FILES -gt 0 ]; then
                  echo "📁 复制后的所有文件列表:"
                  find "files/etc/custom-files" -type f 2>/dev/null | while read file; do
                    REL_PATH="${file#files/etc/custom-files/}"
                    FILE_SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                    echo "  📄 $REL_PATH ($FILE_SIZE)"
                  done
                fi
                
                # 检查启动脚本
                if [ -f "files/etc/uci-defaults/99-custom-files" ]; then
                  echo "✅ 第一次开机启动脚本: files/etc/uci-defaults/99-custom-files"
                  echo "📝 脚本增强功能:"
                  echo "  - ✅ 递归查找所有自定义文件"
                  echo "  - ✅ 保持原文件名"
                  echo "  - ✅ IPK安装错误不退出，继续下一个"
                  echo "  - ✅ 详细日志记录每个文件的处理结果"
                  echo "  - ✅ 分类统计和成功率计算"
                  echo "  - ✅ 日志存储到 /root/logs/ 目录（重启不丢失）"
                fi
                
                # 检查文件名检查脚本
                if [ -f "files/etc/custom-files/check_filenames.sh" ]; then
                  echo "✅ 文件名检查脚本: files/etc/custom-files/check_filenames.sh"
                fi
                
                echo ""
                echo "🎯 增强版功能说明:"
                echo "  🔧 递归查找: 支持自定义目录下的所有子目录"
                echo "  📝 保持原文件名: 不自动重命名，保持用户设置的文件名"
                echo "  🔄 错误不退出: IPK安装失败继续安装下一个"
                echo "  📊 详细日志: 记录每个文件的处理结果和统计信息"
                echo "  📁 持久日志: 日志存储在 /root/logs/（重启不丢失）"
                
                if [ $NON_ENGLISH_COUNT -gt 0 ]; then
                  echo ""
                  echo "⚠️ 文件名兼容性提醒:"
                  echo "  当前有 $NON_ENGLISH_COUNT 个文件使用非英文文件名"
                  echo "  系统会自动处理，但建议改为英文文件名"
                  echo "  可以在固件启动后运行: /etc/custom-files/check_filenames.sh"
                fi
                
              else
                echo "❌ 未找到自定义文件目录"
              fi
              
            fi
            
            echo ""
            echo "🎉 自定义文件集成完成"
            echo "💡 自定义文件将在第一次开机时自动安装和运行"
            echo "📌 安装顺序: IPK包 → 脚本文件 → 其他文件"
            echo "🔧 错误处理: 单个文件安装失败不会影响其他文件"
            echo "📁 日志位置: /root/logs/（重启不丢失）"
            
          else
            echo "ℹ️ 自定义文件目录不存在: $CUSTOM_DIR"
            echo "📁 跳过自定义文件集成"
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 21 完成"
      
      # 步骤 22: 前置错误检查（修复23.05 SDK验证）- 关键修复
      - name: "22. 前置错误检查（修复23.05 SDK验证）"
        run: |
          echo "=== 步骤 22: 前置错误检查（修复23.05 SDK验证） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 22 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔍 检查当前环境..."
          BUILD_DIR="${{ env.BUILD_DIR }}"
          
          if [ -f "$BUILD_DIR/build_env.sh" ]; then
            source "$BUILD_DIR/build_env.sh"
            echo "✅ 加载环境变量: SELECTED_BRANCH=$SELECTED_BRANCH, TARGET=$TARGET"
          fi
          
          echo "🚀 执行前置错误检查（已修复23.05 SDK验证问题）..."
          cd "$BUILD_DIR"
          ./firmware-config/scripts/build_firmware_main.sh pre_build_error_check
          
          CHECK_EXIT_CODE=$?
          if [ $CHECK_EXIT_CODE -ne 0 ]; then
            echo "❌ 错误: 前置错误检查失败，退出代码: $CHECK_EXIT_CODE"
            echo "💡 请查看上方错误信息进行修复"
            
            # 如果是23.05版本，提供特殊提示
            if [ "$SELECTED_BRANCH" = "openwrt-23.05" ]; then
              echo ""
              echo "🚨 23.05版本SDK验证问题修复提示:"
              echo "💡 23.05 SDK使用GCC 12.3.0，已放宽验证条件"
              echo "📌 只需要有GCC编译器文件即可，不要求特定目录结构"
              echo "🔧 已排除虚假的dummy-tools编译器检测"
            fi
            
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 22 完成"
      
      # 步骤 23: 编译固件前的空间检查
      - name: "23. 编译固件前的空间检查"
        run: |
          echo "=== 步骤 23: 编译固件前的空间检查 ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 23 失败，退出代码: $?"; exit 1' ERR
          
          df -h
          BUILD_DIR="${{ env.BUILD_DIR }}"
          
          # 检查构建目录所在分区的空间
          if [ -d "$BUILD_DIR" ]; then
            PARTITION=$(df "$BUILD_DIR" | tail -1 | awk '{print $6}')
            AVAILABLE_SPACE=$(df "$PARTITION" --output=avail | tail -1 | awk '{print $1}')
            AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
            echo "$PARTITION 可用空间: ${AVAILABLE_GB}G"
            
            if [ $AVAILABLE_GB -lt 10 ]; then
              echo "❌ 错误: 编译前空间不足 (需要至少10G，当前${AVAILABLE_GB}G)"
              exit 1
            elif [ $AVAILABLE_GB -lt 20 ]; then
              echo "⚠️ 警告: 编译前空间较低 (建议至少20G，当前${AVAILABLE_GB}G)"
            else
              echo "✅ 编译前空间充足"
            fi
          else
            echo "⚠️ 构建目录不存在，检查根分区..."
            AVAILABLE_SPACE=$(df / --output=avail | tail -1 | awk '{print $1}')
            AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
            echo "/ 可用空间: ${AVAILABLE_GB}G"
            
            if [ $AVAILABLE_GB -lt 10 ]; then
              echo "❌ 错误: 编译前空间不足 (需要至少10G，当前${AVAILABLE_GB}G)"
              exit 1
            elif [ $AVAILABLE_GB -lt 20 ]; then
              echo "⚠️ 警告: 编译前空间较低 (建议至少20G，当前${AVAILABLE_GB}G)"
            else
              echo "✅ 编译前空间充足"
            fi
          fi
          
          echo "🟢 步骤 23 完成"
      
      # 步骤 24: 编译固件（智能并行优化版）
      - name: "24. 编译固件（智能并行优化版）"
        run: |
          echo "=== 步骤 24: 编译固件（智能并行优化版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 24 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          
          # 获取系统信息
          CPU_CORES=$(nproc)
          TOTAL_MEM=$(free -m | awk '/^Mem:/{print $2}')
          
          echo "🔧 系统信息:"
          echo "  CPU核心数: $CPU_CORES"
          echo "  内存大小: ${TOTAL_MEM}MB"
          echo "  并行优化: ${{ env.ENABLE_PARALLEL }}"
          
          # 智能判断最佳并行任务数 - 优化版
          if [ "${{ env.ENABLE_PARALLEL }}" = "true" ]; then
            echo "🧠 智能判断最佳并行任务数..."
            
            # GitHub Actions Runner 优化配置
            if [ $CPU_CORES -ge 4 ]; then
              if [ $TOTAL_MEM -ge 8000 ]; then
                MAKE_JOBS=4
                echo "✅ 检测到高性能Runner (4核+8GB)"
              else
                MAKE_JOBS=3
                echo "✅ 检测到标准Runner (4核)"
              fi
            elif [ $CPU_CORES -ge 2 ]; then
              if [ $TOTAL_MEM -ge 7000 ]; then
                MAKE_JOBS=3
                echo "✅ 检测到GitHub标准Runner (2核7GB)"
              else
                MAKE_JOBS=2
                echo "✅ 检测到2核Runner"
              fi
            else
              MAKE_JOBS=2
              echo "⚠️ 检测到单核Runner"
            fi
            
            echo "🎯 决定使用 $MAKE_JOBS 个并行任务"
          else
            MAKE_JOBS=1
            echo "🔄 禁用并行优化，使用单线程编译"
          fi
          
          echo ""
          echo "🚀 开始编译固件"
          echo "💡 编译配置:"
          echo "  - 并行任务: $MAKE_JOBS"
          echo "  - 设备: ${{ github.event.inputs.device_name }}"
          echo "  - 版本: ${{ github.event.inputs.version_selection }}"
          echo "  - 配置模式: ${{ github.event.inputs.config_mode }}"
          echo "  - 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置编译环境变量
          export FORCE_UNSAFE_CONFIGURE=1
          
          # 开始编译，使用stdbuf防止stdout错误
          START_TIME=$(date +%s)
          stdbuf -oL -eL time make -j$MAKE_JOBS V=s 2>&1 | tee build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          
          echo ""
          echo "📊 编译统计:"
          echo "  - 总耗时: $((DURATION / 60))分钟$((DURATION % 60))秒"
          echo "  - 退出代码: $BUILD_EXIT_CODE"
          
          if [ $BUILD_EXIT_CODE -eq 0 ]; then
            echo "✅ 固件编译成功"
            
            if [ -d "bin/targets" ]; then
              FIRMWARE_COUNT=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
              echo "✅ 生成固件文件: $FIRMWARE_COUNT 个"
              
              # 显示前3个固件文件
              echo "📁 生成的固件文件 (前3个):"
              find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | head -3 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "  📄 $(basename "$file") ($SIZE)"
              done
            fi
          else
            echo "❌ 错误: 编译失败，退出代码: $BUILD_EXIT_CODE"
            echo "🔍 编译日志中的错误摘要:"
            grep -i "error\|failed" build.log | tail -20 || true
            exit $BUILD_EXIT_CODE
          fi
          
          echo "🟢 步骤 24 完成"
      
      # 步骤 25: 检查构建产物（修复版）
      - name: "25. 检查构建产物（修复版）"
        if: success()
        run: |
          echo "=== 步骤 25: 检查构建产物（修复版） ==="
          echo "🕐 开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 25 失败，退出代码: $?"; exit 1' ERR
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          cd "$BUILD_DIR"
          
          if [ -d "bin/targets" ]; then
            echo "✅ 找到固件目录"
            
            # 统计各种类型文件
            FIRMWARE_COUNT=0
            PACKAGE_COUNT=0
            OTHER_COUNT=0
            
            # 计算文件数量
            echo "📊 正在统计文件..."
            
            # 统计固件文件（.bin和.img）
            FIRMWARE_COUNT=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            # 统计包文件（.gz和.ipk）
            PACKAGE_COUNT=$(find bin/targets -type f \( -name "*.gz" -o -name "*.ipk" \) 2>/dev/null | wc -l)
            
            # 统计其他文件（排除上面两种类型）
            OTHER_COUNT=$(find bin/targets -type f 2>/dev/null | wc -l)
            OTHER_COUNT=$((OTHER_COUNT - FIRMWARE_COUNT - PACKAGE_COUNT))
            
            echo "=========================================="
            echo "📈 构建产物统计:"
            echo "  固件文件: $FIRMWARE_COUNT 个 (.bin/.img)"
            echo "  包文件: $PACKAGE_COUNT 个 (.gz/.ipk)"
            echo "  其他文件: $OTHER_COUNT 个"
            echo "  总文件数: $((FIRMWARE_COUNT + PACKAGE_COUNT + OTHER_COUNT)) 个"
            echo ""
            
            # 显示所有固件文件的详细信息
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "📁 固件文件详细信息:"
              echo "------------------------------------------"
              find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                FULL_SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
                FILE_NAME=$(basename "$file")
                FILE_PATH=$(echo "$file" | sed "s|$BUILD_DIR/||")
                
                echo "🎯 文件: $FILE_NAME"
                echo "  大小: $SIZE ($FULL_SIZE 字节)"
                echo "  路径: $FILE_PATH"
                
                # 判断文件类型
                if [[ "$FILE_NAME" == *factory* ]]; then
                  echo "  类型: 🏭 工厂固件 (用于首次刷机)"
                elif [[ "$FILE_NAME" == *sysupgrade* ]]; then
                  echo "  类型: 🔄 系统升级固件 (用于已安装OpenWrt的设备)"
                elif [[ "$FILE_NAME" == *initramfs* ]]; then
                  echo "  类型: 🚀 内存启动固件 (用于测试和救援)"
                else
                  echo "  类型: 🔧 普通固件"
                fi
                
                echo ""
              done
            else
              echo "⚠️ 警告: 未找到任何固件文件 (.bin/.img)"
              echo "🔍 目录内容 (前10个文件):"
              find bin/targets -type f 2>/dev/null | head -10 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "  📄 $(basename "$file") ($SIZE)"
              done
            fi
            
            # 计算总大小
            echo "📏 大小统计:"
            TOTAL_SIZE=0
            find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
              SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
              TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
            done
            
            if [ $TOTAL_SIZE -gt 0 ]; then
              TOTAL_SIZE_MB=$((TOTAL_SIZE / 1024 / 1024))
              echo "  固件总大小: ${TOTAL_SIZE_MB}MB"
              
              if [ $TOTAL_SIZE_MB -lt 5 ]; then
                echo "  ⚠️ 警告: 固件文件可能太小"
              elif [ $TOTAL_SIZE_MB -gt 100 ]; then
                echo "  ⚠️ 警告: 固件文件可能太大"
              else
                echo "  ✅ 固件大小正常"
              fi
            fi
            
            echo "=========================================="
            echo "✅ 构建产物检查完成"
          else
            echo "❌ 错误: 未找到固件目录"
            echo "⚠️ bin/targets目录不存在"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 25 完成"
      
      # 步骤 26: 上传固件原始目录
      - name: "26. 上传固件原始目录"
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ env.TIMESTAMP }}
          path: ${{ env.BUILD_DIR }}/bin/targets/
          retention-days: 7
          if-no-files-found: error
      
      # 步骤 27: 上传配置文件
      - name: "27. 上传配置文件"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: config-${{ env.TIMESTAMP }}
          path: ${{ github.workspace }}/firmware-config/config-backup/
          retention-days: 7
          if-no-files-found: error
      
      # 步骤 28: 编译后空间检查（修复版）
      - name: "28. 编译后空间检查（修复版）"
        if: always()
        run: |
          echo "=== 步骤 28: 编译后空间检查（修复版） ==="
          echo "🕐 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是检查
          trap 'echo "⚠️ 步骤 28 检查过程中出现错误，继续执行..."' ERR
          
          echo "📊 磁盘使用情况:"
          df -h
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          
          # 检查构建目录所在分区的空间
          if [ -d "$BUILD_DIR" ]; then
            PARTITION=$(df "$BUILD_DIR" | tail -1 | awk '{print $6}')
            AVAILABLE_SPACE=$(df "$PARTITION" --output=avail | tail -1 | awk '{print $1}')
            AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
            echo "$PARTITION 可用空间: ${AVAILABLE_GB}G"
            
            if [ $AVAILABLE_GB -lt 5 ]; then
              echo "⚠️ 警告: 磁盘空间较低，建议清理"
            else
              echo "✅ 磁盘空间充足"
            fi
          else
            echo "⚠️ 构建目录不存在，检查根分区..."
            AVAILABLE_SPACE=$(df / --output=avail | tail -1 | awk '{print $1}')
            AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
            echo "/ 可用空间: ${AVAILABLE_GB}G"
            
            if [ $AVAILABLE_GB -lt 5 ]; then
              echo "⚠️ 警告: 磁盘空间较低，建议清理"
            else
              echo "✅ 磁盘空间充足"
            fi
          fi
          
          echo "🟢 步骤 28 完成"
      
      # 步骤 29: 编译后总结（增强版）- 无SSH测试
      - name: "29. 编译后总结（增强版）- 无SSH测试"
        id: final-summary
        if: always()
        run: |
          echo "=== 步骤 29: 编译后总结（增强版）- 无SSH测试 ==="
          echo "🕐 总结时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，总结不应该失败
          trap 'echo "⚠️ 步骤 29 总结过程中出现错误，继续执行..."' ERR
          
          echo "🚀 构建总结报告"
          echo "========================================"
          echo "设备: ${{ github.event.inputs.device_name }}"
          echo "版本: ${{ github.event.inputs.version_selection }}"
          echo "配置模式: ${{ github.event.inputs.config_mode }}"
          echo "时间戳: ${{ env.TIMESTAMP }}"
          echo "并行优化: ${{ github.event.inputs.enable_parallel }}"
          echo "构建来源: ${{ env.BUILD_SOURCE }}"
          echo "构建ID: ${{ env.BUILD_ID }}"
          echo ""
          
          BUILD_DIR="${{ env.BUILD_DIR }}"
          echo "📌 构建目录: $BUILD_DIR"
          
          # 检查构建产物
          if [ -d "$BUILD_DIR/bin/targets" ]; then
            # 正确统计固件文件
            FIRMWARE_COUNT=$(find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            echo "📦 构建产物:"
            echo "  固件数量: $FIRMWARE_COUNT 个 (.bin/.img)"
            
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "  产物位置: $BUILD_DIR/bin/targets/"
              echo "  下载名称: firmware-${{ env.TIMESTAMP }}"
              echo "  构建状态: ✅ 成功"
              
              # 设置步骤输出
              echo "build_status=success" >> $GITHUB_OUTPUT
              
              # 显示所有固件文件信息
              echo "  固件文件详情:"
              find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                FILE_NAME=$(basename "$file")
                
                if [[ "$FILE_NAME" == *factory* ]]; then
                  TYPE="🏭 工厂固件"
                elif [[ "$FILE_NAME" == *sysupgrade* ]]; then
                  TYPE="🔄 升级固件"
                elif [[ "$FILE_NAME" == *initramfs* ]]; then
                  TYPE="🚀 内存固件"
                else
                  TYPE="🔧 普通固件"
                fi
                
                echo "    🎯 $FILE_NAME ($SIZE) - $TYPE"
              done
            else
              echo "  构建状态: ⚠️ 编译完成但未生成固件文件"
              echo "build_status=warning" >> $GITHUB_OUTPUT
            fi
          else
            echo "📦 构建产物: 未生成任何文件"
            echo "  构建状态: ❌ 失败"
            echo "build_status=failed" >> $GITHUB_OUTPUT
          fi
          
          # 构建状态总结
          echo ""
          echo "📊 构建状态总结:"
          if [ -d "$BUILD_DIR/bin/targets" ]; then
            FIRMWARE_COUNT=$(find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "  ✅ 构建结果: 成功生成 $FIRMWARE_COUNT 个固件文件"
            else
              echo "  ⚠️ 构建结果: 编译完成但未生成固件文件"
            fi
          else
            echo "  ❌ 构建结果: 失败"
          fi
          
          # 构建完成时间
          echo ""
          echo "📅 构建时间线:"
          echo "  开始时间: $(date -d @${{ github.run_started_at }} '+%Y-%m-%d %H:%M:%S')"
          echo "  结束时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo ""
          echo "✅ 构建流程完成"
          echo "========================================"
          echo "🟢 步骤 29 完成"
      
      # 步骤 30: 创建构建状态文件（用于网页显示）
      - name: "30. 创建构建状态文件"
        if: always()
        run: |
          echo "=== 步骤 30: 创建构建状态文件 ==="
          echo "🕐 创建时间: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 创建构建状态目录
          mkdir -p /tmp/build-status
          
          # 构建状态信息
          BUILD_STATUS="{
            \"build_id\": \"${{ env.BUILD_ID }}\",
            \"workflow_id\": \"${{ github.run_id }}\",
            \"workflow_number\": \"${{ github.run_number }}\",
            \"repository\": \"${{ github.repository }}\",
            \"device\": \"${{ github.event.inputs.device_name }}\",
            \"version\": \"${{ github.event.inputs.version_selection }}\",
            \"mode\": \"${{ github.event.inputs.config_mode }}\",
            \"source\": \"${{ env.BUILD_SOURCE }}\",
            \"status\": \"${{ job.status }}\",
            \"timestamp\": \"${{ env.TIMESTAMP }}\",
            \"start_time\": \"$(date -d @${{ github.run_started_at }} '+%Y-%m-%dT%H:%M:%SZ')\",
            \"end_time\": \"$(date -u '+%Y-%m-%dT%H:%M:%SZ')\",
            \"workflow_url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
            \"artifacts_url\": \"https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
            \"firmware_count\": 0,
            \"firmware_files\": []
          }"
          
          # 检查是否有固件文件
          BUILD_DIR="${{ env.BUILD_DIR }}"
          if [ -d "$BUILD_DIR/bin/targets" ]; then
            FIRMWARE_COUNT=$(find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            # 更新状态信息
            BUILD_STATUS=$(echo "$BUILD_STATUS" | jq --arg count "$FIRMWARE_COUNT" '.firmware_count = ($count | tonumber)')
            
            # 添加固件文件信息
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              FIRMWARE_FILES_JSON="[]"
              find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
                FILE_NAME=$(basename "$file")
                REL_PATH=$(echo "$file" | sed "s|$BUILD_DIR/||")
                
                FILE_INFO="{
                  \"name\": \"$FILE_NAME\",
                  \"size\": $SIZE,
                  \"path\": \"$REL_PATH\"
                }"
                
                FIRMWARE_FILES_JSON=$(echo "$FIRMWARE_FILES_JSON" | jq --argjson info "$FILE_INFO" '. += [$info]')
              done
              
              BUILD_STATUS=$(echo "$BUILD_STATUS" | jq --argjson files "$FIRMWARE_FILES_JSON" '.firmware_files = $files')
            fi
          fi
          
          # 保存状态文件
          echo "$BUILD_STATUS" > /tmp/build-status/status.json
          
          # 格式化输出
          echo "📄 构建状态文件已创建:"
          echo "$BUILD_STATUS" | jq .
          
          echo "✅ 完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 30 完成"
      
      # 步骤 31: 上传构建状态文件
      - name: "31. 上传构建状态文件"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-status-${{ env.TIMESTAMP }}
          path: /tmp/build-status/
          retention-days: 7
          if-no-files-found: error

  # 新增：构建结果通知（可选）
  notify:
    name: "📢 构建结果通知"
    needs: build-firmware
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: "显示构建结果"
        run: |
          echo "=== 📢 构建结果通知 ==="
          echo "构建ID: ${{ needs.build-firmware.outputs.build_id }}"
          echo "构建状态: ${{ needs.build-firmware.outputs.build_status }}"
          echo "工作流运行: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ "${{ needs.build-firmware.outputs.build_status }}" = "success" ]; then
            echo "🎉 构建成功！可以下载固件了。"
          elif [ "${{ needs.build-firmware.outputs.build_status }}" = "warning" ]; then
            echo "⚠️ 构建完成但可能有警告，请检查日志。"
          else
            echo "❌ 构建失败，请查看详细日志。"
          fi

name: OpenWrt 智能固件构建工作流（完整修复版）

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: '设备名称 (如: ac42u, ac58u, mi4a 等)'
        required: true
        default: 'ac42u'
        type: string
      old_device:
        description: '是否为老旧设备 (性能较差的设备建议选择true)'
        required: true
        default: false
        type: boolean
      version_spec:
        description: '版本规格 (可选，如: openwrt-23.05 或 immortalwrt:master)'
        required: false
        type: string
        default: ''
      config_type:
        description: '配置类型 (minimal:基础功能, normal:完整功能, custom:自定义)'
        required: true
        default: 'normal'
        type: choice
        options: ['minimal', 'normal', 'custom']
      extra_packages:
        description: '额外安装插件 (空格分隔的包名)'
        required: false
        type: string
      disabled_plugins:
        description: '禁用插件 (空格分隔的包名，如: luci-app-accesscontrol luci-app-ddns)'
        required: false
        type: string
        default: ''
      save_config:
        description: '保存配置文件到仓库'
        required: false
        default: true
        type: boolean
      custom_install:
        description: '启用自定义安装 (IPK和脚本)'
        required: false
        default: true
        type: boolean
      enable_cache:
        description: '启用编译缓存 (显著加速后续编译)'
        required: false
        default: true
        type: boolean

env:
  BUILD_DIR: /mnt/openwrt-build
  MIRROR_SOURCE: "tuna"
  CACHE_ENABLED: true

jobs:
  build-firmware:
    runs-on: ubuntu-latest
    
    steps:
    - name: 初始空间检查
      run: |
        echo "=== 初始磁盘空间检查 ==="
        df -h
        AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
        AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
        echo "/mnt 可用空间: ${AVAILABLE_GB}G"
        if [ $AVAILABLE_GB -lt 50 ]; then
          echo "错误: /mnt 空间不足50G"
          exit 1
        fi

    - name: 检出配置仓库
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 设置编译环境
      run: |
        echo "=== 安装编译依赖包 ==="
        sudo apt-get update
        sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential libncurses5-dev libssl-dev python3 unzip zlib1g-dev subversion gcc-multilib git curl file ninja-build automake autoconf libtool pkg-config gettext help2man texinfo gawk flex bison rsync wget aria2 python3-pip libelf-dev liblz4-dev zstd libssl-dev libcurl4-openssl-dev groff texlive texinfo
        pip3 install requests urllib3
        echo "✅ 编译环境设置完成"

    - name: 创建构建目录并设置权限
      run: |
        echo "=== 创建构建目录 ==="
        sudo mkdir -p $BUILD_DIR
        sudo chown -R $USER:$USER $BUILD_DIR
        sudo chmod -R 755 $BUILD_DIR
        sudo chmod u+w $BUILD_DIR
        echo "✅ 构建目录创建完成"
        touch $BUILD_DIR/test_write.txt && echo "✅ 写入测试成功" && rm $BUILD_DIR/test_write.txt

    - name: 复制脚本到构建目录
      run: |
        echo "=== 复制脚本到构建目录 ==="
        cd $GITHUB_WORKSPACE
        
        # 复制所有脚本文件
        SCRIPTS=("complete_version_detector.sh" "device_detection.sh" "error_analysis.sh" "pre_download.sh" "check-plugins.sh" "diagnose-packages.sh")
        
        echo "要复制的脚本列表: ${SCRIPTS[@]}"
        echo "当前工作目录: $(pwd)"
        echo "目录内容:"
        find . -name "*.sh" -type f | head -20
        
        COPIED_COUNT=0
        for script in "${SCRIPTS[@]}"; do
          echo "正在查找: $script"
          FOUND_SCRIPT=$(find . -name "$script" -type f | head -1)
          if [ -n "$FOUND_SCRIPT" ]; then
            cp "$FOUND_SCRIPT" $BUILD_DIR/
            echo "✅ 找到并复制: $script (从 $FOUND_SCRIPT)"
            COPIED_COUNT=$((COPIED_COUNT + 1))
          else
            echo "⚠️ 未找到: $script"
          fi
        done
        
        echo "总共复制了 $COPIED_COUNT 个脚本文件"
        
        cd $BUILD_DIR
        echo "构建目录中的脚本:"
        ls -la *.sh 2>/dev/null || echo "没有找到.sh文件"
        chmod +x *.sh 2>/dev/null || true
        echo "✅ 脚本复制完成"

    - name: 验证脚本存在性
      run: |
        cd $BUILD_DIR
        echo "=== 验证脚本存在性 ==="
        echo "构建目录内容:"
        ls -la
        
        REQUIRED_SCRIPTS=("complete_version_detector.sh" "device_detection.sh")
        ALL_SCRIPTS_EXIST=true
        
        for script in "${REQUIRED_SCRIPTS[@]}"; do
          if [ -f "$script" ]; then
            echo "✅ $script 存在"
            chmod +x "$script"
          else
            echo "❌ 错误: $script 不存在"
            ALL_SCRIPTS_EXIST=false
          fi
        done
        
        if [ "$ALL_SCRIPTS_EXIST" = false ]; then
          echo "当前目录中的文件:"
          ls -la
          echo "❌ 关键脚本缺失，构建终止"
          exit 1
        fi

    - name: 智能版本检测
      id: version-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能版本检测 ==="
        sudo chown -R $USER:$USER . 2>/dev/null || true
        chmod u+w . 2>/dev/null || true
        chmod +x *.sh 2>/dev/null || true
        
        echo "设备名称: ${{ github.event.inputs.device_name }}"
        echo "版本规格: ${{ github.event.inputs.version_spec }}"
        echo "老旧设备: ${{ github.event.inputs.old_device }}"
        
        if [ ! -f "complete_version_detector.sh" ]; then
          echo "❌ 错误: complete_version_detector.sh 不存在"
          ls -la
          exit 1
        fi
        
        chmod +x complete_version_detector.sh
        
        set +e
        OUTPUT=$(./complete_version_detector.sh "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_spec }}" "${{ github.event.inputs.old_device }}" 2>&1)
        SCRIPT_EXIT_CODE=$?
        set -e
        
        echo "脚本输出:"
        echo "$OUTPUT"
        echo "脚本退出代码: $SCRIPT_EXIT_CODE"
        
        SELECTED_REPO=$(echo "$OUTPUT" | grep "^SELECTED_REPO=" | head -1 | cut -d'=' -f2)
        SELECTED_BRANCH=$(echo "$OUTPUT" | grep "^SELECTED_BRANCH=" | head -1 | cut -d'=' -f2)
        SELECTED_REPO_URL=$(echo "$OUTPUT" | grep "^SELECTED_REPO_URL=" | head -1 | cut -d'=' -f2)
        
        if [ -n "$SELECTED_REPO" ] && [ -n "$SELECTED_BRANCH" ] && [ -n "$SELECTED_REPO_URL" ]; then
            echo "✅ 从脚本输出中成功提取版本信息"
            echo "SELECTED_REPO=$SELECTED_REPO" >> $GITHUB_ENV
            echo "SELECTED_BRANCH=$SELECTED_BRANCH" >> $GITHUB_ENV
            echo "SELECTED_REPO_URL=$SELECTED_REPO_URL" >> $GITHUB_ENV
            echo "✅ 环境变量已设置:"
            echo "  仓库: $SELECTED_REPO"
            echo "  分支: $SELECTED_BRANCH"
            echo "  URL: $SELECTED_REPO_URL"
        else
            echo "❌ 无法从脚本输出中提取版本信息"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 版本检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但无法提取版本信息，使用默认值"
                echo "SELECTED_REPO=immortalwrt" >> $GITHUB_ENV
                echo "SELECTED_BRANCH=master" >> $GITHUB_ENV
                echo "SELECTED_REPO_URL=https://github.com/immortalwrt/immortalwrt.git" >> $GITHUB_ENV
                echo "✅ 使用默认版本信息"
            fi
        fi

    - name: 备份检测脚本
      run: |
        echo "=== 备份检测脚本 ==="
        mkdir -p /tmp/build-scripts-backup
        cp $BUILD_DIR/*.sh /tmp/build-scripts-backup/ 2>/dev/null || true
        echo "✅ 脚本备份完成"

    - name: 清理构建目录
      run: |
        cd $BUILD_DIR
        echo "=== 清理构建目录准备克隆 ==="
        ls -la
        sudo rm -rf ./* ./.git* 2>/dev/null || true
        sudo rm -rf .[!.]* 2>/dev/null || true
        ls -la
        echo "✅ 目录清理完成"

    - name: 克隆源码
      run: |
        cd $BUILD_DIR
        echo "=== 克隆选定版本的源码 ==="
        echo "仓库: $SELECTED_REPO_URL"
        echo "分支: $SELECTED_BRANCH"
        
        if [ -z "$SELECTED_REPO_URL" ] || [ -z "$SELECTED_BRANCH" ]; then
          echo "❌ 错误: 环境变量未正确设置"
          exit 1
        fi
        
        echo "检查目录状态..."
        FILE_COUNT=$(ls -A | wc -l)
        if [ $FILE_COUNT -ne 0 ]; then
          echo "❌ 错误: 目录非空，无法克隆"
          exit 1
        fi
        
        MAX_RETRIES=3
        RETRY_COUNT=0
        CLONE_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$CLONE_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "克隆尝试: $RETRY_COUNT/$MAX_RETRIES"
          
          if git clone --depth 1 --branch "$SELECTED_BRANCH" "$SELECTED_REPO_URL" .; then
            echo "✅ 源码克隆完成"
            CLONE_SUCCESS=true
          else
            echo "❌ 克隆失败，尝试 $RETRY_COUNT/$MAX_RETRIES"
            
            if echo "$SELECTED_REPO_URL" | grep -q "github.com" && [ $RETRY_COUNT -eq 2 ]; then
              echo "🔄 尝试使用镜像源..."
              MIRROR_URL=$(echo "$SELECTED_REPO_URL" | sed 's/github.com/github.com.cnpmjs.org/')
              rm -rf ./* ./.git* 2>/dev/null || true
              if git clone --depth 1 --branch "$SELECTED_BRANCH" "$MIRROR_URL" .; then
                echo "✅ 使用镜像源克隆成功"
                CLONE_SUCCESS=true
                break
              fi
            fi
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "❌ 源码克隆失败，达到最大重试次数"
              exit 1
            fi
            sleep 10
            rm -rf ./* ./.git* 2>/dev/null || true
          fi
        done

    - name: 恢复检测脚本
      run: |
        cd $BUILD_DIR
        echo "=== 恢复检测脚本 ==="
        cp /tmp/build-scripts-backup/*.sh ./ 2>/dev/null || true
        chmod +x *.sh
        echo "✅ 脚本恢复完成"

    - name: 配置多源feeds
      run: |
        cd $BUILD_DIR
        echo "=== 配置多源feeds ==="
        
        # 备份原始feeds配置
        cp feeds.conf.default feeds.conf.default.backup
        
        # 创建多源feeds配置 - 使用多个echo命令
        echo "src-git immortalwrt_packages https://github.com/immortalwrt/packages;main" > feeds.conf.default
        echo "src-git immortalwrt_luci https://github.com/immortalwrt/luci;main" >> feeds.conf.default
        echo "src-git immortalwrt_routing https://github.com/immortalwrt/routing;main" >> feeds.conf.default
        echo "src-git immortalwrt_telephony https://github.com/immortalwrt/telephony;main" >> feeds.conf.default
        echo "" >> feeds.conf.default
        echo "# OpenWrt 官方源" >> feeds.conf.default
        echo "src-git openwrt_packages https://git.openwrt.org/feed/packages.git;main" >> feeds.conf.default
        echo "src-git openwrt_luci https://git.openwrt.org/project/luci.git;main" >> feeds.conf.default
        echo "src-git openwrt_routing https://git.openwrt.org/feed/routing.git;main" >> feeds.conf.default
        echo "src-git openwrt_telephony https://git.openwrt.org/feed/telephony.git;main" >> feeds.conf.default
        echo "" >> feeds.conf.default
        echo "# 第三方插件源" >> feeds.conf.default
        echo "src-git lienol_packages https://github.com/Lienol/openwrt-packages;main" >> feeds.conf.default
        echo "src-git kenzo_packages https://github.com/kenzok8/openwrt-packages;main" >> feeds.conf.default
        echo "src-git small_packages https://github.com/kenzok8/small;main" >> feeds.conf.default
        echo "" >> feeds.conf.default
        echo "# 特定功能插件源" >> feeds.conf.default
        echo "src-git smartdns https://github.com/pymumu/openwrt-smartdns;master" >> feeds.conf.default
        echo "src-git openclash https://github.com/vernesong/OpenClash;master" >> feeds.conf.default
        
        echo "✅ 多源feeds配置完成"
        echo "Feeds配置内容:"
        cat feeds.conf.default

    - name: 更新安装feeds
      run: |
        cd $BUILD_DIR
        echo "=== 更新和安装feeds ==="
        ./scripts/feeds update -a
        ./scripts/feeds install -a

    - name: 复制配置文件和脚本
      run: |
        cd $BUILD_DIR
        echo "=== 重新复制配置文件和脚本 ==="
        cd $GITHUB_WORKSPACE
        
        echo "=== 查找配置文件 ==="
        mkdir -p $BUILD_DIR/config-templates
        CONFIG_FILES=("minimal.config" "normal-new.config" "normal-old.config")
        for config_file in "${CONFIG_FILES[@]}"; do
          echo "正在查找配置文件: $config_file"
          FOUND_CONFIG=$(find . -name "$config_file" -type f | head -1)
          if [ -n "$FOUND_CONFIG" ]; then
            cp "$FOUND_CONFIG" $BUILD_DIR/config-templates/
            echo "✅ 复制: $config_file (从 $FOUND_CONFIG)"
          else
            echo "⚠️ 未找到: $config_file"
          fi
        done
        
        echo "✅ 配置文件复制完成"
        
        SCRIPTS=("error_analysis.sh" "pre_download.sh" "check-plugins.sh" "diagnose-packages.sh")
        for script in "${SCRIPTS[@]}"; do
          FOUND_SCRIPT=$(find . -name "$script" -type f | head -1)
          if [ -n "$FOUND_SCRIPT" ]; then
            cp "$FOUND_SCRIPT" $BUILD_DIR/
            chmod +x $BUILD_DIR/"$script"
            echo "✅ 更新脚本: $script"
          fi
        done
        
        echo "✅ 配置文件和脚本重新复制完成"

    - name: 设备检测
      id: device-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能设备检测与别名转换 ==="
        
        INPUT_DEVICE="${{ github.event.inputs.device_name }}"
        echo "输入设备名称: $INPUT_DEVICE"
        
        case "$INPUT_DEVICE" in
            "ac42u"|"acrh17"|"rt-acrh17") ACTUAL_DEVICE="asus_rt-ac42u" ;;
            "ac58u"|"acrh13"|"rt-ac58u"|"rt-acrh13") ACTUAL_DEVICE="asus_rt-ac58u" ;;
            "mi4a"|"r4a") ACTUAL_DEVICE="xiaomi_mi-router-4a-gigabit" ;;
            "mi3g"|"r3g") ACTUAL_DEVICE="xiaomi_mi-router-3g" ;;
            *) ACTUAL_DEVICE="$INPUT_DEVICE" ;;
        esac
        
        if [ "$ACTUAL_DEVICE" != "$INPUT_DEVICE" ]; then
          echo "✅ 检测到设备通用名称 '$INPUT_DEVICE'，转换为实际设备标识 '$ACTUAL_DEVICE'"
        else
          echo "ℹ️ 使用原始设备名称: $ACTUAL_DEVICE"
        fi
        
        if [ ! -f "device_detection.sh" ]; then
          echo "❌ 错误: 设备检测脚本不存在"
          exit 1
        fi
        chmod +x device_detection.sh
        
        echo "=== 开始设备检测 ==="
        TEMP_LOG=$(mktemp)
        
        set +e
        ./device_detection.sh "$ACTUAL_DEVICE" 2>&1 | tee "$TEMP_LOG"
        SCRIPT_EXIT_CODE=$?
        set -e
        
        echo "=== 脚本退出代码: $SCRIPT_EXIT_CODE ==="
        
        PLATFORM=$(grep "^PLATFORM=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_SHORT_NAME=$(grep "^DEVICE_SHORT_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_FULL_NAME=$(grep "^DEVICE_FULL_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        
        echo "=== 提取的设备信息 ==="
        echo "平台(PLATFORM): '$PLATFORM'"
        echo "设备短名称(DEVICE_SHORT_NAME): '$DEVICE_SHORT_NAME'"
        echo "设备全名称(DEVICE_FULL_NAME): '$DEVICE_FULL_NAME'"
        
        rm -f "$TEMP_LOG"
        
        if [ -n "$PLATFORM" ] && [ -n "$DEVICE_SHORT_NAME" ] && [ -n "$DEVICE_FULL_NAME" ]; then
            echo "✅ 从脚本输出中成功提取设备信息"
            echo "PLATFORM=$PLATFORM" >> $GITHUB_ENV
            echo "DEVICE_SHORT_NAME=$DEVICE_SHORT_NAME" >> $GITHUB_ENV
            echo "DEVICE_FULL_NAME=$DEVICE_FULL_NAME" >> $GITHUB_ENV
        else
            echo "❌ 无法从脚本输出中提取设备信息"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 设备检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但无法提取设备信息，使用备用设备映射"
                case "$ACTUAL_DEVICE" in
                    "asus_rt-ac42u"|"ac42u"|"acrh17"|"rt-acrh17")
                        echo "PLATFORM=ipq40xx" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=asus_rt-ac42u" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    "asus_rt-ac58u"|"ac58u"|"acrh13"|"rt-acrh13")
                        echo "PLATFORM=ipq40xx" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=asus_rt-ac58u" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    "xiaomi_mi-router-4a-gigabit"|"mi4a"|"r4a")
                        echo "PLATFORM=ramips" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=xiaomi_mi-router-4a-gigabit" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    *)
                        echo "❌ 未知设备，无法设置默认值"
                        exit 1
                        ;;
                esac
                echo "✅ 已使用备用设备信息"
            fi
        fi

    - name: 创建智能插件检查脚本
      run: |
        cd $BUILD_DIR
        echo "=== 创建智能插件检查脚本 ==="
        
        # 使用多个echo命令创建完整的智能插件检查脚本
        echo '#!/bin/bash' > check-plugins.sh
        echo 'set -e' >> check-plugins.sh
        echo 'BUILD_DIR="${1:-.}"' >> check-plugins.sh
        echo 'cd "$BUILD_DIR"' >> check-plugins.sh
        echo 'echo "=== 智能插件可用性检查与映射系统 ==="' >> check-plugins.sh
        echo 'echo "更新feeds..."' >> check-plugins.sh
        echo './scripts/feeds update -a > /dev/null 2>&1' >> check-plugins.sh
        
        # 这里简化了插件映射内容，您可以根据需要扩展
        echo 'CRITICAL_PLUGINS=("luci" "luci-base" "luci-theme-bootstrap" "luci-i18n-base-zh-cn" "luci-i18n-firewall-zh-cn")' >> check-plugins.sh
        echo 'FEATURE_PLUGINS=("luci-app-turboacc" "luci-app-samba4" "luci-app-smartdns" "luci-app-arpbind" "luci-app-cpulimit" "luci-app-diskman")' >> check-plugins.sh
        echo 'REPORT_FILE="plugin_availability_report.txt"' >> check-plugins.sh
        echo 'echo "插件可用性检查报告" > $REPORT_FILE' >> check-plugins.sh
        echo 'echo "生成时间: $(date)" >> $REPORT_FILE' >> check-plugins.sh
        echo 'echo "=== 关键插件检查 ===" >> $REPORT_FILE' >> check-plugins.sh
        
        # 关键插件检查
        echo 'CRITICAL_MISSING=()' >> check-plugins.sh
        echo 'for plugin in "${CRITICAL_PLUGINS[@]}"; do' >> check-plugins.sh
        echo '    if ./scripts/feeds install "$plugin" > /dev/null 2>&1; then' >> check-plugins.sh
        echo '        echo "✅ $plugin" | tee -a $REPORT_FILE' >> check-plugins.sh
        echo '    else' >> check-plugins.sh
        echo '        echo "❌ $plugin" | tee -a $REPORT_FILE' >> check-plugins.sh
        echo '        CRITICAL_MISSING+=("$plugin")' >> check-plugins.sh
        echo '    fi' >> check-plugins.sh
        echo 'done' >> check-plugins.sh
        
        # 功能插件检查
        echo 'echo "=== 功能插件检查 ===" >> $REPORT_FILE' >> check-plugins.sh
        echo 'FEATURE_MISSING=()' >> check-plugins.sh
        echo 'for plugin in "${FEATURE_PLUGINS[@]}"; do' >> check-plugins.sh
        echo '    if ./scripts/feeds install "$plugin" > /dev/null 2>&1; then' >> check-plugins.sh
        echo '        echo "✅ $plugin" | tee -a $REPORT_FILE' >> check-plugins.sh
        echo '    else' >> check-plugins.sh
        echo '        echo "⚠️ $plugin (无替代)" | tee -a $REPORT_FILE' >> check-plugins.sh
        echo '        FEATURE_MISSING+=("$plugin")' >> check-plugins.sh
        echo '    fi' >> check-plugins.sh
        echo 'done' >> check-plugins.sh
        
        # 总结报告
        echo 'echo "=== 检查总结 ===" >> $REPORT_FILE' >> check-plugins.sh
        echo 'if [ ${#CRITICAL_MISSING[@]} -gt 0 ]; then' >> check-plugins.sh
        echo '    echo "❌ 关键插件缺失: ${CRITICAL_MISSING[*]}" >> $REPORT_FILE' >> check-plugins.sh
        echo '    echo "❌ 关键插件缺失，构建终止"' >> check-plugins.sh
        echo '    exit 1' >> check-plugins.sh
        echo 'else' >> check-plugins.sh
        echo '    echo "✅ 所有关键插件都可用" >> $REPORT_FILE' >> check-plugins.sh
        echo '    echo "✅ 插件检查通过"' >> check-plugins.sh
        echo '    exit 0' >> check-plugins.sh
        echo 'fi' >> check-plugins.sh

        chmod +x check-plugins.sh
        echo "✅ 智能插件检查脚本创建完成"

    - name: 智能检查插件可用性
      run: |
        cd $BUILD_DIR
        echo "=== 智能检查插件可用性 ==="
        
        if [ -f "check-plugins.sh" ]; then
            chmod +x check-plugins.sh
            echo "开始智能检查插件在feeds中的可用性..."
            set +e
            ./check-plugins.sh "$BUILD_DIR"
            CHECK_RESULT=$?
            set -e
            
            case $CHECK_RESULT in
                0)
                    echo "✅ 插件检查完成 - 所有包都可用"
                    ;;
                1)
                    echo "❌ 插件检查失败 - 有关键包缺失"
                    exit 1
                    ;;
                *)
                    echo "ℹ️ 插件检查完成"
                    ;;
            esac
        else
            echo "⚠️ 未找到插件检查脚本，跳过插件检查"
        fi

    # ... 后续步骤保持不变，只是确保不使用heredoc语法 ...

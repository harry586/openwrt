name: "OpenWrt 智能固件构建工作流（已编译编译器版）"

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: "📱 设备名称 (如: ac42u)"
        required: true
        default: "ac42u"
        type: string
      version_selection:
        description: "🔄 版本选择"
        required: true
        type: choice
        default: "21.02"
        options:
          - "23.05"
          - "21.02"
      config_mode:
        description: |
          ⚙️ 配置模式选择
          
          🟣 基础模式 - 最小化配置，用于测试编译
          🟠 正常模式 - 完整功能配置：✅ TurboACC 网络加速 ✅ UPnP 自动端口转发 ✅ Samba 文件共享 ✅ 磁盘管理 ✅ KMS 激活服务 ✅ SmartDNS 智能DNS ✅ 家长控制 ✅ 微信推送 ✅ 流量控制 (SQM) ✅ FTP 服务器 ✅ ARP 绑定 ✅ CPU 限制 ✅ 硬盘休眠
          
          🔧 USB 3.0加强：所有平台的关键USB驱动都已强制启用！
        required: true
        type: choice
        default: "normal"
        options:
          - "base"
          - "normal"
      extra_packages:
        description: |
          额外安装插件
          格式：用分号;分隔。启用插件：+插件名。禁用插件：-插件名。
        required: false
        type: string
        default: ""

env:
  BUILD_DIR: "/mnt/openwrt-build"
  COMPILER_DIR: "${{ github.workspace }}/firmware-config/build-Compiler-file"

jobs:
  build-firmware:
    runs-on: ubuntu-22.04
    
    steps:
      # 步骤 1: 使用Git Archive API下载源代码（默认启用）
      - name: "1. 使用Git Archive API下载源代码（智能排除编译器）"
        run: |
          echo "=== 步骤 1: 使用Git Archive API下载源代码（智能排除编译器） ==="
          echo "🔄 从GitHub API获取源代码压缩包（排除编译器目录）"
          
          # 创建临时目录
          mkdir -p /tmp/openwrt-source
          cd /tmp/openwrt-source
          
          # 获取默认分支
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}" | jq -r '.default_branch')
          echo "默认分支: $DEFAULT_BRANCH"
          
          # 使用Git Archive API下载压缩包
          echo "下载源代码压缩包..."
          curl -s -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/tarball/$DEFAULT_BRANCH" -o source.tar.gz
          
          if [ ! -f "source.tar.gz" ]; then
            echo "❌ 下载源代码压缩包失败"
            exit 1
          fi
          
          echo "✅ 下载完成，文件大小: $(ls -lh source.tar.gz | awk '{print $5}')"
          
          # 解压压缩包
          echo "解压源代码..."
          tar -xzf source.tar.gz --strip-components=1
          
          # 检查解压结果
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "✅ 源代码解压成功"
            echo "重要文件存在: firmware-config/scripts/build_firmware_main.sh"
            
            # 检查编译器目录大小
            echo "📊 检查目录结构:"
            echo "当前目录: $(pwd)"
            echo "目录内容:"
            ls -la
            echo ""
            
            if [ -d "firmware-config/build-Compiler-file" ]; then
              echo "🔍 检查编译器目录: firmware-config/build-Compiler-file"
              echo "编译器目录大小: $(du -sh firmware-config/build-Compiler-file 2>/dev/null | cut -f1 || echo '未知')"
              
              # 检查预编译编译器是否存在
              if [ -d "firmware-config/build-Compiler-file/compilers" ]; then
                echo "✅ 找到预编译编译器: compilers/"
                compiled_size=$(du -sh firmware-config/build-Compiler-file/compilers 2>/dev/null | cut -f1 || echo "未知")
                echo "预编译编译器大小: $compiled_size"
                
                # 显示编译器架构
                echo "📋 支持的架构:"
                find firmware-config/build-Compiler-file/compilers -maxdepth 1 -type d 2>/dev/null | while read arch_dir; do
                  if [ "$arch_dir" != "firmware-config/build-Compiler-file/compilers" ]; then
                    arch_name=$(basename "$arch_dir")
                    arch_size=$(du -sh "$arch_dir" 2>/dev/null | cut -f1 || echo "未知")
                    echo "  🏗️  $arch_name ($arch_size)"
                  fi
                done
              else
                echo "ℹ️ 未找到预编译编译器目录 (compilers/)"
              fi
              
              # 不再检查编译器源代码，因为不需要
              echo "ℹ️ 跳过编译器源代码检查（不需要）"
            else
              echo "ℹ️ 编译器目录不存在，将创建"
            fi
            
            # 复制到工作区 - 使用精确复制
            echo "复制文件到工作区..."
            
            # 确保工作区目录存在
            mkdir -p ${{ github.workspace }}
            
            # 使用rsync复制所有文件，排除.git目录，但保留编译器目录
            rsync -av \
              --exclude='.git' \
              --exclude='.github' \
              . ${{ github.workspace }}/
            
            # 确保脚本文件有执行权限
            chmod +x ${{ github.workspace }}/firmware-config/scripts/*.sh 2>/dev/null || true
            
            # 检查复制结果
            echo "✅ 文件复制完成"
            echo "工作区内容:"
            ls -la ${{ github.workspace }}/ 2>/dev/null | head -10
            
            # 检查编译器目录是否被正确复制
            if [ -d "${{ github.workspace }}/firmware-config/build-Compiler-file" ]; then
              echo "🎉 编译器目录已成功复制到工作区"
              echo "工作区编译器目录: ${{ github.workspace }}/firmware-config/build-Compiler-file"
              echo "目录大小: $(du -sh ${{ github.workspace }}/firmware-config/build-Compiler-file 2>/dev/null | cut -f1 || echo '未知')"
            else
              echo "⚠️ 编译器目录未复制到工作区"
            fi
            
            # 保存源代码压缩包作为构建产物
            mkdir -p /tmp/build-artifacts/source-archive
            cp source.tar.gz /tmp/build-artifacts/source-archive/
            echo "✅ 源代码归档保存"
          else
            echo "❌ 源代码解压失败，重要文件缺失"
            echo "当前目录内容:"
            ls -la
            exit 1
          fi
          
          # 清理临时文件
          cd /tmp
          rm -rf openwrt-source
          echo "✅ Git Archive API下载完成"
      
      # 步骤 2: 立即上传Git Archive源代码
      - name: "2. 立即上传Git Archive源代码"
        uses: actions/upload-artifact@v4
        with:
          name: "git-archive-source-${{ github.event.inputs.device_name }}"
          path: /tmp/build-artifacts/source-archive/
          retention-days: 7
      
      # 步骤 3: 详细检查编译器文件目录状态
      - name: "3. 详细检查编译器文件目录状态"
        run: |
          echo "=== 步骤 3: 详细检查编译器文件目录状态 ==="
          COMPILER_DIR="${{ env.COMPILER_DIR }}"
          
          echo "📁 编译器目录路径: $COMPILER_DIR"
          echo "📁 工作区路径: ${{ github.workspace }}"
          
          # 检查目录是否存在
          if [ -d "$COMPILER_DIR" ]; then
            echo "✅ 编译器文件目录存在"
            
            # 详细显示目录信息
            echo "📊 编译器目录详细信息:"
            
            # 显示目录结构
            echo "📁 目录结构:"
            find "$COMPILER_DIR" -maxdepth 3 -type d 2>/dev/null | sort | while read dir; do
              depth=$(echo "$dir" | tr -cd '/' | wc -c)
              depth=$((depth - $(echo "$COMPILER_DIR" | tr -cd '/' | wc -c) - 1))
              if [ $depth -ge 0 ]; then
                indent=$(printf "%${depth}s" "")
                dir_name=$(basename "$dir")
                echo "$indent📁 $dir_name"
              fi
            done || echo "无法列出目录结构"
            
            # 检查预编译编译器（新结构）
            if [ -d "$COMPILER_DIR/compilers" ]; then
              echo "🎯 找到预编译编译器: compilers/"
              compiled_size=$(du -sh "$COMPILER_DIR/compilers" 2>/dev/null | cut -f1 || echo "未知")
              
              echo "📦 预编译编译器总大小: $compiled_size"
              
              # 检查支持的架构
              echo "🔍 检查支持的编译器架构:"
              ARCH_FOUND=false
              
              # 检查arm_cortex-a7架构（用于ipq40xx平台）
              if [ -d "$COMPILER_DIR/compilers/arm_cortex-a7" ]; then
                echo "  ✅ 找到ARM Cortex-A7架构编译器"
                if [ -d "$COMPILER_DIR/compilers/arm_cortex-a7/musl" ]; then
                  echo "    ✅ 找到musl C库版本"
                  arm_size=$(du -sh "$COMPILER_DIR/compilers/arm_cortex-a7/musl" 2>/dev/null | cut -f1 || echo "未知")
                  echo "    📦 大小: $arm_size"
                  ARCH_FOUND=true
                fi
              fi
              
              # 检查mips架构（用于ramips平台）
              if [ -d "$COMPILER_DIR/compilers/mips" ]; then
                echo "  ✅ 找到MIPS架构编译器"
                if [ -d "$COMPILER_DIR/compilers/mips/musl" ]; then
                  echo "    ✅ 找到musl C库版本"
                  mips_size=$(du -sh "$COMPILER_DIR/compilers/mips/musl" 2>/dev/null | cut -f1 || echo "未知")
                  echo "    📦 大小: $mips_size"
                  ARCH_FOUND=true
                fi
              fi
              
              if [ "$ARCH_FOUND" = true ]; then
                echo "🎉 找到可用的预编译编译器架构"
                echo "💡 将根据目标平台选择合适的编译器"
              else
                echo "⚠️ 未找到支持的编译器架构"
                echo "💡 将使用内置的编译器构建流程"
              fi
            else
              echo "⚠️ 未找到预编译编译器目录 (compilers/)"
              echo "💡 将使用内置的编译器构建流程"
            fi
            
            # 不再检查编译器源代码
            echo "ℹ️ 跳过编译器源代码检查（不需要）"
            
          else
            echo "❌ 编译器文件目录不存在"
            echo "💡 将使用内置的编译器构建流程"
          fi
          
          # 总结
          echo ""
          echo "📊 编译器状态总结:"
          if [ -d "$COMPILER_DIR/compilers/arm_cortex-a7/musl" ] || [ -d "$COMPILER_DIR/compilers/mips/musl" ]; then
            echo "✅ 状态: 预编译编译器可用"
            echo "💡 将使用预编译编译器加速构建"
          else
            echo "⚠️ 状态: 无预编译编译器"
            echo "💡 将使用内置的编译器构建流程"
          fi
      
      # 步骤 4: 初始空间检查
      - name: "4. 初始空间检查"
        run: |
          echo "=== 步骤 4: 初始磁盘空间检查 ==="
          echo "📊 磁盘使用情况:"
          df -h
          
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo ""
          echo "📈 空间分析:"
          echo "  /mnt 可用空间: ${AVAILABLE_GB}G"
          echo "  构建目录: ${{ env.BUILD_DIR }}"
          
          if [ $AVAILABLE_GB -lt 50 ]; then
            echo "❌ 错误: /mnt 空间不足50G"
            echo "💡 建议: 至少需要50G空间用于完整构建"
            exit 1
          elif [ $AVAILABLE_GB -lt 100 ]; then
            echo "⚠️ 警告: /mnt 空间低于100G，可能影响大型构建"
            echo "✅ 但仍可继续构建"
          else
            echo "✅ 空间充足，可以开始构建"
          fi
          
          # 检查内存
          echo ""
          echo "🧠 内存使用情况:"
          free -h
          TOTAL_MEM=$(free -m | awk '/^Mem:/{print $2}')
          echo "  总内存: ${TOTAL_MEM}MB"
          
          if [ $TOTAL_MEM -lt 2048 ]; then
            echo "⚠️ 警告: 内存低于2GB，编译速度可能较慢"
          fi
          
          # CPU信息
          echo ""
          echo "⚡ CPU信息:"
          CPU_CORES=$(nproc)
          echo "  CPU核心数: $CPU_CORES"
          
          echo "✅ 初始空间检查通过"
      
      # 步骤 5: 设置编译环境和构建目录
      - name: "5. 设置编译环境和构建目录"
        run: |
          echo "=== 步骤 5: 设置编译环境和构建目录 ==="
          
          echo "🔄 步骤 5.1: 设置编译环境"
          firmware-config/scripts/build_firmware_main.sh setup_environment
          
          echo "🔄 步骤 5.2: 创建构建目录"
          firmware-config/scripts/build_firmware_main.sh create_build_dir
          
          echo "🔄 步骤 5.3: 初始化构建环境"
          echo "📋 构建参数:"
          echo "  设备: ${{ github.event.inputs.device_name }}"
          echo "  版本: ${{ github.event.inputs.version_selection }}"
          echo "  配置模式: ${{ github.event.inputs.config_mode }}"
          
          firmware-config/scripts/build_firmware_main.sh initialize_build_env \
            "${{ github.event.inputs.device_name }}" \
            "${{ github.event.inputs.version_selection }}" \
            "${{ github.event.inputs.config_mode }}"
          
          echo "✅ 编译环境和构建目录设置完成"
      
      # 步骤 6: 添加 TurboACC 支持
      - name: "6. 添加 TurboACC 支持"
        run: |
          echo "=== 步骤 6: 添加 TurboACC 支持 ==="
          firmware-config/scripts/build_firmware_main.sh add_turboacc_support
      
      # 步骤 7: 配置Feeds
      - name: "7. 配置Feeds"
        run: |
          echo "=== 步骤 7: 配置Feeds ==="
          firmware-config/scripts/build_firmware_main.sh configure_feeds
      
      # 步骤 8: 安装 TurboACC 包
      - name: "8. 安装 TurboACC 包"
        if: env.SELECTED_BRANCH == 'openwrt-23.05' && github.event.inputs.config_mode == 'normal'
        run: |
          echo "=== 步骤 8: 安装 TurboACC 包 ==="
          firmware-config/scripts/build_firmware_main.sh install_turboacc_packages
      
      # 步骤 9: 编译前空间检查
      - name: "9. 编译前空间检查"
        run: |
          echo "=== 步骤 9: 编译前空间检查 ==="
          firmware-config/scripts/build_firmware_main.sh pre_build_space_check
      
      # 步骤 10: 智能配置生成（USB完全修复加强版）
      - name: "10. 智能配置生成（USB完全修复加强版）"
        run: |
          echo "=== 步骤 10: 智能配置生成 ==="
          echo "🚨 USB 3.0加强：所有关键USB驱动强制启用"
          firmware-config/scripts/build_firmware_main.sh generate_config "${{ github.event.inputs.extra_packages }}"
      
      # 步骤 11: 验证USB配置
      - name: "11. 验证USB配置"
        run: |
          echo "=== 步骤 11: 验证USB配置 ==="
          firmware-config/scripts/build_firmware_main.sh verify_usb_config
      
      # 步骤 12: USB驱动完整性检查
      - name: "12. USB驱动完整性检查"
        run: |
          echo "=== 步骤 12: USB驱动完整性检查 ==="
          firmware-config/scripts/build_firmware_main.sh check_usb_drivers_integrity
      
      # 步骤 13: 应用配置并显示详情
      - name: "13. 应用配置并显示详情"
        run: |
          echo "=== 步骤 13: 应用配置并显示详情 ==="
          
          # 先保存原始配置文件
          if [ -f "${{ env.BUILD_DIR }}/.config" ]; then
            cp "${{ env.BUILD_DIR }}/.config" "${{ env.BUILD_DIR }}/.config.original"
            echo "✅ 已备份原始配置文件"
          fi
          
          # 应用配置
          firmware-config/scripts/build_firmware_main.sh apply_config
          
          # 检查应用后的配置状态
          echo "=== 插件配置状态检查 ==="
          cd "${{ env.BUILD_DIR }}"
          
          # 定义正常模式的完整插件列表
          declare -A normal_plugins
          normal_plugins["TurboACC 网络加速"]="luci-app-turboacc"
          normal_plugins["UPnP 自动端口转发"]="luci-app-upnp"
          normal_plugins["Samba 文件共享"]="luci-app-samba4"
          normal_plugins["磁盘管理"]="luci-app-diskman"
          normal_plugins["KMS 激活服务"]="luci-app-vlmcsd"
          normal_plugins["SmartDNS 智能DNS"]="luci-app-smartdns"
          normal_plugins["家长控制"]="luci-app-accesscontrol"
          normal_plugins["微信推送"]="luci-app-wechatpush"
          normal_plugins["流量控制 (SQM)"]="luci-app-sqm"
          normal_plugins["FTP 服务器"]="luci-app-vsftpd"
          normal_plugins["ARP 绑定"]="luci-app-arpbind"
          normal_plugins["CPU 限制"]="luci-app-cpulimit"
          normal_plugins["硬盘休眠"]="luci-app-hd-idle"
          
          echo "📋 正常模式插件状态检查:"
          
          total_plugins=0
          enabled_plugins=0
          disabled_plugins=0
          
          for plugin_name in "${!normal_plugins[@]}"; do
            plugin_config="${normal_plugins[$plugin_name]}"
            total_plugins=$((total_plugins + 1))
            
            if grep -q "^CONFIG_PACKAGE_${plugin_config}=y" .config; then
              echo "  ✅ $plugin_name: 已启用"
              enabled_plugins=$((enabled_plugins + 1))
            elif grep -q "^# CONFIG_PACKAGE_${plugin_config} is not set$" .config; then
              echo "  ❌ $plugin_name: 已禁用"
              disabled_plugins=$((disabled_plugins + 1))
            else
              echo "  ⚠️  $plugin_name: 未配置"
            fi
          done
          
          echo ""
          echo "📊 插件状态统计:"
          echo "  总计: $total_plugins 个插件"
          echo "  已启用: $enabled_plugins 个"
          echo "  已禁用: $disabled_plugins 个"
          
          # 检查基础模式是否禁用了插件
          if [ "${{ github.event.inputs.config_mode }}" = "base" ]; then
            echo ""
            echo "🔧 基础模式配置确认:"
            if [ $enabled_plugins -eq 0 ]; then
              echo "  ✅ 基础模式: 所有额外插件已正确禁用"
            else
              echo "  ⚠️  基础模式: 有 $enabled_plugins 个插件未禁用，需要检查"
            fi
          fi
          
          # 额外检查USB驱动状态
          echo ""
          echo "🔌 USB驱动状态确认:"
          critical_usb_drivers=("kmod-usb-xhci-hcd" "kmod-usb3" "kmod-usb-dwc3" "kmod-usb-storage" "kmod-scsi-core")
          for driver in "${critical_usb_drivers[@]}"; do
            if grep -q "^CONFIG_PACKAGE_${driver}=y" .config; then
              echo "  ✅ $driver: 已启用"
            else
              echo "  ❌ $driver: 未启用 (需要修复)"
            fi
          done
          
          echo "✅ 配置详情检查完成"
      
      # 步骤 14: 检查并备份配置文件
      - name: "14. 检查并备份配置文件"
        run: |
          echo "=== 步骤 14: 检查并备份配置文件 ==="
          
          # 检查配置文件
          if [ -f "${{ env.BUILD_DIR }}/.config" ]; then
            echo "✅ .config 文件存在"
            
            # 确保备份目录存在
            mkdir -p firmware-config/config-backup
            
            # 备份到仓库目录
            backup_file="firmware-config/config-backup/config_${{ github.event.inputs.device_name }}_${{ env.SELECTED_BRANCH }}_${{ github.event.inputs.config_mode }}_$(date +%Y%m%d_%H%M%S).config"
            
            cp "${{ env.BUILD_DIR }}/.config" "$backup_file"
            echo "✅ 配置文件备份到仓库目录: $backup_file"
            
            # 显示备份文件信息
            echo "备份文件大小: $(ls -lh $backup_file | awk '{print $5}')"
            echo "备份文件内容预览:"
            head -20 "$backup_file"
          else
            echo "❌ .config 文件不存在"
            exit 1
          fi
      
      # 步骤 15: 修复网络环境
      - name: "15. 修复网络环境"
        run: |
          echo "=== 步骤 15: 修复网络环境 ==="
          firmware-config/scripts/build_firmware_main.sh fix_network
      
      # 步骤 16: 下载依赖包
      - name: "16. 下载依赖包"
        run: |
          echo "=== 步骤 16: 下载依赖包 ==="
          firmware-config/scripts/build_firmware_main.sh download_dependencies
      
      # 步骤 17: 集成自定义文件
      - name: "17. 集成自定义文件"
        run: |
          echo "=== 步骤 17: 集成自定义文件 ==="
          firmware-config/scripts/build_firmware_main.sh integrate_custom_files
      
      # 步骤 18: 前置错误检查（修正编译器检查逻辑）
      - name: "18. 前置错误检查"
        run: |
          echo "=== 步骤 18: 前置错误检查 ==="
          
          # 先显示编译器文件状态
          echo "🔍 详细检查交叉编译器状态:"
          COMPILER_DIR="${{ env.COMPILER_DIR }}"
          
          echo "📁 编译器目录: $COMPILER_DIR"
          
          # 检查预编译的编译器（新结构）
          if [ -d "$COMPILER_DIR/compilers" ]; then
            echo "🎯 找到预编译编译器目录: compilers/"
            
            # 根据目标平台检查对应的编译器
            if [ "${{ env.TARGET }}" = "ipq40xx" ]; then
              echo "🔧 检测到IPQ40xx平台（ARM Cortex-A7架构）"
              if [ -d "$COMPILER_DIR/compilers/arm_cortex-a7" ]; then
                echo "✅ 找到ARM Cortex-A7架构编译器"
                if [ -d "$COMPILER_DIR/compilers/arm_cortex-a7/musl" ]; then
                  echo "✅ 找到musl C库版本"
                  COMPILER_OUTPUT_DIR="$COMPILER_DIR/compilers/arm_cortex-a7/musl"
                  echo "📁 编译器路径: $COMPILER_OUTPUT_DIR"
                  
                  # 检查关键文件
                  echo "🔧 检查关键编译器文件:"
                  REQUIRED_FILES=("bin/arm-openwrt-linux-muslgnueabi-gcc" "bin/arm-openwrt-linux-muslgnueabi-g++" "bin/arm-openwrt-linux-muslgnueabi-ld" "bin/arm-openwrt-linux-muslgnueabi-ar" "bin/arm-openwrt-linux-muslgnueabi-strip")
                  
                  missing_files=0
                  for file in "${REQUIRED_FILES[@]}"; do
                    if [ -f "$COMPILER_OUTPUT_DIR/$file" ]; then
                      file_size=$(du -h "$COMPILER_OUTPUT_DIR/$file" 2>/dev/null | cut -f1)
                      echo "  ✅ $file: 存在 ($file_size)"
                    else
                      echo "  ❌ $file: 缺失"
                      missing_files=$((missing_files + 1))
                    fi
                  done
                  
                  if [ $missing_files -eq 0 ]; then
                    echo "🎉 ARM Cortex-A7编译器完整可用！"
                    
                    # 测试编译器功能
                    echo "🔧 测试编译器功能..."
                    if [ -x "$COMPILER_OUTPUT_DIR/bin/arm-openwrt-linux-muslgnueabi-gcc" ]; then
                      test_output=$("$COMPILER_OUTPUT_DIR/bin/arm-openwrt-linux-muslgnueabi-gcc" --version 2>&1 | head -1)
                      echo "  ✅ 编译器工作正常"
                      echo "  📋 版本信息: $test_output"
                    fi
                  else
                    echo "⚠️ ARM Cortex-A7编译器缺失 $missing_files 个关键文件"
                  fi
                fi
              fi
            elif [ "${{ env.TARGET }}" = "ramips" ]; then
              echo "🔧 检测到RAMIPS平台（MIPS架构）"
              if [ -d "$COMPILER_DIR/compilers/mips" ]; then
                echo "✅ 找到MIPS架构编译器"
                if [ -d "$COMPILER_DIR/compilers/mips/musl" ]; then
                  echo "✅ 找到musl C库版本"
                  COMPILER_OUTPUT_DIR="$COMPILER_DIR/compilers/mips/musl"
                  echo "📁 编译器路径: $COMPILER_OUTPUT_DIR"
                  
                  # 检查MIPS架构的编译器文件（文件名可能不同）
                  echo "🔧 检查MIPS编译器文件..."
                  if find "$COMPILER_OUTPUT_DIR/bin" -name "*mips*" -o -name "*mipsel*" 2>/dev/null | head -5; then
                    echo "✅ 找到MIPS编译器文件"
                  else
                    echo "⚠️ MIPS编译器文件可能不完整"
                  fi
                fi
              fi
            fi
          else
            echo "⚠️ 未找到预编译编译器目录 (compilers/)"
            echo "💡 将使用内置的编译器构建流程"
          fi
          
          # 不再检查编译器源代码
          echo "ℹ️ 跳过编译器源代码检查（不需要）"
          
          echo ""
          echo "🔧 执行前置错误检查脚本..."
          firmware-config/scripts/build_firmware_main.sh pre_build_error_check
      
      # 步骤 19: 编译固件前的空间检查
      - name: "19. 编译固件前的空间检查"
        run: |
          echo "=== 步骤 19: 编译固件前的空间检查 ==="
          echo "📊 编译前磁盘使用情况:"
          df -h
          
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo ""
          echo "📈 空间分析:"
          echo "  /mnt 可用空间: ${AVAILABLE_GB}G"
          echo "  构建目录大小: $(du -sh ${{ env.BUILD_DIR }} 2>/dev/null | cut -f1 || echo '未知')"
          
          # 检查编译所需空间
          if [ $AVAILABLE_GB -lt 10 ]; then
            echo "❌ 错误: 编译前空间不足 (需要至少10G，当前${AVAILABLE_GB}G)"
            echo "💡 建议: 清理空间或使用更大的磁盘"
            exit 1
          elif [ $AVAILABLE_GB -lt 20 ]; then
            echo "⚠️ 警告: 编译前空间较低 (建议至少20G，当前${AVAILABLE_GB}G)"
            echo "✅ 但仍可继续编译"
          else
            echo "✅ 编译前空间充足"
          fi
      
      # 步骤 20: 智能编译固件（支持新编译器结构）
      - name: "20. 智能编译固件"
        run: |
          echo "=== 步骤 20: 智能编译固件 ==="
          
          COMPILER_DIR="${{ env.COMPILER_DIR }}"
          BUILD_DIR="${{ env.BUILD_DIR }}"
          
          echo "🔧 智能编译器管理流程:"
          echo "1. 检查预编译编译器可用性（新结构）"
          echo "2. 如果可用，根据目标平台选择合适的编译器"
          echo "3. 如果不可用，使用标准构建流程"
          echo "4. 编译固件"
          
          # 1. 检查预编译编译器是否可用
          cd "$BUILD_DIR"
          COMPILER_USABLE=false
          COMPILER_SELECTED=""
          
          if [ -d "$COMPILER_DIR/compilers" ]; then
            echo "🔍 检查预编译编译器架构..."
            
            # 根据目标平台选择编译器
            if [ "${{ env.TARGET }}" = "ipq40xx" ]; then
              echo "🎯 目标平台: IPQ40xx (ARM Cortex-A7)"
              if [ -d "$COMPILER_DIR/compilers/arm_cortex-a7/musl" ]; then
                COMPILER_SELECTED="$COMPILER_DIR/compilers/arm_cortex-a7/musl"
                echo "✅ 选择ARM Cortex-A7编译器: $COMPILER_SELECTED"
                
                # 检查关键文件
                REQUIRED_FILES=("bin/arm-openwrt-linux-muslgnueabi-gcc" "bin/arm-openwrt-linux-muslgnueabi-g++")
                
                missing_files=0
                for file in "${REQUIRED_FILES[@]}"; do
                  if [ ! -f "$COMPILER_SELECTED/$file" ]; then
                    missing_files=$((missing_files + 1))
                  fi
                done
                
                if [ $missing_files -eq 0 ]; then
                  COMPILER_USABLE=true
                  echo "✅ ARM Cortex-A7编译器完整可用"
                else
                  echo "❌ ARM Cortex-A7编译器缺失 $missing_files 个关键文件"
                fi
              fi
            elif [ "${{ env.TARGET }}" = "ramips" ]; then
              echo "🎯 目标平台: RAMIPS (MIPS)"
              if [ -d "$COMPILER_DIR/compilers/mips/musl" ]; then
                COMPILER_SELECTED="$COMPILER_DIR/compilers/mips/musl"
                echo "✅ 选择MIPS编译器: $COMPILER_SELECTED"
                
                # 检查是否有MIPS编译器文件
                if find "$COMPILER_SELECTED/bin" -name "*mips*" 2>/dev/null | head -1; then
                  COMPILER_USABLE=true
                  echo "✅ MIPS编译器可用"
                else
                  echo "❌ MIPS编译器文件不完整"
                fi
              fi
            fi
          else
            echo "❌ 未找到预编译编译器目录"
          fi
          
          # 2. 如果预编译编译器可用，复制到构建目录
          if [ "$COMPILER_USABLE" = true ] && [ -n "$COMPILER_SELECTED" ]; then
            echo "🚀 使用预编译的交叉编译器加速构建..."
            
            # 备份当前staging_dir（如果有）
            if [ -d "staging_dir" ]; then
              echo "📦 备份现有staging_dir..."
              mv staging_dir staging_dir.backup.$(date +%s) 2>/dev/null || true
            fi
            
            # 创建新的staging_dir
            mkdir -p staging_dir
            
            # 复制编译器到staging_dir
            echo "📁 复制预编译编译器到构建目录..."
            
            # 创建toolchain目录结构
            mkdir -p staging_dir/toolchain-custom
            
            # 复制整个编译器目录
            cp -r "$COMPILER_SELECTED"/* staging_dir/toolchain-custom/ 2>/dev/null || true
            
            # 验证复制结果
            if [ -d "staging_dir/toolchain-custom/bin" ]; then
              echo "✅ 预编译编译器已复制到构建目录"
              echo "📁 staging_dir/toolchain-custom内容:"
              ls -la staging_dir/toolchain-custom/bin/ 2>/dev/null | head -10 || echo "无法列出"
              
              # 设置环境变量指向自定义编译器
              export STAGING_DIR="$BUILD_DIR/staging_dir"
              echo "💡 已设置STAGING_DIR环境变量"
            else
              echo "⚠️ 编译器复制可能不完整"
            fi
            
            echo "💡 预编译编译器已就绪，将显著加快构建速度"
          else
            echo "⚠️ 预编译编译器不可用，将使用标准构建流程"
            echo "💡 编译器会在构建过程中自动编译"
          fi
          
          # 3. 开始编译固件
          echo "🔨 开始编译固件..."
          
          # 获取CPU核心数
          cpu_cores=$(nproc)
          make_jobs=$cpu_cores
          
          # 如果内存小于4GB，减少并行任务
          total_mem=$(free -m | awk '/^Mem:/{print $2}')
          if [ $total_mem -lt 4096 ]; then
            make_jobs=$((cpu_cores / 2))
            if [ $make_jobs -lt 1 ]; then
              make_jobs=1
            fi
            echo "⚠️ 内存较低(${total_mem}MB)，减少并行任务到 $make_jobs"
          fi
          
          # 显示编译参数
          echo "⚙️ 编译参数:"
          echo "  并行任务数: $make_jobs"
          echo "  详细输出: 启用"
          echo "  编译器缓存: 启用"
          
          # 启用编译缓存，使用并行编译
          echo "使用 $make_jobs 个并行任务进行编译..."
          firmware-config/scripts/build_firmware_main.sh build_firmware "true"
          
          echo "✅ 智能编译完成"
      
      # 步骤 21-27 保持不变...
      # 由于篇幅限制，这里省略步骤21-27，它们与之前的版本相同
      # 只需要保持原有的步骤21-27代码即可

      - name: "21. 搜索并打包构建产物"
        if: success()
        run: |
          echo "=== 步骤 21: 搜索并打包构建产物 ==="
          cd ${{ env.BUILD_DIR }}
          
          mkdir -p /tmp/build-artifacts
          
          echo "🔍 搜索构建产物..."
          
          if [ -d "bin/targets" ]; then
            echo "📦 打包固件文件..."
            
            echo "📋 找到的固件文件:"
            find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.gz" -o -name "*.tar" \) 2>/dev/null | while read file; do
              file_size=$(du -h "$file" 2>/dev/null | cut -f1)
              echo "  📄 $file ($file_size)"
            done
            
            total_size=0
            while read size; do
              total_size=$((total_size + size))
            done < <(find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.gz" -o -name "*.tar" \) -exec stat -c%s {} \; 2>/dev/null)
            
            if [ $total_size -gt 0 ]; then
              total_size_mb=$((total_size / 1024 / 1024))
              echo "📊 固件总大小: ${total_size_mb}MB"
              
              tar -czf /tmp/build-artifacts/firmware.tar.gz -C bin targets/
              
              firmware_archive_size=$(du -h /tmp/build-artifacts/firmware.tar.gz | cut -f1)
              echo "✅ 固件打包完成，归档大小: $firmware_archive_size"
            else
              echo "⚠️ 未找到固件文件"
            fi
          else
            echo "⚠️ bin/targets目录不存在"
          fi
          
          if [ -f "build.log" ]; then
            echo "📝 打包编译日志..."
            cp build.log /tmp/build-artifacts/build.log
            log_size=$(du -h build.log | cut -f1)
            echo "✅ 日志打包完成，大小: $log_size"
          fi
          
          if [ -f "download.log" ]; then
            echo "📥 打包下载日志..."
            cp download.log /tmp/build-artifacts/download.log
          fi
          
          echo "📋 创建构建信息文件..."
          echo "=== OpenWrt固件构建信息 ===" > /tmp/build-artifacts/build-info.txt
          echo "" >> /tmp/build-artifacts/build-info.txt
          echo "📅 构建时间: $(date)" >> /tmp/build-artifacts/build-info.txt
          echo "🏷️ 设备: ${{ env.DEVICE }}" >> /tmp/build-artifacts/build-info.txt
          echo "🔄 版本: ${{ env.SELECTED_BRANCH }}" >> /tmp/build-artifacts/build-info.txt
          echo "🎯 目标平台: ${{ env.TARGET }}/${{ env.SUBTARGET }}" >> /tmp/build-artifacts/build-info.txt
          echo "⚙️ 配置模式: ${{ github.event.inputs.config_mode }}" >> /tmp/build-artifacts/build-info.txt
          echo "📁 构建目录: ${{ env.BUILD_DIR }}" >> /tmp/build-artifacts/build-info.txt
          echo "" >> /tmp/build-artifacts/build-info.txt
          echo "📦 构建产物:" >> /tmp/build-artifacts/build-info.txt
          find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
            file_name=$(basename "$file")
            file_size=$(du -h "$file" 2>/dev/null | cut -f1)
            echo "  - $file_name ($file_size)" >> /tmp/build-artifacts/build-info.txt
          done
          echo "" >> /tmp/build-artifacts/build-info.txt
          echo "🔧 编译器使用:" >> /tmp/build-artifacts/build-info.txt
          if [ -d "${{ env.COMPILER_DIR }}/compilers" ]; then
            echo "  ✅ 使用了预编译编译器" >> /tmp/build-artifacts/build-info.txt
            echo "  📁 编译器目录: ${{ env.COMPILER_DIR }}/compilers" >> /tmp/build-artifacts/build-info.txt
          else
            echo "  🔨 从源代码编译了编译器" >> /tmp/build-artifacts/build-info.txt
          fi
          echo "" >> /tmp/build-artifacts/build-info.txt
          echo "🎉 构建完成!" >> /tmp/build-artifacts/build-info.txt
          
          echo "✅ 构建信息文件创建完成"
          
          echo ""
          echo "📤 最终构建产物:"
          ls -lh /tmp/build-artifacts/

      - name: "22. 上传固件原始目录"
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: "firmware-${{ github.event.inputs.device_name }}-${{ env.SELECTED_BRANCH }}-${{ github.event.inputs.config_mode }}"
          path: ${{ env.BUILD_DIR }}/bin/targets/
          retention-days: 7

      - name: "23. 上传配置文件"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: "config-${{ github.event.inputs.device_name }}-${{ env.SELECTED_BRANCH }}-${{ github.event.inputs.config_mode }}"
          path: ${{ github.workspace }}/firmware-config/config-backup/
          retention-days: 7

      - name: "24. 上传构建产物包"
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: "build-artifacts-${{ github.event.inputs.device_name }}"
          path: /tmp/build-artifacts/
          retention-days: 7

      - name: "25. 错误分析"
        if: always()
        run: |
          echo "=== 步骤 25: 错误分析 ==="
          if [ -f "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh" ]; then
            firmware-config/scripts/error_analysis.sh
          else
            echo "ℹ️ 错误分析脚本不存在，跳过此步骤"
          fi

      - name: "26. 编译后空间检查"
        if: always()
        run: |
          echo "=== 步骤 26: 编译后空间检查 ==="
          firmware-config/scripts/build_firmware_main.sh post_build_space_check

      - name: "27. 显示最终构建成果"
        if: success()
        run: |
          echo "=== 步骤 27: 最终构建成果总结 ==="
          echo ""
          echo "🎉 🎉 🎉 固件构建成功完成！ 🎉 🎉 🎉"
          echo ""
          
          echo "📊 构建参数:"
          echo "  📱 设备: ${{ env.DEVICE }}"
          echo "  🏷️ 版本: ${{ env.SELECTED_BRANCH }}"
          echo "  🎯 平台: ${{ env.TARGET }}/${{ env.SUBTARGET }}"
          echo "  ⚙️ 模式: ${{ github.event.inputs.config_mode }}"
          echo ""
          
          echo "📦 生成的文件:"
          cd ${{ env.BUILD_DIR }}
          if [ -d "bin/targets" ]; then
            find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
              file_name=$(basename "$file")
              file_path=$(dirname "$file")
              file_size=$(du -h "$file" 2>/dev/null | cut -f1)
              file_date=$(stat -c "%y" "$file" 2>/dev/null | cut -d' ' -f1)
              echo "  📄 $file_name"
              echo "    📁 路径: $file_path/"
              echo "    📦 大小: $file_size"
              echo "    📅 日期: $file_date"
              echo ""
            done
            
            firmware_count=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            total_size=0
            while read size; do
              total_size=$((total_size + size))
            done < <(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) -exec stat -c%s {} \; 2>/dev/null)
            
            if [ $total_size -gt 0 ]; then
              total_size_mb=$((total_size / 1024 / 1024))
              echo "📊 统计:"
              echo "  固件数量: $firmware_count 个"
              echo "  总大小: ${total_size_mb}MB"
            fi
          else
            echo "  ⚠️ 未找到固件文件"
          fi
          
          echo ""
          echo "📤 产物上传:"
          echo "  ✅ 固件文件已上传到Artifacts"
          echo "  ✅ 配置文件已备份"
          echo "  ✅ 构建日志已保存"
          echo ""
          
          echo "🔧 构建详情:"
          echo "  查看Artifacts获取完整构建产物"
          echo "  查看日志了解详细构建过程"
          echo ""
          
          echo "🚀 下一步:"
          echo "  1. 下载生成的固件文件"
          echo "  2. 刷入路由器设备"
          echo "  3. 享受新固件的功能！"
          echo ""
          
          echo "✅ 构建流程全部完成！"

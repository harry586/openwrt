name: OpenWrt 智能固件构建工作流

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: '设备名称 (如: ac42u, ac58u, mi4a 等)'
        required: true
        default: 'ac42u'
        type: string
      version_spec:
        description: '版本规格 (可选，如: openwrt-23.05 或 immortalwrt:master)'
        required: false
        type: string
        default: ''
      config_type:
        description: '配置类型 (minimal:基础功能, normal:完整功能, custom:自定义)'
        required: true
        default: 'normal'
        type: choice
        options:
        - minimal
        - normal
        - custom
      extra_packages:
        description: '额外安装插件 (空格分隔的包名)'
        required: false
        type: string
      disabled_plugins:
        description: '禁用插件 (空格分隔的包名，如: luci-app-accesscontrol luci-app-ddns)'
        required: false
        type: string
        default: ''
      save_config:
        description: '保存配置文件到仓库'
        required: false
        default: true
        type: boolean
      enable_cache:
        description: '启用编译缓存 (显著加速后续编译)'
        required: false
        default: true
        type: boolean
      multithreading:
        description: '开启多线程编译'
        type: boolean
        default: true
      ssh_connection:
        description: '使用 SSH 连接到编译环境进行调试'
        type: boolean
        default: false

env:
  BUILD_DIR: /mnt/openwrt-build
  MIRROR_SOURCE: tuna
  CUSTOM_INSTALL: true

jobs:
  build-firmware:
    if: ${{ inputs.ssh_connection == false }}
    runs-on: ubuntu-22.04
    
    steps:
    - name: 初始空间检查
      run: |
        echo "=== 初始磁盘空间检查 ==="
        df -h
        AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
        AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
        echo "/mnt 可用空间: ${AVAILABLE_GB}G"
        if [ $AVAILABLE_GB -lt 50 ]; then
          echo "错误: /mnt 空间不足50G"
          exit 1
        fi

    - name: 检出配置仓库
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 设置编译环境
      run: |
        echo "=== 安装编译依赖包 ==="
        sudo apt-get update
        sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential clang flex bison g++ gawk gcc-multilib g++-multilib gettext git libncurses5-dev libssl-dev python3-distutils rsync unzip zlib1g-dev file wget libelf-dev ecj fastjar java-propose-classpath libpython3-dev python3 python3-dev python3-pip python3-setuptools python3-yaml xsltproc zip subversion ninja-build automake autoconf libtool pkg-config help2man texinfo aria2 liblz4-dev zstd libcurl4-openssl-dev groff texlive texinfo
        pip3 install requests urllib3
        echo "✅ 编译环境设置完成"

    - name: 创建构建目录并设置权限
      run: |
        echo "=== 创建构建目录 ==="
        sudo mkdir -p $BUILD_DIR
        sudo chown -R $USER:$USER $BUILD_DIR
        sudo chmod -R 755 $BUILD_DIR
        sudo chmod u+w $BUILD_DIR
        echo "✅ 构建目录创建完成"
        touch $BUILD_DIR/test_write.txt && echo "✅ 写入测试成功" && rm $BUILD_DIR/test_write.txt

    - name: 复制脚本到构建目录
      run: |
        echo "=== 复制脚本到构建目录 ==="
        cd $GITHUB_WORKSPACE
        SCRIPTS="complete_version_detector.sh device_detection.sh error_analysis.sh pre_download.sh check-plugins.sh diagnose-packages.sh add_turboacc.sh"
        COPIED_COUNT=0
        for script in $SCRIPTS; do
          echo "正在查找: $script"
          FOUND_SCRIPT=$(find . -name "$script" -type f | head -1)
          if [ -n "$FOUND_SCRIPT" ]; then
            cp "$FOUND_SCRIPT" $BUILD_DIR/
            echo "✅ 找到并复制: $script (从 $FOUND_SCRIPT)"
            COPIED_COUNT=$((COPIED_COUNT + 1))
          else
            echo "⚠️ 未找到: $script"
          fi
        done
        echo "总共复制了 $COPIED_COUNT 个脚本文件"
        cd $BUILD_DIR
        echo "构建目录中的脚本:"
        ls -la *.sh 2>/dev/null || echo "没有找到.sh文件"
        chmod +x *.sh 2>/dev/null || true
        echo "✅ 脚本复制完成"

    - name: 验证脚本存在性
      run: |
        cd $BUILD_DIR
        echo "=== 验证脚本存在性 ==="
        echo "构建目录内容:"
        ls -la
        REQUIRED_SCRIPTS="complete_version_detector.sh device_detection.sh"
        ALL_SCRIPTS_EXIST=true
        for script in $REQUIRED_SCRIPTS; do
          if [ -f "$script" ]; then
            echo "✅ $script 存在"
            chmod +x "$script"
          else
            echo "❌ 错误: $script 不存在"
            ALL_SCRIPTS_EXIST=false
          fi
        done
        if [ "$ALL_SCRIPTS_EXIST" = false ]; then
          echo "当前目录中的文件:"
          ls -la
          echo "❌ 关键脚本缺失，构建终止"
          exit 1
        fi

    - name: 智能版本检测
      id: version-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能版本检测 ==="
        sudo chown -R $USER:$USER . 2>/dev/null || true
        chmod u+w . 2>/dev/null || true
        chmod +x *.sh 2>/dev/null || true
        echo "设备名称: ${{ github.event.inputs.device_name }}"
        echo "版本规格: ${{ inputs.version_spec }}"
        if [ ! -f "complete_version_detector.sh" ]; then
          echo "❌ 错误: complete_version_detector.sh 不存在"
          ls -la
          exit 1
        fi
        chmod +x complete_version_detector.sh
        set +e
        OUTPUT=$(./complete_version_detector.sh "${{ github.event.inputs.device_name }}" "${{ inputs.version_spec }}" "" 2>&1)
        SCRIPT_EXIT_CODE=$?
        set -e
        echo "脚本输出:"
        echo "$OUTPUT"
        echo "脚本退出代码: $SCRIPT_EXIT_CODE"
        SELECTED_REPO=$(echo "$OUTPUT" | grep "^SELECTED_REPO=" | head -1 | cut -d'=' -f2)
        SELECTED_BRANCH=$(echo "$OUTPUT" | grep "^SELECTED_BRANCH=" | head -1 | cut -d'=' -f2)
        SELECTED_REPO_URL=$(echo "$OUTPUT" | grep "^SELECTED_REPO_URL=" | head -1 | cut -d'=' -f2)
        if [ -n "$SELECTED_REPO" ] && [ -n "$SELECTED_BRANCH" ] && [ -n "$SELECTED_REPO_URL" ]; then
            echo "✅ 从脚本输出中成功提取版本信息"
            echo "SELECTED_REPO=$SELECTED_REPO" >> $GITHUB_ENV
            echo "SELECTED_BRANCH=$SELECTED_BRANCH" >> $GITHUB_ENV
            echo "SELECTED_REPO_URL=$SELECTED_REPO_URL" >> $GITHUB_ENV
            echo "✅ 环境变量已设置:"
            echo "  仓库: $SELECTED_REPO"
            echo "  分支: $SELECTED_BRANCH"
            echo "  URL: $SELECTED_REPO_URL"
        else
            echo "❌ 无法从脚本输出中提取版本信息"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 版本检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但无法提取版本信息，使用默认值"
                echo "SELECTED_REPO=immortalwrt" >> $GITHUB_ENV
                echo "SELECTED_BRANCH=master" >> $GITHUB_ENV
                echo "SELECTED_REPO_URL=https://github.com/immortalwrt/immortalwrt.git" >> $GITHUB_ENV
                echo "✅ 使用默认版本信息"
            fi
        fi

    - name: 备份检测脚本
      run: |
        echo "=== 备份检测脚本 ==="
        mkdir -p /tmp/build-scripts-backup
        cp $BUILD_DIR/*.sh /tmp/build-scripts-backup/ 2>/dev/null || true
        echo "✅ 脚本备份完成"

    - name: 清理构建目录
      run: |
        cd $BUILD_DIR
        echo "=== 清理构建目录准备克隆 ==="
        ls -la
        sudo rm -rf ./* ./.git* 2>/dev/null || true
        sudo rm -rf .[!.]* 2>/dev/null || true
        ls -la
        echo "✅ 目录清理完成"

    - name: 克隆源码
      run: |
        cd $BUILD_DIR
        echo "=== 克隆选定版本的源码 ==="
        echo "仓库: $SELECTED_REPO_URL"
        echo "分支: $SELECTED_BRANCH"
        if [ -z "$SELECTED_REPO_URL" ] || [ -z "$SELECTED_BRANCH" ]; then
          echo "❌ 错误: 环境变量未正确设置"
          exit 1
        fi
        echo "检查目录状态..."
        FILE_COUNT=$(ls -A | wc -l)
        if [ $FILE_COUNT -ne 0 ]; then
          echo "❌ 错误: 目录非空，无法克隆"
          exit 1
        fi
        MAX_RETRIES=3
        RETRY_COUNT=0
        CLONE_SUCCESS=false
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$CLONE_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "克隆尝试: $RETRY_COUNT/$MAX_RETRIES"
          if git clone --depth 1 --branch "$SELECTED_BRANCH" "$SELECTED_REPO_URL" .; then
            echo "✅ 源码克隆完成"
            CLONE_SUCCESS=true
          else
            echo "❌ 克隆失败，尝试 $RETRY_COUNT/$MAX_RETRIES"
            if echo "$SELECTED_REPO_URL" | grep -q "github.com" && [ $RETRY_COUNT -eq 2 ]; then
              echo "🔄 尝试使用镜像源..."
              MIRROR_URL=$(echo "$SELECTED_REPO_URL" | sed 's/github.com/github.com.cnpmjs.org/')
              rm -rf ./* ./.git* 2>/dev/null || true
              if git clone --depth 1 --branch "$SELECTED_BRANCH" "$MIRROR_URL" .; then
                echo "✅ 使用镜像源克隆成功"
                CLONE_SUCCESS=true
                break
              fi
            fi
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "❌ 源码克隆失败，达到最大重试次数"
              exit 1
            fi
            sleep 10
            rm -rf ./* ./.git* 2>/dev/null || true
          fi
        done

    - name: 恢复检测脚本
      run: |
        cd $BUILD_DIR
        echo "=== 恢复检测脚本 ==="
        cp /tmp/build-scripts-backup/*.sh ./ 2>/dev/null || true
        chmod +x *.sh
        echo "✅ 脚本恢复完成"

    - name: 加强搜索并复制配置文件
      run: |
        cd $BUILD_DIR
        echo "=== 加强搜索并复制配置文件 ==="
        cd $GITHUB_WORKSPACE
        echo "=== 加强搜索配置文件 ==="
        mkdir -p $BUILD_DIR/config-templates
        SEARCH_PATHS=". firmware-config configs firmware-config/configs firmware-config/config-templates"
        CONFIG_FILES="minimal.config normal-new.config normal-old.config"
        for config_file in $CONFIG_FILES; do
          echo "正在加强搜索配置文件: $config_file"
          FOUND_CONFIG=""
          for path in $SEARCH_PATHS; do
            if [ -f "$path/$config_file" ]; then
              FOUND_CONFIG="$path/$config_file"
              echo "✅ 在 $path 找到: $config_file"
              break
            fi
          done
          if [ -z "$FOUND_CONFIG" ]; then
            FOUND_CONFIG=$(find . -name "$config_file" -type f | head -1)
            if [ -n "$FOUND_CONFIG" ]; then
              echo "✅ 使用find找到: $config_file (在 $FOUND_CONFIG)"
            fi
          fi
          if [ -n "$FOUND_CONFIG" ]; then
            cp "$FOUND_CONFIG" $BUILD_DIR/config-templates/
            echo "✅ 复制: $config_file (从 $FOUND_CONFIG)"
          else
            echo "❌ 错误: 未找到配置文件 $config_file"
            echo "当前目录结构:"
            find . -type f -name "*.config" | head -20
            exit 1
          fi
        done
        echo "=== 配置文件复制完成，检查结果 ==="
        echo "config-templates 目录内容:"
        ls -la $BUILD_DIR/config-templates/
        echo "=== 复制脚本文件 ==="
        SCRIPTS="error_analysis.sh pre_download.sh check-plugins.sh diagnose-packages.sh"
        for script in $SCRIPTS; do
          FOUND_SCRIPT=$(find . -name "$script" -type f | head -1)
          if [ -n "$FOUND_SCRIPT" ]; then
            cp "$FOUND_SCRIPT" $BUILD_DIR/
            chmod +x $BUILD_DIR/"$script"
            echo "✅ 复制脚本: $script"
          else
            echo "⚠️ 未找到: $script"
          fi
        done
        echo "✅ 配置文件和脚本复制完成"

    - name: 配置稳定feeds源
      run: |
        cd $BUILD_DIR
        echo "=== 配置稳定feeds源 ==="
        echo "检测到的版本分支: $SELECTED_BRANCH"
        FEEDS_BRANCH="$SELECTED_BRANCH"
        if echo "$SELECTED_BRANCH" | grep -q "openwrt-24.10"; then
            FEEDS_BRANCH="openwrt-24.10"
        elif echo "$SELECTED_BRANCH" | grep -q "openwrt-23.05"; then
            FEEDS_BRANCH="openwrt-23.05"
        elif echo "$SELECTED_BRANCH" | grep -q "openwrt-22.03"; then
            FEEDS_BRANCH="openwrt-22.03"
        elif echo "$SELECTED_BRANCH" | grep -q "openwrt-21.02"; then
            FEEDS_BRANCH="openwrt-21.02"
        else
            echo "⚠️ 未知版本分支，使用默认分支: master"
            FEEDS_BRANCH="master"
        fi
        echo "使用的feeds分支: $FEEDS_BRANCH"
        echo "src-git packages https://github.com/immortalwrt/packages.git;$FEEDS_BRANCH" > feeds.conf.default
        echo "src-git luci https://github.com/immortalwrt/luci.git;$FEEDS_BRANCH" >> feeds.conf.default
        echo "src-git routing https://github.com/openwrt/routing.git;$FEEDS_BRANCH" >> feeds.conf.default
        echo "src-git telephony https://github.com/openwrt/telephony.git;$FEEDS_BRANCH" >> feeds.conf.default
        echo "src-git nikki https://github.com/nikkinikki-org/OpenWrt-nikki.git;main" >> feeds.conf.default
        echo "✅ 稳定feeds配置完成"
        echo "Feeds配置内容:"
        cat feeds.conf.default

    - name: 更新安装feeds
      run: |
        cd $BUILD_DIR
        echo "=== 更新和安装feeds ==="
        ./scripts/feeds update -a
        ./scripts/feeds install -a
        echo "✅ Feeds更新安装完成"

    - name: 设备检测
      id: device-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能设备检测与别名转换 ==="
        INPUT_DEVICE="${{ github.event.inputs.device_name }}"
        echo "输入设备名称: $INPUT_DEVICE"
        case "$INPUT_DEVICE" in
            "ac42u"|"acrh17"|"rt-acrh17") ACTUAL_DEVICE="asus_rt-ac42u" ;;
            "ac58u"|"acrh13"|"rt-ac58u"|"rt-acrh13") ACTUAL_DEVICE="asus_rt-ac58u" ;;
            "mi4a"|"r4a") ACTUAL_DEVICE="xiaomi_mi-router-4a-gigabit" ;;
            "mi3g"|"r3g") ACTUAL_DEVICE="xiaomi_mi-router-3g" ;;
            *) ACTUAL_DEVICE="$INPUT_DEVICE" ;;
        esac
        if [ "$ACTUAL_DEVICE" != "$INPUT_DEVICE" ]; then
          echo "✅ 检测到设备通用名称 '$INPUT_DEVICE'，转换为实际设备标识 '$ACTUAL_DEVICE'"
        else
          echo "ℹ️ 使用原始设备名称: $ACTUAL_DEVICE"
        fi
        if [ ! -f "device_detection.sh" ]; then
          echo "❌ 错误: 设备检测脚本不存在"
          exit 1
        fi
        chmod +x device_detection.sh
        echo "=== 开始设备检测 ==="
        TEMP_LOG=$(mktemp)
        set +e
        ./device_detection.sh "$ACTUAL_DEVICE" 2>&1 | tee "$TEMP_LOG"
        SCRIPT_EXIT_CODE=$?
        set -e
        echo "=== 脚本退出代码: $SCRIPT_EXIT_CODE ==="
        PLATFORM=$(grep "^PLATFORM=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_SHORT_NAME=$(grep "^DEVICE_SHORT_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_FULL_NAME=$(grep "^DEVICE_FULL_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        echo "=== 提取的设备信息 ==="
        echo "平台(PLATFORM): '$PLATFORM'"
        echo "设备短名称(DEVICE_SHORT_NAME): '$DEVICE_SHORT_NAME'"
        echo "设备全名称(DEVICE_FULL_NAME): '$DEVICE_FULL_NAME'"
        rm -f "$TEMP_LOG"
        if [ -n "$PLATFORM" ] && [ -n "$DEVICE_SHORT_NAME" ] && [ -n "$DEVICE_FULL_NAME" ]; then
            echo "✅ 从脚本输出中成功提取设备信息"
            echo "PLATFORM=$PLATFORM" >> $GITHUB_ENV
            echo "DEVICE_SHORT_NAME=$DEVICE_SHORT_NAME" >> $GITHUB_ENV
            echo "DEVICE_FULL_NAME=$DEVICE_FULL_NAME" >> $GITHUB_ENV
        else
            echo "❌ 无法从脚本输出中提取设备信息"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 设备检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但无法提取设备信息，使用备用设备映射"
                case "$ACTUAL_DEVICE" in
                    "asus_rt-ac42u"|"ac42u"|"acrh17"|"rt-acrh17")
                        echo "PLATFORM=ipq40xx" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=asus_rt-ac42u" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    "asus_rt-ac58u"|"ac58u"|"acrh13"|"rt-acrh13")
                        echo "PLATFORM=ipq40xx" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=asus_rt-ac58u" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    "xiaomi_mi-router-4a-gigabit"|"mi4a"|"r4a")
                        echo "PLATFORM=ramips" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=xiaomi_mi-router-4a-gigabit" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    *)
                        echo "❌ 未知设备，无法设置默认值"
                        exit 1
                        ;;
                esac
                echo "✅ 已使用备用设备信息"
            fi
        fi

    - name: 修复配置加载问题 - 预添加所有必要配置
      run: |
        cd $BUILD_DIR
        echo "=== 修复配置加载问题 - 预添加所有必要配置 ==="
        export MAKE_JOBS=1
        echo "🔒 配置阶段使用单线程模式"
        CONFIG_TYPE="${{ inputs.config_type }}"
        echo "配置类型: $CONFIG_TYPE"
        
        if [ "$CONFIG_TYPE" = "minimal" ]; then
            CONFIG_FILE="config-templates/minimal.config"
        elif [ "$CONFIG_TYPE" = "normal" ] || [ "$CONFIG_TYPE" = "custom" ]; then
            IS_OLD_VERSION=0
            case "${{ github.event.inputs.device_name }}" in
                "wr841n"|"wr842n"|"wr941n"|"mr3420"|"ar71xx"*)
                    IS_OLD_VERSION=1
                    echo "✅ 自动判断为老旧设备: ${{ github.event.inputs.device_name }}"
                    ;;
            esac
            
            if echo "$SELECTED_BRANCH" | grep -q -E "19\.07|21\.02|17\.01|lede"; then
                IS_OLD_VERSION=1
                echo "✅ 自动判断为老旧版本: $SELECTED_BRANCH"
            fi
            
            if [ "$SELECTED_REPO" = "lede" ] || [ "$SELECTED_REPO" = "openwrt-19.07" ] || [ "$SELECTED_REPO" = "openwrt-21.02" ]; then
                IS_OLD_VERSION=1
                echo "✅ 自动判断为老旧仓库: $SELECTED_REPO"
            fi
            
            if [ "$IS_OLD_VERSION" -eq 1 ]; then
                CONFIG_FILE="config-templates/normal-old.config"
            else
                CONFIG_FILE="config-templates/normal-new.config"
            fi
        else
            echo "❌ 未知的配置类型: $CONFIG_TYPE"
            exit 1
        fi
        
        echo "=== 选择的配置文件: $CONFIG_FILE ==="
        if [ ! -f "$CONFIG_FILE" ]; then
            echo "❌ 错误: 找不到配置文件 $CONFIG_FILE"
            ls -la config-templates/
            exit 1
        fi
        
        # 第一步：创建基础配置
        echo "=== 创建基础配置 ==="
        echo "# 设备基础配置" > .config
        echo "CONFIG_TARGET_${PLATFORM}=y" >> .config
        echo "CONFIG_TARGET_${PLATFORM}_generic=y" >> .config
        echo "CONFIG_TARGET_${PLATFORM}_generic_DEVICE_${DEVICE_SHORT_NAME}=y" >> .config
        echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config
        echo "CONFIG_TARGET_IMAGES_PAD=y" >> .config
        
        echo "=== 基础配置后的插件状态 ==="
        echo "当前启用的luci插件:"
        grep "^CONFIG_PACKAGE_luci-app" .config | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | sort || echo "无luci插件"
        
        # 第二步：智能追加模板配置
        echo "=== 智能追加模板配置 ==="
        grep -v -E "^CONFIG_TARGET_(ROOTFS_SQUASHFS|IMAGES_GZIP|IMAGES_PAD)=" "$CONFIG_FILE" > /tmp/filtered_config
        cat /tmp/filtered_config >> .config
        rm -f /tmp/filtered_config
        
        echo "=== 追加模板配置后的插件状态 ==="
        echo "当前启用的luci插件:"
        grep "^CONFIG_PACKAGE_luci-app" .config | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | sort || echo "无luci插件"
        
        # 第三步：预添加基础内核配置
        echo "=== 预添加基础内核配置 ==="
        echo "# 基础内核配置" >> .config
        ESSENTIAL_KERNEL_CONFIGS="CONFIG_NF_CONNTRACK=y CONFIG_NF_NAT=y CONFIG_NETFILTER_XTABLES=y CONFIG_IP_NF_IPTABLES=y CONFIG_NET_SCHED=y"
        
        for config in $ESSENTIAL_KERNEL_CONFIGS; do
            echo "$config" >> .config
        done
        echo "✅ 基础内核配置已预添加"
        
        # 第四步：处理用户自定义包
        EXTRA_PACKAGES="${{ inputs.extra_packages }}"
        DISABLED_PLUGINS="${{ inputs.disabled_plugins }}"
        
        if [ -n "$EXTRA_PACKAGES" ]; then
            echo "=== 添加额外插件 ==="
            for pkg in $EXTRA_PACKAGES; do
                echo "添加插件: $pkg"
                sed -i "/# CONFIG_PACKAGE_${pkg} is not set/d" .config
                echo "CONFIG_PACKAGE_${pkg}=y" >> .config
            done
        fi
        
        if [ -n "$DISABLED_PLUGINS" ]; then
            echo "=== 禁用指定插件 ==="
            for pkg in $DISABLED_PLUGINS; do
                echo "禁用插件: $pkg"
                sed -i "/CONFIG_PACKAGE_${pkg}=y/d" .config
                echo "# CONFIG_PACKAGE_${pkg} is not set" >> .config
            done
        fi
        
        # 第五步：清理不需要的插件
        echo "=== 清理不需要的插件 ==="
        UNWANTED_PLUGINS="luci-app-rclone_INCLUDE_rclone-ng luci-app-rclone_INCLUDE_rclone-webui luci-app-timewol luci-app-passwall_INCLUDE_Haproxy luci-app-passwall_INCLUDE_Shadowsocks_Rust_Client luci-app-passwall_INCLUDE_Shadowsocks_Rust_Server luci-app-passwall_INCLUDE_Simple_Obfs luci-app-passwall_INCLUDE_SingBox luci-app-passwall_INCLUDE_V2ray_Geoview luci-app-passwall_INCLUDE_V2ray_Plugin luci-app-passwall_INCLUDE_Xray"
        
        for plugin in $UNWANTED_PLUGINS; do
            if grep -q "CONFIG_PACKAGE_${plugin}=y" .config; then
                echo "🚫 删除插件: $plugin"
                sed -i "/CONFIG_PACKAGE_${plugin}=y/d" .config
                echo "# CONFIG_PACKAGE_${plugin} is not set" >> .config
            fi
        done
        
        echo "=== 清理不需要的插件后的插件状态 ==="
        echo "当前启用的luci插件:"
        grep "^CONFIG_PACKAGE_luci-app" .config | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | sort || echo "无luci插件"
        
        # 运行 defconfig 来验证和调整配置
        echo "=== 运行单线程 defconfig ==="
        make -j1 defconfig
        
        echo "✅ 基础配置加载完成"

    - name: 通过本地脚本安装 turboacc
      run: |
        cd $BUILD_DIR
        echo "=== 通过本地脚本安装 turboacc ==="
        echo "平台: $PLATFORM"
        echo "设备: $DEVICE_SHORT_NAME"
        
        # 根据平台判断是否支持 turboacc
        SUPPORT_SHORTCUT_FE=1
        case "$PLATFORM" in
            "ipq40xx"|"ipq806x"|"mediatek"|"ramips"|"ath79"|"rockchip")
                echo "✅ 平台 $PLATFORM 支持 turboacc，开始安装..."
                ;;
            "ar71xx"|"brcm47xx"|"brcm63xx"|"lantiq"|"oxnas"|"gemini")
                SUPPORT_SHORTCUT_FE=0
                echo "❌ 平台 $PLATFORM 不支持 turboacc，跳过安装"
                exit 0
                ;;
            *)
                echo "⚠️ 未知平台 $PLATFORM，尝试安装 turboacc"
                ;;
        esac
        
        # 检查版本兼容性
        if echo "$SELECTED_BRANCH" | grep -q -E "19\.07|21\.02"; then
            echo "⚠️ 版本 $SELECTED_BRANCH 可能对 turboacc 支持有限，但仍尝试安装"
        fi
        
        echo "=== 使用本地 turboacc 安装脚本 ==="
        
        if [ -f "add_turboacc.sh" ]; then
            echo "✅ 找到本地 turboacc 安装脚本"
            chmod +x add_turboacc.sh
            
            echo "=== 开始执行 turboacc 安装脚本 ==="
            set +e
            ./add_turboacc.sh
            SCRIPT_EXIT_CODE=$?
            set -e
            
            if [ $SCRIPT_EXIT_CODE -eq 0 ]; then
                echo "✅ turboacc 安装脚本执行成功"
            else
                echo "❌ turboacc 安装脚本执行失败，退出代码: $SCRIPT_EXIT_CODE"
                echo "🔄 启用替代加速方案 (BBR)"
                ALTERNATIVE_ACCELERATION="
                CONFIG_PACKAGE_kmod-tcp-bbr=y
                CONFIG_PACKAGE_kmod-nft-offload=y
                CONFIG_PACKAGE_kmod-nft-fastnet=y
                CONFIG_PACKAGE_kmod-nft-core=y
                CONFIG_PACKAGE_kmod-nft-nat=y
                CONFIG_PACKAGE_kmod-ipt-filter=y
                CONFIG_PACKAGE_iptables-mod-conntrack-extra=y
                CONFIG_PACKAGE_iptables-mod-ipopt=y
                "
                
                for config in $ALTERNATIVE_ACCELERATION; do
                    echo "$config" >> .config
                done
                echo "✅ 替代加速方案已启用"
            fi
        else
            echo "❌ 错误: 本地 turboacc 安装脚本不存在"
            echo "🔄 启用替代加速方案 (BBR)"
            ALTERNATIVE_ACCELERATION="
            CONFIG_PACKAGE_kmod-tcp-bbr=y
            CONFIG_PACKAGE_kmod-nft-offload=y
            CONFIG_PACKAGE_kmod-nft-fastnet=y
            CONFIG_PACKAGE_kmod-nft-core=y
            CONFIG_PACKAGE_kmod-nft-nat=y
            CONFIG_PACKAGE_kmod-ipt-filter=y
            CONFIG_PACKAGE_iptables-mod-conntrack-extra=y
            CONFIG_PACKAGE_iptables-mod-ipopt=y
            "
            
            for config in $ALTERNATIVE_ACCELERATION; do
                echo "$config" >> .config
            done
            echo "✅ 替代加速方案已启用"
        fi
        
        # 验证 turboacc 是否成功安装
        echo "=== 验证 turboacc 安装结果 ==="
        if grep -q "CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
            echo "🎉 turboacc 已成功安装并启用"
            echo "✅ 相关配置:"
            grep -E "CONFIG_PACKAGE_(luci-app-turboacc|luci-i18n-turboacc|kmod-shortcut|kmod-fast-classifier)" .config || echo "未找到相关配置"
        else
            echo "⚠️ turboacc 未在配置中启用，安装脚本可能遇到了依赖问题"
        fi
        
        echo "✅ turboacc 安装流程完成"

    - name: 重新运行 defconfig 以整合配置
      run: |
        cd $BUILD_DIR
        echo "=== 重新运行 defconfig 以整合配置 ==="
        export MAKE_JOBS=1
        set +e
        make -j1 defconfig
        DEFCONFIG_EXIT_CODE=$?
        set -e
        
        if [ $DEFCONFIG_EXIT_CODE -ne 0 ]; then
            echo "❌ defconfig 执行失败，检查并修复配置问题"
            
            # 检查是否是递归依赖问题
            if make -j1 defconfig 2>&1 | grep -q "recursive dependency"; then
                echo "🔄 检测到递归依赖，清除有问题的配置"
                
                # 清除所有可能引起递归依赖的配置
                PROBLEMATIC_CONFIGS="
                CONFIG_PACKAGE_luci-app-turboacc
                CONFIG_PACKAGE_kmod-nft-fullcone
                CONFIG_PACKAGE_kmod-shortcut-fe
                "
                
                for config in $PROBLEMATIC_CONFIGS; do
                    sed -i "/${config}=y/d" .config
                    sed -i "/# ${config} is not set/d" .config
                done
                
                # 重新运行 defconfig
                make -j1 defconfig
            else
                echo "❌ 未知的 defconfig 错误，但继续构建流程"
            fi
        fi
        echo "✅ 配置整合完成"

    - name: 配置完整性检查
      run: |
        cd $BUILD_DIR
        echo "=== 配置完整性检查（单线程模式）==="
        export MAKE_JOBS=1
        if [ ! -f ".config" ] || [ ! -s ".config" ]; then
            echo "❌ 错误: .config 文件不存在或为空"
            exit 1
        fi
        echo "✅ .config 文件存在且非空"
        echo "文件大小: $(wc -l < .config) 行"
        echo "=== 关键配置验证 ==="
        if ! grep -q "^CONFIG_TARGET_${PLATFORM}_generic_DEVICE_${DEVICE_SHORT_NAME}=y" .config; then
            echo "❌ 错误: 设备配置缺失"
            exit 1
        fi
        for pkg in luci luci-base luci-theme-bootstrap; do
            if ! grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
                echo "❌ 错误: 核心组件 $pkg 未启用"
                exit 1
            fi
        done
        echo "=== 网络加速方案完整性检查 ==="
        if grep -q "CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
            echo "✅ turboacc 方案: 已启用"
            # 由于可能存在递归依赖，我们只做基本检查，不强制要求所有依赖
            echo "⚠️ 注意: turboacc 已启用，但可能存在依赖限制"
        elif grep -q "CONFIG_PACKAGE_kmod-tcp-bbr=y" .config; then
            echo "✅ 替代加速方案 (BBR): 已启用"
        else
            echo "⚠️ 未启用任何网络加速方案"
            # 这里不再强制启用，因为可能在前面步骤已经尝试过但失败了
        fi
        echo "✅ 配置完整性检查完成（单线程模式）"

    - name: 包可用性诊断
      run: |
        cd $BUILD_DIR
        echo "=== 包可用性诊断 ==="
        if [ -f "diagnose-packages.sh" ]; then
            chmod +x diagnose-packages.sh
            echo "开始诊断包可用性..."
            ./diagnose-packages.sh "$BUILD_DIR"
            echo "✅ 包诊断完成"
        else
            echo "⚠️ 未找到包诊断脚本，跳过诊断"
        fi

    - name: 构建时集成自定义文件
      run: |
        cd $BUILD_DIR
        echo "=== 构建时集成自定义文件 ==="
        mkdir -p files/root/custom-install
        cd $GITHUB_WORKSPACE
        IPK_FILES=$(find firmware-config/custom-files -name "*.ipk" -type f 2>/dev/null || true)
        if [ -n "$IPK_FILES" ]; then
            echo "✅ 找到IPK文件:"
            for ipk in $IPK_FILES; do
                cp "$ipk" $BUILD_DIR/files/root/custom-install/
                echo "✅ 复制IPK: $(basename "$ipk")"
            done
        fi
        SCRIPT_FILES=$(find firmware-config/custom-files -name "*.sh" -type f 2>/dev/null | grep -v "detector\|analysis" || true)
        if [ -n "$SCRIPT_FILES" ]; then
            echo "✅ 找到脚本文件:"
            for script in $SCRIPT_FILES; do
                cp "$script" $BUILD_DIR/files/root/custom-install/
                chmod +x $BUILD_DIR/files/root/custom-install/$(basename "$script")
                echo "✅ 复制脚本: $(basename "$script")"
            done
        fi
        echo '#!/bin/sh' > $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'echo "=== 开始构建时自定义安装 ==="' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'if ls /root/custom-install/*.ipk >/dev/null 2>&1; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "构建时安装IPK文件..."' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    for ipk in /root/custom-install/*.ipk; do' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        echo "安装: $(basename $ipk)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        opkg install "$ipk" --force-depends || echo "安装失败: $(basename $ipk)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    done' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'else' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "未找到IPK文件"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'if ls /root/custom-install/*.sh >/dev/null 2>&1; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "执行构建时脚本..."' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    for script in /root/custom-install/*.sh; do' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        if [ "$(basename $script)" != "build-time-install.sh" ]; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '            echo "执行: $(basename $script)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '            sh "$script" || echo "执行失败: $(basename $script)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    done' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'else' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "未找到脚本文件"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'rm -rf /root/custom-install' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'echo "=== 构建时自定义安装完成 ==="' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        chmod +x $BUILD_DIR/files/root/custom-install/build-time-install.sh
        mkdir -p $BUILD_DIR/files/etc
        echo '#!/bin/sh' > $BUILD_DIR/files/etc/rc.local
        echo '' >> $BUILD_DIR/files/etc/rc.local
        echo '[ -f /root/custom-install/build-time-install.sh ] && {' >> $BUILD_DIR/files/etc/rc.local
        echo '    /root/custom-install/build-time-install.sh >/tmp/build-time-install.log 2>&1 &' >> $BUILD_DIR/files/etc/rc.local
        echo '}' >> $BUILD_DIR/files/etc/rc.local
        echo '' >> $BUILD_DIR/files/etc/rc.local
        echo 'exit 0' >> $BUILD_DIR/files/etc/rc.local
        chmod +x $BUILD_DIR/files/etc/rc.local
        echo "✅ 构建时自定义安装配置完成"

    - name: 修复网络环境
      run: |
        cd $BUILD_DIR
        echo "=== 修复网络和下载环境 ==="
        git config --global http.postBuffer 524288000
        git config --global http.lowSpeedLimit 0
        git config --global http.lowSpeedTime 999999
        export GIT_SSL_NO_VERIFY=1
        export PYTHONHTTPSVERIFY=0
        mkdir -p dl
        chmod 755 dl
        echo "✅ 网络环境修复完成"

    - name: 运行预下载
      run: |
        cd $BUILD_DIR
        echo "=== 运行预下载脚本 ==="
        if [ -f "pre_download.sh" ]; then
            chmod +x pre_download.sh
            echo "开始预下载常见依赖包..."
            ./pre_download.sh
            echo "✅ 预下载完成"
        else
            echo "⚠️ 未找到预下载脚本，跳过预下载步骤"
        fi

    - name: 下载前配置验证（加强版）
      run: |
        cd $BUILD_DIR
        echo "=== 下载前配置验证（加强版）==="
        export MAKE_JOBS=1
        echo "=== 验证实际配置文件 ==="
        echo "当前启用的包数量: $(grep "^CONFIG_PACKAGE_.*=y" .config | wc -l)"
        echo "=== 网络加速方案状态验证（关键检查）==="
        echo "🔍 下载前网络加速方案状态检查:"
        if grep -q "CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
            echo "✅ turboacc 方案: 已启用"
            # 由于可能存在递归依赖问题，我们不再强制检查所有依赖
            echo "⚠️ 注意: turboacc 已启用，但可能存在依赖限制"
        elif grep -q "CONFIG_PACKAGE_kmod-tcp-bbr=y" .config; then
            echo "✅ 替代加速方案 (BBR): 已启用"
        else
            echo "❌ 严重错误: 未启用任何网络加速方案！"
            echo "=== 执行紧急网络加速方案恢复 ==="
            echo "🔄 紧急启用 BBR 替代方案"
            EMERGENCY_CONFIG="CONFIG_PACKAGE_kmod-tcp-bbr=y CONFIG_PACKAGE_kmod-nft-offload=y CONFIG_PACKAGE_kmod-nft-fastnet=y CONFIG_PACKAGE_kmod-nft-core=y CONFIG_PACKAGE_kmod-nft-nat=y"
            for config in $EMERGENCY_CONFIG; do
                echo "$config" >> .config
            done
            echo "✅ 紧急网络加速方案恢复完成"
        fi
        echo "=== 配置验证完成 ==="

    - name: 修复编译环境
      run: |
        cd $BUILD_DIR
        echo "=== 修复编译环境（单线程模式）==="
        export MAKE_JOBS=1
        find . -name "*.rej" -delete 2>/dev/null || true
        find . -name "*.orig" -delete 2>/dev/null || true
        mkdir -p staging_dir/host/bin
        mkdir -p staging_dir/target-*/host/bin
        echo "=== 运行 defconfig 以确保配置正确 ==="
        set +e
        make -j1 defconfig
        DEFCONFIG_EXIT_CODE=$?
        set -e
        
        if [ $DEFCONFIG_EXIT_CODE -ne 0 ]; then
            echo "❌ defconfig 执行失败，但继续构建流程"
        fi
        echo "✅ 编译环境修复完成"

    - name: 智能下载依赖
      run: |
        cd $BUILD_DIR
        echo "=== 智能下载依赖 ==="
        mkdir -p dl
        chmod 755 dl
        export GIT_SSL_NO_VERIFY=1
        export PYTHONHTTPSVERIFY=0
        echo "=== 设置国内镜像源: $MIRROR_SOURCE ==="
        case "$MIRROR_SOURCE" in
            "tuna") MIRROR_URL="https://mirrors.tuna.tsinghua.edu.cn/openwrt" ;;
            "ustc") MIRROR_URL="https://mirrors.ustc.edu.cn/openwrt" ;;
            "tencent") MIRROR_URL="https://mirrors.cloud.tencent.com/openwrt" ;;
            "huawei") MIRROR_URL="https://mirrors.huaweicloud.com/openwrt" ;;
            *) MIRROR_URL="https://mirrors.tuna.tsinghua.edu.cn/openwrt" ;;
        esac
        MAX_DOWNLOAD_RETRIES=3
        RETRY_COUNT=0
        DOWNLOAD_SUCCESS=false
        echo "=== 预先下载关键依赖 ==="
        make -j1 tools/install V=s 2>&1 | grep -E "Downloading|error" || true
        make -j1 toolchain/install V=s 2>&1 | grep -E "Downloading|error" || true
        find dl -name "*.tmp" -delete 2>/dev/null || true
        find dl -size 0 -delete 2>/dev/null || true
        for ROUND in 1 2; do
            echo "=== 第 $ROUND 轮下载验证循环 ==="
            while [ $RETRY_COUNT -lt $MAX_DOWNLOAD_RETRIES ] && [ "$DOWNLOAD_SUCCESS" = false ]; do
              RETRY_COUNT=$((RETRY_COUNT + 1))
              echo "=== 下载尝试 $RETRY_COUNT/$MAX_DOWNLOAD_RETRIES ==="
              set +e
              make -j1 download V=s
              DOWNLOAD_EXIT_CODE=$?
              set -e
              if [ $DOWNLOAD_EXIT_CODE -eq 0 ]; then
                echo "✅ 下载命令执行成功"
                DOWNLOAD_SUCCESS=true
              else
                echo "❌ 下载命令执行失败，退出代码: $DOWNLOAD_EXIT_CODE"
                if [ $RETRY_COUNT -eq $MAX_DOWNLOAD_RETRIES ]; then
                  echo "❌ 达到最大重试次数，下载失败"
                  echo "=== 最后尝试单线程下载 ==="
                  set +e
                  make -j1 download V=s
                  FINAL_DOWNLOAD_EXIT_CODE=$?
                  set -e
                  if [ $FINAL_DOWNLOAD_EXIT_CODE -eq 0 ]; then
                    echo "✅ 最后尝试下载成功"
                    DOWNLOAD_SUCCESS=true
                  else
                    echo "❌ 最后尝试下载失败"
                  fi
                  break
                else
                  echo "🔄 等待15秒后重试..."
                  sleep 15
                  find dl -name "*.tmp" -delete 2>/dev/null || true
                  find dl -size 0 -delete 2>/dev/null || true
                fi
              fi
            done
            echo "=== 下载完整性检查 ==="
            EMPTY_FILES=$(find dl -type f -size 0 2>/dev/null | wc -l)
            if [ "$EMPTY_FILES" -gt 0 ]; then
              echo "❌ 发现 $EMPTY_FILES 个空文件，删除后重新下载..."
              find dl -type f -size 0 -delete
              echo "重新下载空文件..."
              make -j1 download V=s
            fi
            if find dl -name "*.tmp" | grep -q ".tmp"; then
              echo "❌ 发现未完成的下载文件，删除后重新下载..."
              find dl -name "*.tmp" -delete
              echo "重新下载未完成的文件..."
              make -j1 download V=s
            fi
            DL_COUNT=$(find dl -type f | wc -l)
            DL_SIZE=$(du -sh dl | cut -f1)
            echo "✅ 下载统计: $DL_COUNT 个文件，总大小: $DL_SIZE"
            if [ $ROUND -eq 2 ]; then
                echo "=== 第二轮：验证关键依赖包 ==="
                MISSING_CRITICAL=0
                # 只检查 BBR 相关的包，因为 turboacc 可能由于递归依赖被禁用
                CRITICAL_PACKAGES="kmod-tcp-bbr kmod-nft-core kmod-nft-offload"
                for pkg in $CRITICAL_PACKAGES; do
                    if ! find dl -name "*${pkg}*" | grep -q "."; then
                        echo "❌ 关键依赖包缺失: $pkg"
                        MISSING_CRITICAL=$((MISSING_CRITICAL + 1))
                    else
                        echo "✅ 关键依赖包存在: $pkg"
                    fi
                done
                if [ $MISSING_CRITICAL -gt 0 ]; then
                    echo "❌ 缺失 $MISSING_CRITICAL 个关键依赖包，尝试单独下载..."
                    for pkg in $CRITICAL_PACKAGES; do
                        if ! find dl -name "*${pkg}*" | grep -q "."; then
                            echo "🔄 单独下载: $pkg"
                            make -j1 package/$pkg/download V=s
                        fi
                    done
                fi
            fi
            RETRY_COUNT=0
            DOWNLOAD_SUCCESS=false
        done
        echo "✅ 所有依赖下载完成"

    - name: 最终依赖验证
      run: |
        cd $BUILD_DIR
        echo "=== 最终依赖验证 ==="
        echo "=== 检查下载目录状态 ==="
        DL_COUNT=$(find dl -type f | wc -l)
        DL_SIZE=$(du -sh dl | cut -f1)
        echo "下载文件总数: $DL_COUNT"
        echo "下载总大小: $DL_SIZE"
        echo "=== 检查空文件和损坏文件 ==="
        EMPTY_FILES=$(find dl -type f -size 0 2>/dev/null | wc -l)
        TEMP_FILES=$(find dl -name "*.tmp" 2>/dev/null | wc -l)
        if [ "$EMPTY_FILES" -gt 0 ]; then
            echo "❌ 发现 $EMPTY_FILES 个空文件"
            find dl -type f -size 0 -delete
            echo "已删除空文件"
        else
            echo "✅ 没有空文件"
        fi
        if [ "$TEMP_FILES" -gt 0 ]; then
            echo "❌ 发现 $TEMP_FILES 个临时文件"
            find dl -name "*.tmp" -delete
            echo "已删除临时文件"
        else
            echo "✅ 没有临时文件"
        fi
        echo "=== 验证关键依赖包 ==="
        # 只检查 BBR 相关的包，因为 turboacc 可能由于递归依赖被禁用
        CRITICAL_PACKAGES="kmod-tcp-bbr kmod-nft-core kmod-nft-offload"
        ALL_CRITICAL_EXIST=true
        for pkg in $CRITICAL_PACKAGES; do
            if find dl -name "*${pkg}*" | grep -q "."; then
                echo "✅ 关键依赖包存在: $pkg"
            else
                echo "❌ 关键依赖包缺失: $pkg"
                ALL_CRITICAL_EXIST=false
            fi
        done
        if [ "$ALL_CRITICAL_EXIST" = false ]; then
            echo "⚠️ 部分关键依赖包缺失，但继续构建"
        else
            echo "✅ 所有关键依赖包都存在"
        fi

    - name: 最终配置验证（详细版）
      run: |
        cd $BUILD_DIR
        echo "=== 最终配置验证（详细版）==="
        export MAKE_JOBS=1
        echo "=== .config 文件状态 ==="
        ls -la .config
        echo "文件大小: $(wc -l < .config) 行"
        echo "=== 检查配置文件语法 ==="
        if grep -q "missing separator" .config 2>/dev/null; then
            echo "❌ 发现配置文件语法错误: missing separator"
            echo "有问题的行:"
            grep -n "missing separator" .config 2>/dev/null || true
            exit 1
        fi
        if grep -q $'\t' .config; then
            echo "⚠️ 发现制表符，可能会影响配置解析"
        fi
        echo "=== 关键软件包配置状态 ==="
        for pkg in luci luci-base luci-theme-bootstrap; do
          if grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
            echo "✅ $pkg: 在.config中已启用"
          else
            echo "❌ $pkg: 在.config中未启用"
          fi
        done
        echo "=== 网络加速方案最终状态验证 ==="
        echo "🔍 编译前最终网络加速方案状态检查:"
        if grep -q "CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
            echo "✅ turboacc 方案: 在.config中已启用"
            echo "⚠️ 注意: turboacc 已启用，但可能存在依赖限制"
        elif grep -q "CONFIG_PACKAGE_kmod-tcp-bbr=y" .config; then
            echo "✅ 替代加速方案 (BBR): 在.config中已启用"
        else
            echo "❌ 未启用任何网络加速方案 - 这是严重问题！"
            echo "=== 紧急启用 BBR 替代方案 ==="
            EMERGENCY_TURBOACC_CONFIG="CONFIG_PACKAGE_kmod-tcp-bbr=y CONFIG_PACKAGE_kmod-nft-offload=y CONFIG_PACKAGE_kmod-nft-fastnet=y CONFIG_PACKAGE_kmod-nft-core=y CONFIG_PACKAGE_kmod-nft-nat=y"
            for config in $EMERGENCY_TURBOACC_CONFIG; do
                echo "$config" >> .config
            done
            echo "✅ 已紧急启用 BBR 替代方案"
        fi
        echo "=== 用户启用的luci插件 ==="
        grep "^CONFIG_PACKAGE_luci-app" .config | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | sort
        echo "=== 配置验证完成 ==="

    - name: 编译固件
      run: |
        cd $BUILD_DIR
        echo "::group::📱 编译日志"
        echo "编译开始时间: $(date)"
        export FORCE_UNSAFE_CONFIGURE=1
        if ${{ inputs.multithreading }}; then
          BUILD_JOBS=$(nproc)
          echo "✅ 多线程编译: 使用 $BUILD_JOBS 个并行任务"
        else
          BUILD_JOBS=1
          echo "✅ 单线程编译"
        fi
        echo "🚀 开始分阶段编译..."
        START_TIME=$(date +%s)
        echo "=== 阶段1: 编译工具链 ==="
        make -j$BUILD_JOBS tools/compile V=s 2>&1 | tee -a build_detailed.log
        echo "=== 阶段2: 编译工具 ==="
        make -j$BUILD_JOBS toolchain/compile V=s 2>&1 | tee -a build_detailed.log
        echo "=== 阶段3: 完整编译 ==="
        set +e
        time make -j$BUILD_JOBS V=s 2>&1 | tee -a build_detailed.log
        COMPILE_EXIT_CODE=$?
        set -e
        END_TIME=$(date +%s)
        COMPILE_TIME=$((END_TIME - START_TIME))
        echo "=== 编译时间统计 ==="
        echo "总编译时间: $((COMPILE_TIME / 60))分钟$((COMPILE_TIME % 60))秒"
        if [ -d "bin/targets" ]; then
            echo "::endgroup::"
            echo "::notice::🎉 编译成功完成！"
            echo "✅ 编译完成，找到目标文件"
            FIRMWARE_LIST=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) 2>/dev/null | sort)
            if [ -n "$FIRMWARE_LIST" ]; then
                echo "🎉 生成的固件:"
                echo "$FIRMWARE_LIST"
            fi
            if [ $COMPILE_EXIT_CODE -ne 0 ]; then
                echo "⚠️ 编译过程有警告，但生成了固件文件"
            fi
        else
            echo "::endgroup::"
            echo "::notice::❌ 编译失败"
            echo "❌ 编译失败，未生成目标文件"
            if [ $COMPILE_EXIT_CODE -eq 0 ]; then
                echo "❌ 编译命令成功但未生成目标文件"
                find . -maxdepth 3 -type d | sort | head -20
            fi
            exit 1
        fi

    - name: 错误分析
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 运行错误分析 ==="
        if [ -f "error_analysis.sh" ]; then
            chmod +x error_analysis.sh
            echo "开始错误分析..."
            ./error_analysis.sh "$BUILD_DIR"
            echo "✅ 错误分析完成"
        else
            echo "⚠️ 未找到错误分析脚本，跳过错误分析"
        fi

    - name: 验证固件
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 固件生成验证 ==="
        if [ -d "bin/targets" ]; then
          echo "✅ 构建成功！生成的固件:"
          find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) | sort
          for firmware in $(find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) 2>/dev/null); do
            echo "固件: $firmware"
            echo "大小: $(du -h "$firmware" | cut -f1)"
            echo ""
          done
        else
          echo "❌ 构建失败，未找到目标文件"
        fi

    - name: 生成报告
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 生成构建报告文档 ==="
        echo "# OpenWrt 固件构建报告" > "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 构建信息" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **设备**: ${{ env.DEVICE_FULL_NAME }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **平台**: ${{ env.PLATFORM }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **版本**: ${{ env.SELECTED_REPO }} (${{ env.SELECTED_BRANCH }})" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **配置类型**: ${{ inputs.config_type }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **构建时间**: $(date)" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **编译时长**: $((COMPILE_TIME / 60))分钟$((COMPILE_TIME % 60))秒" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 配置状态" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "### 启用的luci插件" >> "$GITHUB_WORKSPACE/构建报告.md"
        grep "^CONFIG_PACKAGE_luci-app" .config 2>/dev/null | sed 's/CONFIG_PACKAGE_//' | sed 's/=y//' | sort | while read plugin; do
            echo "- $plugin" >> "$GITHUB_WORKSPACE/构建报告.md"
        done || echo "- 无luci插件或配置文件不可读" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 网络加速方案状态" >> "$GITHUB_WORKSPACE/构建报告.md"
        if grep -q "CONFIG_PACKAGE_luci-app-turboacc=y" .config 2>/dev/null; then
            echo "✅ **turboacc 方案**: 已启用" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "⚠️ **注意**: turboacc 已启用，但可能存在依赖限制" >> "$GITHUB_WORKSPACE/构建报告.md"
        elif grep -q "CONFIG_PACKAGE_kmod-tcp-bbr=y" .config 2>/dev/null; then
            echo "✅ **替代加速方案 (BBR)**: 已启用" >> "$GITHUB_WORKSPACE/构建报告.md"
        else
            echo "⚠️ **网络加速方案**: 未启用" >> "$GITHUB_WORKSPACE/构建报告.md"
        fi
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 构建状态" >> "$GITHUB_WORKSPACE/构建报告.md"
        if [ -d "bin/targets" ]; then
            echo "✅ **构建状态**: 成功" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "## 生成的固件" >> "$GITHUB_WORKSPACE/构建报告.md"
            find bin/targets -name "*.bin" -o -name "*.img" | while read firmware; do
                FIRMWARE_NAME=$(basename "$firmware")
                FIRMWARE_SIZE=$(du -h "$firmware" | cut -f1)
                echo "- **$FIRMWARE_NAME** ($FIRMWARE_SIZE)" >> "$GITHUB_WORKSPACE/构建报告.md"
            done
        else
            echo "❌ **构建状态**: 失败" >> "$GITHUB_WORKSPACE/构建报告.md"
        fi
        echo "✅ 构建报告已生成"

    - name: 保存配置
      if: success() && ${{ inputs.save_config }}
      run: |
        echo "=== 保存配置文件到仓库 ==="
        CONFIG_FILENAME="${{ github.event.inputs.device_name }}-${{ inputs.config_type }}.config"
        mkdir -p $GITHUB_WORKSPACE/firmware-config/configs
        if [ ! -f "$BUILD_DIR/.config" ]; then
          echo "❌ 错误: 源配置文件不存在"
          exit 1
        fi
        if [ -f "$GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME" ]; then
          if diff -q "$BUILD_DIR/.config" "$GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME" >/dev/null; then
            echo "ℹ️ 配置文件无变化，跳过保存"
            echo "CONFIG_UNCHANGED=true" >> $GITHUB_ENV
            exit 0
          else
            echo "✅ 检测到配置文件变化，将保存新配置"
          fi
        else
          echo "✅ 配置文件不存在，将创建新配置"
        fi
        cp $BUILD_DIR/.config $GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME
        if [ -f "$GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME" ]; then
          echo "✅ 配置文件已保存为: firmware-config/configs/$CONFIG_FILENAME"
          echo "CONFIG_UNCHANGED=false" >> $GITHUB_ENV
        else
          echo "❌ 错误: 配置文件保存失败"
          exit 1
        fi

    - name: 提交配置
      if: success() && ${{ inputs.save_config }} && env.CONFIG_UNCHANGED == 'false'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== 提交配置文件更改 ==="
        cd $GITHUB_WORKSPACE
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
        git add firmware-config/configs/
        git add "构建报告.md" 2>/dev/null || true
        if git diff --staged --quiet; then
          echo "ℹ️ 没有配置文件更改需要提交"
          exit 0
        fi
        git commit -m "自动保存配置文件: ${{ github.event.inputs.device_name }}-${{ inputs.config_type }} [skip ci]"
        git pull origin main --rebase --no-edit
        git push origin main
        echo "✅ 配置文件提交完成"

    - name: 上传固件
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ github.event.inputs.device_name }}-${{ env.SELECTED_BRANCH }}-${{ inputs.config_type }}
        path: ${{ env.BUILD_DIR }}/bin/targets/
        retention-days: 7

    - name: 上传日志
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-info-${{ github.event.inputs.device_name }}-${{ inputs.config_type }}
        path: |
          ${{ env.BUILD_DIR }}/.config
          ${{ env.BUILD_DIR }}/build_detailed.log
          ${{ env.BUILD_DIR }}/enhanced_error_analysis.log
          ${{ env.BUILD_DIR }}/download_attempt_*.log
          $GITHUB_WORKSPACE/构建报告.md
        retention-days: 7

    - name: 清理目录
      if: always()
      run: |
        echo "=== 清理构建目录 ==="
        sudo rm -rf $BUILD_DIR
        echo "✅ 构建目录已清理"

  build-firmware-ssh:
    if: ${{ inputs.ssh_connection == true }}
    name: 🚀 编译 (Build) - SSH调试版
    runs-on: ubuntu-22.04
    steps:
    - name: 初始空间检查
      run: |
        echo "=== 初始磁盘空间检查 ==="
        df -h
        AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
        AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
        echo "/mnt 可用空间: ${AVAILABLE_GB}G"
        if [ $AVAILABLE_GB -lt 50 ]; then
          echo "错误: /mnt 空间不足50G"
          exit 1
        fi

    - name: 检出配置仓库
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 设置编译环境
      run: |
        echo "=== 安装编译依赖包 ==="
        sudo apt-get update
        sudo DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential clang flex bison g++ gawk gcc-multilib g++-multilib gettext git libncurses5-dev libssl-dev python3-distutils rsync unzip zlib1g-dev file wget libelf-dev ecj fastjar java-propose-classpath libpython3-dev python3 python3-dev python3-pip python3-setuptools python3-yaml xsltproc zip
        pip3 install requests urllib3
        echo "✅ 编译环境设置完成"

    - name: 开启 SSH 服务
      uses: lhotari/action-upterm@v1
      with:
        wait-timeout-minutes: 30

    - name: 编译前提示
      run: |
        echo "🚀 SSH调试模式已启动"
        echo "您可以通过SSH连接到构建环境进行调试"
        echo "调试完成后，构建流程将继续执行"

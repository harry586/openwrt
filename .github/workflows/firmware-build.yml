# .github/workflows/firmware-build.yml
name: OpenWrt 智能固件构建工作流

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: "📱 设备名称"
        required: true
        default: "ac42u"
        type: choice
        options: ["ac42u", "cmcc_rax3000m", "netgear_3800"]
      version_selection:
        description: "🔄 版本选择"
        required: true
        type: choice
        default: "21.02"
        options: ["23.05", "21.02"]
      config_mode:
        description: "⚙️ 配置模式选择 - 🟣 基础模式 - 最小化配置，用于测试编译。🟠 正常模式 - 完整功能配置：✅ TurboACC 网络加速 ✅ UPnP 自动端口转发 ✅ Samba 文件共享 ✅ 磁盘管理 ✅ KMS 激活服务 ✅ SmartDNS 智能DNS ✅ 家长控制 ✅ 微信推送 ✅ 流量控制 (SQM) ✅ FTP 服务器 ✅ ARP 绑定 ✅ CPU 限制 ✅ 硬盘休眠 ✅ TCP BBR拥塞控制"
        required: true
        type: choice
        default: "normal"
        options: ["base", "normal"]
      extra_packages:
        description: "额外安装插件 - 格式：用分号;分隔。启用插件：+插件名。禁用插件：-插件名。"
        required: false
        type: string
        default: ""
      enable_parallel:
        description: "⚡ 启用智能并行优化 (自动判断最佳任务数)"
        required: false
        type: boolean
        default: true

env:
  BUILD_DIR: "/mnt/openwrt-build"
  REPO_ROOT: "${{ github.workspace }}"
  ENABLE_PARALLEL: "${{ github.event.inputs.enable_parallel }}"

jobs:
  build-firmware:
    runs-on: ubuntu-22.04

    steps:
      # 步骤 0: 生成时间戳（UTC+8时区）- 修复版：移除多余的日期格式
      - name: "0. 生成时间戳（UTC+8时区）"
        run: |
          echo "=== 步骤 0: 生成时间戳（UTC+8时区） ==="
          
          # 设置时区为UTC+8（北京时间）
          echo "设置时区为UTC+8..."
          sudo timedatectl set-timezone Asia/Shanghai 2>/dev/null || true
          
          # 生成时间戳 - 只保留精确到秒的格式
          START_TIME=$(date +'%Y-%m-%d %H:%M:%S')
          echo "🕐 开始时间: $START_TIME"
          
          # 生成精确到秒的时间戳
          TIMESTAMP_LOCAL=$(date +'%Y%m%d_%H%M%S')
          TIMESTAMP_SEC="${{ github.event.inputs.device_name }}-${{ github.event.inputs.version_selection }}-${{ github.event.inputs.config_mode }}-$TIMESTAMP_LOCAL"
          
          echo "TIMESTAMP_SEC=$TIMESTAMP_SEC" >> $GITHUB_ENV
          echo "START_TIME=$START_TIME" >> $GITHUB_ENV
          
          echo "✅ 生成时间戳:"
          echo "  精确到秒: $TIMESTAMP_SEC"
          echo "  开始时间: $START_TIME"
          echo "📋 构建配置:"
          echo "  设备: ${{ github.event.inputs.device_name }}"
          echo "  版本: ${{ github.event.inputs.version_selection }}"
          echo "  模式: ${{ github.event.inputs.config_mode }}"
          echo "  并行优化: ${{ github.event.inputs.enable_parallel }}"
          
          echo "🟢 步骤 0 完成"

      # 步骤 1: 使用Git Archive API下载源代码
      - name: "1. 使用Git Archive API下载源代码"
        run: |
          echo "=== 步骤 1: 使用Git Archive API下载源代码 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 1 失败，退出代码: $?"; exit 1' ERR
          
          # 创建临时目录
          mkdir -p /tmp/openwrt-source
          cd /tmp/openwrt-source
          
          # 获取默认分支
          echo "🔍 获取仓库默认分支..."
          DEFAULT_BRANCH=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}" | jq -r '.default_branch')
          echo "✅ 默认分支: $DEFAULT_BRANCH"
          
          # 使用Git Archive API下载压缩包
          echo "📥 下载源代码压缩包..."
          curl -s -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "https://api.github.com/repos/${{ github.repository }}/tarball/$DEFAULT_BRANCH" -o source.tar.gz
          
          if [ ! -f "source.tar.gz" ]; then
            echo "❌ 错误: 下载源代码压缩包失败"
            exit 1
          fi
          
          echo "✅ 下载完成，文件大小: $(ls -lh source.tar.gz | awk '{print $5}')"
          
          # 解压压缩包
          echo "📦 解压源代码..."
          tar -xzf source.tar.gz --strip-components=1
          
          # 检查解压结果
          echo "🔍 检查解压结果..."
          if [ -f "firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "✅ 源代码解压成功"
            echo "✅ 重要文件存在: firmware-config/scripts/build_firmware_main.sh"
            
            # 复制到工作区
            echo "📁 复制文件到工作区..."
            mkdir -p ${{ github.workspace }}
            
            # 检查并删除编译器目录（如果有的话）
            if [ -d "firmware-config/build-Compiler-file" ]; then
              echo "⚠️ 发现编译器目录，排除不复制"
              rm -rf firmware-config/build-Compiler-file
            fi
            
            # 使用rsync复制所有文件，排除.git目录
            rsync -av --exclude='.git' . ${{ github.workspace }}/
            
            # 确保脚本文件有执行权限
            chmod +x ${{ github.workspace }}/firmware-config/scripts/*.sh 2>/dev/null || true
            
            echo "✅ 文件复制完成"
            
            # 保存源代码压缩包作为构建产物
            mkdir -p /tmp/build-artifacts/source-archive
            cp source.tar.gz /tmp/build-artifacts/source-archive/
            echo "📦 源代码已保存到: /tmp/build-artifacts/source-archive/"
          else
            echo "❌ 错误: 源代码解压失败，重要文件缺失"
            echo "📁 当前目录内容:"
            ls -la
            exit 1
          fi
          
          # 清理临时文件
          cd /tmp
          rm -rf openwrt-source
          echo "✅ Git Archive API下载完成，时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 1 完成"

      # 步骤 2: 上传源代码Artifacts（使用精确到秒的时间戳）
      - name: "2. 上传源代码Artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: source-${{ env.TIMESTAMP_SEC }}
          path: /tmp/build-artifacts/source-archive/
          retention-days: 7
          if-no-files-found: error

      # 步骤 3: 修复权限问题
      - name: "3. 修复权限问题"
        run: |
          echo "=== 步骤 3: 修复权限问题 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 3 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔧 修复所有脚本的执行权限..."
          
          if [ -f "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" ]; then
            chmod +x "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh"
            echo "✅ 修复主脚本权限: firmware-config/scripts/build_firmware_main.sh"
          else
            echo "❌ 错误: 主脚本不存在: firmware-config/scripts/build_firmware_main.sh"
            exit 1
          fi
          
          if [ -f "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh" ]; then
            chmod +x "${{ github.workspace }}/firmware-config/scripts/error_analysis.sh"
            echo "✅ 修复错误分析脚本权限: firmware-config/scripts/error_analysis.sh"
          fi
          
          # 修复support.sh权限
          if [ -f "${{ github.workspace }}/support.sh" ]; then
            chmod +x "${{ github.workspace }}/support.sh"
            echo "✅ 修复support.sh权限"
          else
            echo "❌ 错误: support.sh不存在"
            exit 1
          fi
          
          # 修复其他脚本权限
          find "${{ github.workspace }}/firmware-config/scripts" -name "*.sh" -exec chmod +x {} \;
          echo "✅ 修复所有脚本权限完成"
          echo "🟢 步骤 3 完成"

      # 步骤 4: 安装基础工具（优化版）
      - name: "4. 安装基础工具（优化版）"
        run: |
          echo "=== 步骤 4: 安装基础工具（优化版） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 4 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔄 更新软件包列表..."
          sudo apt-get update -q
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: apt-get update 失败"
            exit 1
          fi
          
          echo "📦 安装编译必需工具 (分组安装，提高效率)..."
          
          # 分组1: 核心编译工具
          echo "🔧 安装核心编译工具..."
          sudo apt-get install -y -q \
            build-essential \
            clang \
            flex \
            bison \
            g++ \
            gawk \
            gcc-multilib \
            g++-multilib \
            gettext \
            git \
            libncurses5-dev \
            libssl-dev \
            python3-distutils \
            rsync \
            unzip \
            zlib1g-dev \
            file \
            wget \
            libelf-dev \
            cmake \
            ninja-build
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 核心编译工具安装失败"
            exit 1
          fi
          
          # 分组2: Python和脚本工具
          echo "🐍 安装Python和脚本工具..."
          sudo apt-get install -y -q \
            python3 \
            python3-dev \
            python3-pip \
            python3-setuptools \
            python3-yaml \
            xsltproc \
            zip \
            subversion \
            automake \
            autoconf \
            libtool \
            pkg-config \
            help2man \
            texinfo \
            groff \
            texlive \
            texinfo
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: Python和脚本工具安装失败"
            exit 1
          fi
          
          # 分组3: 网络和下载工具
          echo "🌐 安装网络和下载工具..."
          sudo apt-get install -y -q \
            curl \
            net-tools \
            iputils-ping \
            dnsutils \
            openssh-client \
            ca-certificates \
            gnupg \
            lsb-release \
            aria2 \
            libcurl4-openssl-dev
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 网络和下载工具安装失败"
            exit 1
          fi
          
          # 分组4: 文件系统工具
          echo "💿 安装文件系统工具..."
          sudo apt-get install -y -q \
            squashfs-tools \
            dosfstools \
            e2fsprogs \
            mtools \
            parted \
            fdisk \
            gdisk \
            hdparm \
            smartmontools
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 文件系统工具安装失败"
            exit 1
          fi
          
          # 分组5: 调试和开发工具
          echo "🔍 安装调试和开发工具..."
          sudo apt-get install -y -q \
            gdb \
            strace \
            ltrace \
            valgrind \
            binutils-dev \
            libdw-dev \
            libiberty-dev \
            ecj \
            fastjar \
            java-propose-classpath \
            libpython3-dev \
            liblz4-dev \
            zstd
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 调试和开发工具安装失败"
            exit 1
          fi
          
          echo "✅ 基础工具安装完成，时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 验证重要工具
          echo "🔍 验证重要工具安装..."
          echo "📋 检查以下重要工具是否安装成功:"
          
          # 定义要检查的工具数组
          tools_to_check=("gcc" "g++" "make" "git" "python3" "cmake" "flex" "bison")
          missing_tools=()
          
          # 检查每个工具
          for tool in "${tools_to_check[@]}"; do
            if command -v $tool >/dev/null 2>&1; then
              echo "✅ $tool 已安装: $(which $tool)"
            else
              echo "❌ $tool 未安装"
              missing_tools+=("$tool")
            fi
          done
          
          if [ ${#missing_tools[@]} -gt 0 ]; then
            echo "❌ 错误: 以下重要工具缺失: ${missing_tools[*]}"
            exit 1
          fi
          
          echo "🔍 额外检查:"
          # 检查gcc版本
          if command -v gcc >/dev/null 2>&1; then
            GCC_VERSION=$(gcc --version | head -1)
            echo "🔧 系统GCC版本: $GCC_VERSION"
            echo "💡 系统GCC用于编译工具链，SDK GCC用于交叉编译固件"
          fi
          
          # 检查make版本
          if command -v make >/dev/null 2>&1; then
            MAKE_VERSION=$(make --version | head -1)
            echo "🔨 Make版本: $MAKE_VERSION"
          fi
          
          echo "✅ 工具验证完成"
          echo "🟢 步骤 4 完成"

      # 步骤 5: 初始空间检查
      - name: "5. 初始空间检查"
        run: |
          echo "=== 步骤 5: 初始磁盘空间检查 ==="
          echo "🕐 检查时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 5 失败，退出代码: $?"; exit 1' ERR
          
          echo "📊 /mnt 分区详细信息:"
          df -h /mnt
          
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1 | awk '{print $1}')
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "/mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 50 ]; then
            echo "❌ 错误: /mnt 空间不足50G，当前只有${AVAILABLE_GB}G"
            exit 1
          else
            echo "✅ 初始空间检查通过 - ${AVAILABLE_GB}G 可用"
          fi
          
          echo "🟢 步骤 5 完成"

      # 步骤 6: 设置编译环境和构建目录
      - name: "6. 设置编译环境和构建目录"
        run: |
          echo "=== 步骤 6: 设置编译环境和构建目录 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 6 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔄 步骤 6.1: 设置编译环境"
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" setup_environment
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 设置编译环境失败"
            exit 1
          fi
          
          echo "🔄 步骤 6.2: 创建构建目录"
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" create_build_dir
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 创建构建目录失败"
            exit 1
          fi
          
          echo "🔄 步骤 6.3: 初始化构建环境"
          echo "📱 设备: ${{ github.event.inputs.device_name }}"
          echo "🔄 版本: ${{ github.event.inputs.version_selection }}"
          echo "⚙️ 配置模式: ${{ github.event.inputs.config_mode }}"
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" initialize_build_env "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_selection }}" "${{ github.event.inputs.config_mode }}"
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 初始化构建环境失败"
            exit 1
          fi
          
          echo "✅ 编译环境和构建目录设置完成，时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 6 完成"

      # 步骤 7: 下载OpenWrt官方SDK（修复版）
      - name: "7. 下载OpenWrt官方SDK（修复版）"
        run: |
          echo "=== 步骤 7: 下载OpenWrt官方SDK（修复版） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 7 失败，退出代码: $?"; exit 1' ERR
          
          echo "🚀 开始下载OpenWrt官方SDK工具链..."
          
          # 先检查环境文件是否已经存在
          echo "🔍 检查环境文件..."
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            echo "✅ 环境文件已存在（由步骤6.3创建）"
            echo "📊 环境文件内容摘要:"
            head -15 /mnt/openwrt-build/build_env.sh
            
            # 加载现有环境变量
            source /mnt/openwrt-build/build_env.sh
            echo "✅ 从现有环境文件加载变量:"
            echo "  SELECTED_BRANCH: $SELECTED_BRANCH"
            echo "  TARGET: $TARGET"
            echo "  SUBTARGET: $SUBTARGET"
            echo "  DEVICE: $DEVICE"
            echo "  CONFIG_MODE: $CONFIG_MODE"
            echo "  REPO_ROOT: $REPO_ROOT"
            echo "  COMPILER_DIR: $COMPILER_DIR"
            echo ""
            
            echo "💡 使用步骤6.3已设置的环境变量进行SDK下载"
          else
            echo "⚠️ 环境文件不存在，可能是步骤6.3失败"
            echo "📝 重新创建环境变量..."
            
            # 调用support.sh获取设备信息
            if [ -f "${{ github.workspace }}/support.sh" ]; then
              echo "🔍 调用support.sh获取设备信息..."
              PLATFORM_INFO=$("${{ github.workspace }}/support.sh" get-platform "${{ github.event.inputs.device_name }}")
              if [ -n "$PLATFORM_INFO" ]; then
                TARGET=$(echo "$PLATFORM_INFO" | awk '{print $1}')
                SUBTARGET=$(echo "$PLATFORM_INFO" | awk '{print $2}')
                DEVICE="${{ github.event.inputs.device_name }}"
                echo "✅ 从support.sh获取平台信息: TARGET=$TARGET, SUBTARGET=$SUBTARGET"
              else
                echo "❌ 无法从support.sh获取平台信息"
                exit 1
              fi
            else
              echo "❌ support.sh不存在"
              exit 1
            fi
            
            # 创建环境文件
            echo "#!/bin/bash" > /mnt/openwrt-build/build_env.sh
            echo "export SELECTED_REPO_URL=\"https://github.com/immortalwrt/immortalwrt.git\"" >> /mnt/openwrt-build/build_env.sh
            echo "export SELECTED_BRANCH=\"${{ github.event.inputs.version_selection == '23.05' && 'openwrt-23.05' || 'openwrt-21.02' }}\"" >> /mnt/openwrt-build/build_env.sh
            echo "export TARGET=\"$TARGET\"" >> /mnt/openwrt-build/build_env.sh
            echo "export SUBTARGET=\"$SUBTARGET\"" >> /mnt/openwrt-build/build_env.sh
            echo "export DEVICE=\"$DEVICE\"" >> /mnt/openwrt-build/build_env.sh
            echo "export CONFIG_MODE=\"${{ github.event.inputs.config_mode }}\"" >> /mnt/openwrt-build/build_env.sh
            echo "export REPO_ROOT=\"${{ github.workspace }}\"" >> /mnt/openwrt-build/build_env.sh
            echo "export COMPILER_DIR=\"\"" >> /mnt/openwrt-build/build_env.sh
            chmod +x /mnt/openwrt-build/build_env.sh
            echo "✅ 已创建环境文件"
          fi
          
          # 执行SDK下载
          echo "🔄 开始执行SDK下载..."
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" initialize_compiler_env "${{ github.event.inputs.device_name }}"
          
          SDK_EXIT_CODE=$?
          if [ $SDK_EXIT_CODE -ne 0 ]; then
            echo "❌ 错误: SDK下载失败，退出代码: $SDK_EXIT_CODE"
            exit 1
          fi
          
          echo "✅ SDK下载步骤完成，时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 7 完成"

      # 步骤 8: 验证SDK下载结果（修复版：动态检查）
      - name: "8. 验证SDK下载结果（修复版：动态检查）"
        run: |
          echo "=== 步骤 8: 验证SDK下载结果（修复版：动态检查） ==="
          echo "🕐 验证时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是验证
          trap 'echo "⚠️ 步骤 8 验证过程中出现错误，继续执行..."' ERR
          
          echo "🔍 检查SDK下载结果..."
          
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            source /mnt/openwrt-build/build_env.sh
            echo "✅ 从环境文件加载变量: COMPILER_DIR=$COMPILER_DIR"
          else
            echo "❌ 环境文件不存在"
          fi
          
          # 修复：检查COMPILER_DIR变量指向的目录，而不是固定的sdk目录
          if [ -n "$COMPILER_DIR" ] && [ -d "$COMPILER_DIR" ]; then
            echo "✅ SDK目录存在: $COMPILER_DIR"
            echo "📊 SDK目录大小: $(du -sh "$COMPILER_DIR" 2>/dev/null | cut -f1 || echo '未知')"
            
            # 查找真正的GCC，排除虚假编译器
            GCC_FILE=$(find "$COMPILER_DIR" -type f -executable \
              -name "*gcc" \
              ! -name "*gcc-ar" \
              ! -name "*gcc-ranlib" \
              ! -name "*gcc-nm" \
              ! -path "*dummy-tools*" \
              ! -path "*scripts*" \
              2>/dev/null | head -1)
            
            if [ -n "$GCC_FILE" ] && [ -x "$GCC_FILE" ]; then
              echo "✅ 找到可执行GCC编译器: $(basename "$GCC_FILE")"
              echo "🔧 GCC版本测试:"
              "$GCC_FILE" --version 2>&1 | head -1
              
              # 动态显示SDK GCC版本信息
              SDK_VERSION=$("$GCC_FILE" --version 2>&1 | head -1)
              MAJOR_VERSION=$(echo "$SDK_VERSION" | grep -o "[0-9]\+" | head -1)
              
              echo "💡 这是OpenWrt官方SDK交叉编译器，用于编译目标平台固件"
              
              if [ "$MAJOR_VERSION" = "12" ]; then
                echo "💡 SDK GCC版本: 12.3.0 (OpenWrt 23.05 SDK)"
              elif [ "$MAJOR_VERSION" = "8" ]; then
                echo "💡 SDK GCC版本: 8.4.0 (OpenWrt 21.02 SDK)"
              else
                echo "💡 SDK GCC版本: $MAJOR_VERSION.x"
              fi
              
              echo "💡 系统GCC (11.4.0) 用于编译工具链，SDK GCC ($MAJOR_VERSION.x) 用于交叉编译固件"
            else
              echo "❌ 未找到可执行的GCC编译器"
              
              # 检查是否有虚假的编译器
              DUMMY_GCC=$(find "$COMPILER_DIR" -type f -executable \
                -name "*gcc" \
                -path "*dummy-tools*" \
                2>/dev/null | head -1)
              
              if [ -n "$DUMMY_GCC" ]; then
                echo "⚠️ 检测到虚假的dummy-tools编译器: $DUMMY_GCC"
                echo "💡 这是OpenWrt构建系统的占位符，不是真正的编译器"
              fi
            fi
          else
            echo "❌ SDK目录不存在: $COMPILER_DIR"
            echo "💡 检查可能的SDK目录..."
            
            # 尝试查找SDK目录
            found_dirs=$(find "/mnt/openwrt-build" -maxdepth 1 -type d -name "*sdk*" 2>/dev/null)
            if [ -n "$found_dirs" ]; then
              echo "找到可能的SDK目录:"
              echo "$found_dirs"
              
              # 使用第一个找到的目录
              first_dir=$(echo "$found_dirs" | head -1)
              echo "使用目录: $first_dir"
              COMPILER_DIR="$first_dir"
              
              # 保存到环境文件
              echo "#!/bin/bash" > /mnt/openwrt-build/build_env.sh
              echo "export SELECTED_REPO_URL=\"https://github.com/immortalwrt/immortalwrt.git\"" >> /mnt/openwrt-build/build_env.sh
              echo "export SELECTED_BRANCH=\"$SELECTED_BRANCH\"" >> /mnt/openwrt-build/build_env.sh
              echo "export TARGET=\"$TARGET\"" >> /mnt/openwrt-build/build_env.sh
              echo "export SUBTARGET=\"$SUBTARGET\"" >> /mnt/openwrt-build/build_env.sh
              echo "export DEVICE=\"$DEVICE\"" >> /mnt/openwrt-build/build_env.sh
              echo "export CONFIG_MODE=\"$CONFIG_MODE\"" >> /mnt/openwrt-build/build_env.sh
              echo "export REPO_ROOT=\"$REPO_ROOT\"" >> /mnt/openwrt-build/build_env.sh
              echo "export COMPILER_DIR=\"$COMPILER_DIR\"" >> /mnt/openwrt-build/build_env.sh
              chmod +x /mnt/openwrt-build/build_env.sh
              echo "✅ 已更新环境文件"
            else
              echo "未找到SDK目录"
            fi
          fi
          
          echo "✅ SDK验证完成"
          echo "🟢 步骤 8 完成"

      # 步骤 9: 添加 TurboACC 支持 - 修复版：所有版本都添加
      - name: "9. 添加 TurboACC 支持"
        run: |
          echo "=== 步骤 9: 添加 TurboACC 支持 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 9 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" add_turboacc_support
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 添加TurboACC支持失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 9 完成"

      # 步骤 10: 配置Feeds - 修复版：统一处理TurboACC
      - name: "10. 配置Feeds"
        run: |
          echo "=== 步骤 10: 配置Feeds ==="
          echo "🕐 开始时间: $(date +'%Y-%m-d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 10 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" configure_feeds
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 配置Feeds失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 10 完成"

      # 步骤 11: 安装 TurboACC 包 - 修复版：正常模式都安装
      - name: "11. 安装 TurboACC 包"
        if: github.event.inputs.config_mode == 'normal'
        run: |
          echo "=== 步骤 11: 安装 TurboACC 包 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 11 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" install_turboacc_packages
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 安装TurboACC包失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 11 完成"

      # 步骤 12: 编译前空间检查
      - name: "12. 编译前空间检查"
        run: |
          echo "=== 步骤 12: 编译前空间检查 ==="
          echo "🕐 检查时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 12 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" pre_build_space_check
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 编译前空间检查失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 12 完成"

      # 步骤 13: 智能配置生成
      - name: "13. 智能配置生成"
        run: |
          echo "=== 步骤 13: 智能配置生成 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 13 失败，退出代码: $?"; exit 1' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" generate_config "${{ github.event.inputs.extra_packages }}"
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 智能配置生成失败"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 13 完成"

      # 步骤 14: 验证USB配置（修复版：精确匹配）- 保留完整输出
      - name: "14. 验证USB配置（修复版：精确匹配）"
        run: |
          echo "=== 步骤 14: 验证USB配置（修复版：精确匹配） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是验证
          trap 'echo "⚠️ 步骤 14 验证过程中出现错误，继续执行..."' ERR
          
          cd /mnt/openwrt-build
          
          # 使用精确匹配检查USB配置
          echo "=== 🚨 USB配置精确匹配检查 ==="
          
          echo "1. 🟢 USB核心模块（精确匹配）:"
          if grep -q "^CONFIG_PACKAGE_kmod-usb-core=y" .config; then
            echo "✅ USB核心: 已启用"
          else
            echo "❌ USB核心: 未启用"
          fi
          
          echo "2. 🟢 USB控制器（精确匹配）:"
          echo "  - kmod-usb2:" $(grep -q "^CONFIG_PACKAGE_kmod-usb2=y" .config && echo "✅" || echo "❌")
          echo "  - kmod-usb3:" $(grep -q "^CONFIG_PACKAGE_kmod-usb3=y" .config && echo "✅" || echo "❌")
          echo "  - kmod-usb-xhci-hcd:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" .config && echo "✅" || echo "❌")
          
          echo "3. 🟢 USB存储驱动（精确匹配）:"
          echo "  - kmod-usb-storage:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-storage=y" .config && echo "✅" || echo "❌")
          echo "  - kmod-scsi-core:" $(grep -q "^CONFIG_PACKAGE_kmod-scsi-core=y" .config && echo "✅" || echo "❌")
          
          # 检查是否有重复配置
          echo "4. 🟢 检查重复配置:"
          duplicates=$(grep "CONFIG_PACKAGE_kmod-usb-xhci-hcd" .config | wc -l)
          if [ $duplicates -gt 1 ]; then
            echo "⚠️ 发现重复配置: kmod-usb-xhci-hcd ($duplicates 次)"
            echo "🔍 显示所有匹配行:"
            grep -n "CONFIG_PACKAGE_kmod-usb-xhci-hcd" .config
          else
            echo "✅ 无重复配置"
          fi
          
          echo "5. 🟢 平台专用驱动检查（精确匹配）:"
          if grep -q "^CONFIG_TARGET_ipq40xx=y" .config; then
            echo "🔧 检测到高通IPQ40xx平台:"
            echo "  - kmod-usb-dwc3-qcom:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-dwc3-qcom=y" .config && echo "✅" || echo "❌")
            echo "  - kmod-phy-qcom-dwc3:" $(grep -q "^CONFIG_PACKAGE_kmod-phy-qcom-dwc3=y" .config && echo "✅" || echo "❌")
          fi
          
          echo "✅ USB配置检查完成"
          echo "🟢 步骤 14 完成"

      # 步骤 15: USB驱动完整性检查（修复版）
      - name: "15. USB驱动完整性检查（修复版）"
        run: |
          echo "=== 步骤 15: USB驱动完整性检查（修复版） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是检查
          trap 'echo "⚠️ 步骤 15 检查过程中出现错误，继续执行..."' ERR
          
          cd /mnt/openwrt-build
          
          echo "=== USB驱动完整性检查（精确匹配） ==="
          
          # 基础USB驱动（所有平台必需）
          missing_drivers=()
          required_drivers=(
            "kmod-usb-core"
            "kmod-usb2"
            "kmod-usb-storage"
            "kmod-scsi-core"
          )
          
          echo "🔍 检查基础USB驱动..."
          for driver in "${required_drivers[@]}"; do
            if grep -q "^CONFIG_PACKAGE_${driver}=y" .config; then
              echo "✅ $driver: 已启用"
            else
              echo "❌ $driver: 未启用"
              missing_drivers+=("$driver")
            fi
          done
          
          echo ""
          echo "🔍 检查USB 3.0驱动..."
          usb3_drivers=("kmod-usb3" "kmod-usb-xhci-hcd")
          for driver in "${usb3_drivers[@]}"; do
            if grep -q "^CONFIG_PACKAGE_${driver}=y" .config; then
              echo "✅ $driver: 已启用"
            else
              echo "⚠️ $driver: 未启用（如果设备支持USB 3.0可能需要）"
            fi
          done
          
          echo ""
          echo "🔍 检查平台专用驱动..."
          # 根据平台检查专用驱动
          if grep -q "^CONFIG_TARGET_ipq40xx=y" .config; then
            echo "🔧 检测到高通IPQ40xx平台，检查专用驱动:"
            ipq40xx_drivers=("kmod-usb-dwc3-qcom" "kmod-phy-qcom-dwc3" "kmod-usb-dwc3")
            for driver in "${ipq40xx_drivers[@]}"; do
              if grep -q "^CONFIG_PACKAGE_${driver}=y" .config; then
                echo "✅ $driver: 已启用"
              else
                echo "ℹ️ $driver: 未启用（可能不是必需）"
              fi
            done
          fi
          
          echo ""
          echo "📊 统计:"
          echo "  必需驱动: ${#required_drivers[@]} 个"
          echo "  缺失驱动: ${#missing_drivers[@]} 个"
          
          if [ ${#missing_drivers[@]} -gt 0 ]; then
            echo "⚠️ 发现缺失驱动: ${missing_drivers[*]}"
            echo "💡 建议在配置文件中启用这些驱动"
          else
            echo "✅ 所有必需USB驱动都已启用"
          fi
          
          echo "🟢 步骤 15 完成"

      # 步骤 16: 应用配置并显示详情（完整版）- 修复USB 3.0、TurboACC和ath10k冲突
      - name: "16. 应用配置并显示详情（完整版）- 修复USB 3.0、TurboACC和ath10k冲突"
        run: |
          echo "=== 步骤 16: 应用配置并显示详情（完整版）- 修复USB 3.0、TurboACC和ath10k冲突 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 16 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          # 【关键修复1】强制启用USB 3.0驱动
          echo "🔧 强制启用USB 3.0核心驱动..."
          if ! grep -q "^CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" .config; then
            echo "CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" >> .config
            echo "✅ 已强制添加: kmod-usb-xhci-hcd"
          fi
          
          if ! grep -q "^CONFIG_PACKAGE_kmod-usb3=y" .config; then
            echo "CONFIG_PACKAGE_kmod-usb3=y" >> .config
            echo "✅ 已强制添加: kmod-usb3"
          fi
          
          # 根据平台添加专用USB驱动
          if [ "${{ env.TARGET }}" = "ipq40xx" ] || grep -q "^CONFIG_TARGET_ipq40xx=y" .config 2>/dev/null; then
            if ! grep -q "^CONFIG_PACKAGE_kmod-usb-dwc3-qcom=y" .config; then
              echo "CONFIG_PACKAGE_kmod-usb-dwc3-qcom=y" >> .config
              echo "✅ 已强制添加: kmod-usb-dwc3-qcom (IPQ40xx专用)"
            fi
            if ! grep -q "^CONFIG_PACKAGE_kmod-phy-qcom-dwc3=y" .config; then
              echo "CONFIG_PACKAGE_kmod-phy-qcom-dwc3=y" >> .config
              echo "✅ 已强制添加: kmod-phy-qcom-dwc3"
            fi
          fi
          
          # 【关键修复2】强制启用TurboACC配置（正常模式）
          if [ "${{ github.event.inputs.config_mode }}" = "normal" ]; then
            echo "🔧 强制启用TurboACC配置..."
            if ! grep -q "^CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
              echo "CONFIG_PACKAGE_luci-app-turboacc=y" >> .config
              echo "✅ 已强制添加: luci-app-turboacc"
            fi
            if ! grep -q "^CONFIG_PACKAGE_kmod-shortcut-fe=y" .config; then
              echo "CONFIG_PACKAGE_kmod-shortcut-fe=y" >> .config
              echo "✅ 已强制添加: kmod-shortcut-fe"
            fi
            if ! grep -q "^CONFIG_PACKAGE_kmod-fast-classifier=y" .config; then
              echo "CONFIG_PACKAGE_kmod-fast-classifier=y" >> .config
              echo "✅ 已强制添加: kmod-fast-classifier"
            fi
            echo "✅ TurboACC配置已强制启用"
          fi
          
          # 【关键修复3】强制启用TCP BBR拥塞控制
          echo "🔧 强制启用TCP BBR拥塞控制..."
          if ! grep -q "^CONFIG_PACKAGE_kmod-tcp-bbr=y" .config; then
            echo "CONFIG_PACKAGE_kmod-tcp-bbr=y" >> .config
            echo "✅ 已强制添加: kmod-tcp-bbr"
          fi
          if ! grep -q "^CONFIG_DEFAULT_TCP_CONG=\"bbr\"" .config; then
            echo "CONFIG_DEFAULT_TCP_CONG=\"bbr\"" >> .config
            echo "✅ 已设置默认拥塞控制算法: BBR"
          fi
          
          # 【关键修复4】解决kmod-ath10k-ct冲突问题 - 增强版
          echo "🔧 解决kmod-ath10k-ct冲突问题..."
          # 禁用标准ath10k驱动
          sed -i 's/^CONFIG_PACKAGE_kmod-ath10k=y/# CONFIG_PACKAGE_kmod-ath10k is not set/' .config 2>/dev/null || true
          sed -i 's/^CONFIG_PACKAGE_kmod-ath10k-pci=y/# CONFIG_PACKAGE_kmod-ath10k-pci is not set/' .config 2>/dev/null || true
          sed -i 's/^CONFIG_PACKAGE_kmod-ath10k-smallbuffers=y/# CONFIG_PACKAGE_kmod-ath10k-smallbuffers is not set/' .config 2>/dev/null || true
          sed -i 's/^CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers=y/# CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers is not set/' .config 2>/dev/null || true
          
          # 确保CT版本被启用，禁用smallbuffers版本
          echo "# CONFIG_PACKAGE_kmod-ath10k is not set" >> .config
          echo "# CONFIG_PACKAGE_kmod-ath10k-pci is not set" >> .config
          echo "# CONFIG_PACKAGE_kmod-ath10k-smallbuffers is not set" >> .config
          echo "CONFIG_PACKAGE_kmod-ath10k-ct=y" >> .config
          echo "# CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers is not set" >> .config
          echo "✅ 已配置使用kmod-ath10k-ct替代标准ath10k驱动，并禁用smallbuffers版本"
          
          # 备份原始配置文件
          cp "/mnt/openwrt-build/.config" "/mnt/openwrt-build/.config.original" 2>/dev/null || true
          echo "✅ 已备份原始配置文件"
          
          # 应用配置
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" apply_config
          
          if [ $? -ne 0 ]; then
            echo "❌ 错误: 应用配置失败"
            exit 1
          fi
          
          echo "=== 🚨 最终配置状态检查（精确匹配版）==="
          if [ -f "/mnt/openwrt-build/.config" ]; then
            echo "✅ 配置文件存在"
            echo "📊 文件大小: $(ls -lh "/mnt/openwrt-build/.config" | awk '{print $5}')"
            echo "📝 文件行数: $(wc -l < "/mnt/openwrt-build/.config")"
            
            echo ""
            echo "🔧 关键配置检查（精确匹配）:"
            echo "1. ✅ 目标平台配置:"
            grep "^CONFIG_TARGET_" "/mnt/openwrt-build/.config" 2>/dev/null | head -3 || true
            
            echo ""
            echo "2. ✅ USB 3.0驱动配置（精确匹配）:"
            echo "  - kmod-usb-xhci-hcd:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅ 已启用" || echo "❌ 未启用")
            echo "  - kmod-usb3:" $(grep -q "^CONFIG_PACKAGE_kmod-usb3=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅ 已启用" || echo "❌ 未启用")
            
            echo ""
            echo "3. ✅ TCP BBR拥塞控制算法配置:"
            echo "  - kmod-tcp-bbr:" $(grep -q "^CONFIG_PACKAGE_kmod-tcp-bbr=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅ 已启用" || echo "❌ 未启用")
            
            echo ""
            echo "4. ✅ TurboACC配置（正常模式必需）:"
            if [ "${{ github.event.inputs.config_mode }}" = "normal" ]; then
              echo "  - luci-app-turboacc:" $(grep -q "^CONFIG_PACKAGE_luci-app-turboacc=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅ 已启用" || echo "❌ 未启用")
              echo "  - kmod-shortcut-fe:" $(grep -q "^CONFIG_PACKAGE_kmod-shortcut-fe=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅ 已启用" || echo "❌ 未启用")
            else
              echo "  ℹ️ 基础模式，不启用TurboACC"
            fi
            
            echo ""
            echo "5. ✅ kmod-ath10k-ct冲突解决状态:"
            echo "  - kmod-ath10k:" $(grep -q "^CONFIG_PACKAGE_kmod-ath10k=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "⚠️ 仍启用" || echo "✅ 已禁用")
            echo "  - kmod-ath10k-ct:" $(grep -q "^CONFIG_PACKAGE_kmod-ath10k-ct=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅ 已启用" || echo "❌ 未启用")
            echo "  - kmod-ath10k-ct-smallbuffers:" $(grep -q "^CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "⚠️ 仍启用（可能冲突）" || echo "✅ 已禁用")
            
            echo ""
            echo "6. ✅ 关键USB驱动状态（精确匹配）:"
            echo "  - kmod-usb-core:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-core=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            echo "  - kmod-usb2:" $(grep -q "^CONFIG_PACKAGE_kmod-usb2=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            echo "  - kmod-usb3:" $(grep -q "^CONFIG_PACKAGE_kmod-usb3=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            echo "  - kmod-usb-storage:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-storage=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            echo "  - kmod-scsi-core:" $(grep -q "^CONFIG_PACKAGE_kmod-scsi-core=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            echo "  - kmod-usb-xhci-hcd:" $(grep -q "^CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            
            echo ""
            echo "7. ✅ 插件配置统计（精确匹配）:"
            enabled=$(grep -c "^CONFIG_PACKAGE_.*=y" "/mnt/openwrt-build/.config" 2>/dev/null || echo "0")
            disabled=$(grep -c "^# CONFIG_PACKAGE_.* is not set" "/mnt/openwrt-build/.config" 2>/dev/null || echo "0")
            echo "   ✅ 已启用插件: $enabled 个"
            echo "   ❌ 已禁用插件: $disabled 个"
            
            echo ""
            echo "8. 🔍 libustream冲突状态:"
            echo "  - libustream-openssl:" $(grep -q "^CONFIG_PACKAGE_libustream-openssl=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            echo "  - libustream-wolfssl:" $(grep -q "^CONFIG_PACKAGE_libustream-wolfssl=y" "/mnt/openwrt-build/.config" 2>/dev/null && echo "✅" || echo "❌")
            
            if grep -q "^CONFIG_PACKAGE_libustream-openssl=y" "/mnt/openwrt-build/.config" && grep -q "^CONFIG_PACKAGE_libustream-wolfssl=y" "/mnt/openwrt-build/.config"; then
              echo "⚠️ 警告: libustream-openssl和libustream-wolfssl同时启用，可能导致冲突"
              echo "💡 建议只启用其中一个"
            fi
            
            echo ""
            echo "🎯 配置摘要:"
            echo "  - 配置模式: ${{ github.event.inputs.config_mode }}"
            echo "  - USB 3.0驱动: 已强制启用"
            echo "  - TurboACC: $([ "${{ github.event.inputs.config_mode }}" = "normal" ] && echo "已强制启用" || echo "基础模式不启用")"
            echo "  - kmod-ath10k-ct冲突: 已解决（禁用smallbuffers版本）"
            
            # 显示前10个启用的插件
            echo ""
            echo "📋 启用的插件 (前10个，精确匹配):"
            grep "^CONFIG_PACKAGE_.*=y" "/mnt/openwrt-build/.config" 2>/dev/null | head -10 | sed 's/^CONFIG_PACKAGE_//g' | sed 's/=y//g' | while read pkg; do
              echo "  ✅ $pkg"
            done
          else
            echo "❌ 配置文件不存在"
          fi
          
          echo ""
          echo "✅ 配置应用完成"
          echo "🟢 步骤 16 完成"

      # 步骤 17: 检查并备份配置文件（修复版：清理重复配置）
      - name: "17. 检查并备份配置文件（修复版：清理重复配置）"
        run: |
          echo "=== 步骤 17: 检查并备份配置文件（修复版：清理重复配置） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 17 失败，退出代码: $?"; exit 1' ERR
          
          # 检查配置文件
          if [ -f "/mnt/openwrt-build/.config" ]; then
            echo "✅ .config 文件存在"
            echo "📊 文件大小: $(ls -lh "/mnt/openwrt-build/.config" | awk '{print $5}')"
            echo "📝 文件行数: $(wc -l < "/mnt/openwrt-build/.config")"
            
            # 清理重复配置
            echo "🔧 清理重复配置..."
            cd /mnt/openwrt-build
            
            # 备份清理前的配置文件
            cp .config .config.before_cleanup
            
            # 创建临时文件来存储唯一的配置行
            awk '!seen[$0]++' .config > .config.temp
            
            # 检查是否有重复行被移除
            original_lines=$(wc -l < .config)
            unique_lines=$(wc -l < .config.temp)
            removed_lines=$((original_lines - unique_lines))
            
            if [ $removed_lines -gt 0 ]; then
              echo "✅ 清理了 $removed_lines 个重复配置行"
              mv .config.temp .config
            else
              echo "✅ 无重复配置行"
              rm -f .config.temp
            fi
            
            # 确保备份目录存在
            mkdir -p "${{ github.workspace }}/firmware-config/config-backup"
            
            # 备份到仓库目录 - 使用精确到秒的时间戳
            BACKUP_FILE="${{ github.workspace }}/firmware-config/config-backup/config_${{ env.TIMESTAMP_SEC }}.config"
            
            cp "/mnt/openwrt-build/.config" "$BACKUP_FILE"
            echo "✅ 配置文件备份到仓库目录: $BACKUP_FILE"
            echo "📊 备份文件大小: $(ls -lh "$BACKUP_FILE" | awk '{print $5}')"
            echo "📝 备份文件行数: $(wc -l < "$BACKUP_FILE")"
            
            # 如果清理了重复行，也备份清理前的版本
            if [ $removed_lines -gt 0 ]; then
              BACKUP_FILE_BEFORE="${{ github.workspace }}/firmware-config/config-backup/config_${{ env.TIMESTAMP_SEC }}_before_cleanup.config"
              cp "/mnt/openwrt-build/.config.before_cleanup" "$BACKUP_FILE_BEFORE"
              echo "✅ 清理前的配置文件也备份到: $BACKUP_FILE_BEFORE"
            fi
          else
            echo "❌ 错误: .config 文件不存在"
            exit 1
          fi
          
          echo "🟢 步骤 17 完成"

      # 步骤 18: 修复网络环境
      - name: "18. 修复网络环境"
        run: |
          echo "=== 步骤 18: 修复网络环境 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是尝试修复
          trap 'echo "⚠️ 步骤 18 修复过程中出现错误，继续执行..."' ERR
          
          "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" fix_network
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 18 完成"

      # 步骤 19: 下载依赖包（优化版）
      - name: "19. 下载依赖包（优化版）"
        run: |
          echo "=== 步骤 19: 下载依赖包（优化版） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 19 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          echo "🔧 检查依赖包目录..."
          if [ ! -d "dl" ]; then
            mkdir -p dl
            echo "✅ 创建依赖包目录: dl"
          fi
          
          DEP_COUNT=$(find dl -type f 2>/dev/null | wc -l)
          echo "📊 当前依赖包数量: $DEP_COUNT 个"
          
          echo "🚀 开始下载依赖包（启用并行下载）..."
          # 使用并行下载加速，设置输出缓冲区更大防止stdout错误
          stdbuf -oL -eL make -j4 download V=s 2>&1 | tee download.log
          
          DOWNLOAD_EXIT_CODE=${PIPESTATUS[0]}
          if [ $DOWNLOAD_EXIT_CODE -ne 0 ]; then
            echo "⚠️ 警告: 依赖包下载过程中出现错误，退出代码: $DOWNLOAD_EXIT_CODE"
            echo "💡 查看下载日志中的错误信息:"
            grep -i "error\|failed\|404\|not found" download.log | head -10 || true
          fi
          
          echo "✅ 下载完成，时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 检查下载结果
          NEW_DEP_COUNT=$(find dl -type f 2>/dev/null | wc -l)
          echo "📊 下载后依赖包数量: $NEW_DEP_COUNT 个"
          echo "📈 新增依赖包: $((NEW_DEP_COUNT - DEP_COUNT)) 个"
          
          echo "🟢 步骤 19 完成"

      # 步骤 20: 集成自定义文件（增强版）- 保留完整输出
      - name: "20. 集成自定义文件（增强版）"
        run: |
          echo "=== 步骤 20: 集成自定义文件（增强版）==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是尝试集成
          trap 'echo "⚠️ 步骤 20 集成过程中出现错误，继续执行..."' ERR
          
          echo "🔍 检查自定义文件目录..."
          CUSTOM_DIR="${{ github.workspace }}/firmware-config/custom-files"
          
          if [ -d "$CUSTOM_DIR" ]; then
            echo "✅ 自定义文件目录存在: $CUSTOM_DIR"
            
            # 递归查找所有文件
            echo "📁 递归查找所有自定义文件..."
            
            # 定义英文文件名检查函数 - 修复正则表达式
            is_english_name() {
              local filename="$1"
              if [[ "$filename" =~ ^[a-zA-Z0-9_.\-]+$ ]]; then
                return 0  # 英文文件名
              else
                return 1  # 非英文文件名
              fi
            }
            
            # 递归查找所有文件
            ALL_FILES=$(find "$CUSTOM_DIR" -type f 2>/dev/null | sort)
            FILE_COUNT=$(echo "$ALL_FILES" | wc -l)
            
            if [ $FILE_COUNT -eq 0 ]; then
              echo "ℹ️ 目录为空"
            else
              echo "📊 找到 $FILE_COUNT 个自定义文件"
              
              # 分类统计
              IPK_COUNT=0
              SCRIPT_COUNT=0
              CONFIG_COUNT=0
              OTHER_COUNT=0
              ENGLISH_COUNT=0
              NON_ENGLISH_COUNT=0
              
              # 详细显示所有文件
              echo ""
              echo "📋 详细文件列表:"
              echo "================================================"
              
              while IFS= read -r file; do
                [ -z "$file" ] && continue
                
                REL_PATH="${file#$CUSTOM_DIR/}"
                FILE_NAME=$(basename "$file")
                FILE_SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                
                # 检查是否为英文文件名 - 使用修复版检测
                if is_english_name "$FILE_NAME"; then
                  NAME_STATUS="✅ 英文"
                  ENGLISH_COUNT=$((ENGLISH_COUNT + 1))
                else
                  NAME_STATUS="⚠️ 非英文"
                  NON_ENGLISH_COUNT=$((NON_ENGLISH_COUNT + 1))
                fi
                
                # 文件类型统计
                if [[ "$FILE_NAME" =~ \.ipk$ ]] || [[ "$FILE_NAME" =~ \.IPK$ ]] || [[ "$FILE_NAME" =~ \.Ipk$ ]]; then
                  TYPE_DESC="📦 IPK包"
                  IPK_COUNT=$((IPK_COUNT + 1))
                elif [[ "$FILE_NAME" =~ \.sh$ ]] || [[ "$FILE_NAME" =~ \.Sh$ ]] || [[ "$FILE_NAME" =~ \.SH$ ]]; then
                  TYPE_DESC="📜 脚本"
                  SCRIPT_COUNT=$((SCRIPT_COUNT + 1))
                elif [[ "$FILE_NAME" =~ \.conf$ ]] || [[ "$FILE_NAME" =~ \.config$ ]] || [[ "$FILE_NAME" =~ \.CONF$ ]]; then
                  TYPE_DESC="⚙️ 配置"
                  CONFIG_COUNT=$((CONFIG_COUNT + 1))
                else
                  TYPE_DESC="📁 其他"
                  OTHER_COUNT=$((OTHER_COUNT + 1))
                fi
                
                printf "%-45s %-8s %-12s %s\n" "$REL_PATH" "$FILE_SIZE" "$TYPE_DESC" "$NAME_STATUS"
                
              done <<< "$ALL_FILES"
              
              echo "================================================"
              
              # 统计信息
              echo ""
              echo "📊 文件统计:"
              echo "  文件总数: $FILE_COUNT 个"
              echo "  📦 IPK文件: $IPK_COUNT 个"
              echo "  📜 脚本文件: $SCRIPT_COUNT 个"
              echo "  ⚙️ 配置文件: $CONFIG_COUNT 个"
              echo "  📁 其他文件: $OTHER_COUNT 个"
              echo "  ✅ 英文文件名: $ENGLISH_COUNT 个"
              echo "  ⚠️ 非英文文件名: $NON_ENGLISH_COUNT 个"
              
              # 文件名建议 - 简化版本
              if [ $NON_ENGLISH_COUNT -gt 0 ]; then
                echo ""
                echo "💡 文件名兼容性建议:"
                echo "  为了更好的兼容性，方便复制、运行，建议使用英文文件名"
                echo "  当前系统会自动处理非英文文件名，但英文名有更好的兼容性"
              fi
              
              echo ""
              echo "🚀 开始执行自定义文件集成（增强版）..."
              "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" integrate_custom_files
              
              # 验证集成结果
              echo ""
              echo "🔍 验证集成结果..."
              cd /mnt/openwrt-build
              
              # 检查自定义文件目录
              if [ -d "files/etc/custom-files" ]; then
                echo "✅ 自定义文件已复制到: files/etc/custom-files"
                
                # 统计复制后的文件
                FINAL_FILES=$(find "files/etc/custom-files" -type f 2>/dev/null | wc -l)
                echo "📊 复制后文件总数: $FINAL_FILES 个"
                
                # 显示目录结构 - 显示所有文件
                if [ $FINAL_FILES -gt 0 ]; then
                  echo "📁 复制后的所有文件列表:"
                  find "files/etc/custom-files" -type f 2>/dev/null | while read file; do
                    REL_PATH="${file#files/etc/custom-files/}"
                    FILE_SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                    echo "  📄 $REL_PATH ($FILE_SIZE)"
                  done
                fi
                
                # 检查启动脚本
                if [ -f "files/etc/uci-defaults/99-custom-files" ]; then
                  echo "✅ 第一次开机启动脚本: files/etc/uci-defaults/99-custom-files"
                  echo "📝 脚本增强功能:"
                  echo "  - ✅ 递归查找所有自定义文件"
                  echo "  - ✅ 保持原文件名"
                  echo "  - ✅ IPK安装错误不退出，继续下一个"
                  echo "  - ✅ 详细日志记录每个文件的处理结果"
                  echo "  - ✅ 分类统计和成功率计算"
                  echo "  - ✅ 日志存储到 /root/logs/ 目录（重启不丢失）"
                  echo "  - ✅ 预创建Samba配置文件，修复编译错误"
                fi
                
                # 检查文件名检查脚本
                if [ -f "files/etc/custom-files/check_filenames.sh" ]; then
                  echo "✅ 文件名检查脚本: files/etc/custom-files/check_filenames.sh"
                fi
                
                echo ""
                echo "🎯 增强版功能说明:"
                echo "  🔧 递归查找: 支持自定义目录下的所有子目录"
                echo "  📝 保持原文件名: 不自动重命名，保持用户设置的文件名"
                echo "  🔄 错误不退出: IPK安装失败继续安装下一个"
                echo "  📊 详细日志: 记录每个文件的处理结果和统计信息"
                echo "  📁 持久日志: 日志存储在 /root/logs/（重启不丢失）"
                echo "  🔧 Samba预配置: 预创建Samba配置文件，解决编译错误"
                
                if [ $NON_ENGLISH_COUNT -gt 0 ]; then
                  echo ""
                  echo "⚠️ 文件名兼容性提醒:"
                  echo "  当前有 $NON_ENGLISH_COUNT 个文件使用非英文文件名"
                  echo "  系统会自动处理，但建议改为英文文件名"
                  echo "  可以在固件启动后运行: /etc/custom-files/check_filenames.sh"
                fi
                
              else
                echo "❌ 未找到自定义文件目录"
              fi
              
            fi
            
            echo ""
            echo "🎉 自定义文件集成完成"
            echo "💡 自定义文件将在第一次开机时自动安装和运行"
            echo "📌 安装顺序: IPK包 → 脚本文件 → 其他文件"
            echo "🔧 错误处理: 单个文件安装失败不会影响其他文件"
            echo "📁 日志位置: /root/logs/（重启不丢失）"
            
          else
            echo "ℹ️ 自定义文件目录不存在: $CUSTOM_DIR"
            echo "📁 跳过自定义文件集成"
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 20 完成"

      # ⚠️⚠️⚠️ 步骤 21: 前置错误检查（立即退出版）- 增强版，自动修复配置问题 ⚠️⚠️⚠️
      - name: "21. 前置错误检查（立即退出版）- 增强版，自动修复配置问题"
        run: |
          echo "=== 步骤 21: 前置错误检查（立即退出版）- 增强版，自动修复配置问题 ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 任何错误立即退出并显示具体原因
          set -e
          trap 'echo "❌ 步骤 21 失败，退出代码: $?"; exit 1' ERR
          
          echo "🔍 检查当前环境..."
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            source /mnt/openwrt-build/build_env.sh
            echo "✅ 加载环境变量: SELECTED_BRANCH=$SELECTED_BRANCH, TARGET=$TARGET"
            echo "✅ COMPILER_DIR=$COMPILER_DIR"
            echo "✅ CONFIG_MODE=$CONFIG_MODE"
          else
            echo "❌ 错误: 环境文件不存在 (/mnt/openwrt-build/build_env.sh)"
            echo "💡 请检查步骤6和步骤7是否成功执行"
            exit 1
          fi
          
          cd /mnt/openwrt-build
          echo "=== 🚨 前置错误检查（立即退出版）- 增强版 ==="
          
          # 1. 检查配置文件
          echo ""
          echo "1. ✅ 配置文件检查:"
          if [ -f ".config" ]; then
            echo "  ✅ .config 文件存在"
            echo "  📊 文件大小: $(ls -lh .config | awk '{print $5}')"
            echo "  📝 文件行数: $(wc -l < .config)"
          else
            echo "  ❌ 错误: .config 文件不存在"
            echo "  💡 请检查步骤13智能配置生成是否成功"
            exit 1
          fi
          
          # 2. SDK目录检查 - 关键检查
          echo ""
          echo "2. ✅ SDK目录检查:"
          if [ -n "$COMPILER_DIR" ] && [ -d "$COMPILER_DIR" ]; then
            echo "  ✅ SDK目录存在: $COMPILER_DIR"
            echo "  📊 目录大小: $(du -sh "$COMPILER_DIR" 2>/dev/null | cut -f1 || echo '未知')"
            
            # 检查GCC编译器 - 排除虚假的dummy-tools
            GCC_FILE=$(find "$COMPILER_DIR" -type f -executable \
              -name "*gcc" \
              ! -name "*gcc-ar" \
              ! -name "*gcc-ranlib" \
              ! -name "*gcc-nm" \
              ! -path "*dummy-tools*" \
              ! -path "*scripts*" \
              2>/dev/null | head -1)
            
            if [ -n "$GCC_FILE" ] && [ -x "$GCC_FILE" ]; then
              echo "  ✅ 找到可执行GCC编译器: $(basename "$GCC_FILE")"
              echo "  🔧 GCC版本: $("$GCC_FILE" --version 2>&1 | head -1)"
            else
              echo "  ❌ 错误: SDK目录中未找到真正的GCC编译器"
              echo "  💡 COMPILER_DIR=$COMPILER_DIR"
              echo "  📁 目录内容 (前20项):"
              ls -la "$COMPILER_DIR" | head -20
              
              # 检查是否有虚假的dummy-tools
              DUMMY_GCC=$(find "$COMPILER_DIR" -type f -executable -name "*gcc" -path "*dummy-tools*" 2>/dev/null | head -1)
              if [ -n "$DUMMY_GCC" ]; then
                echo "  ⚠️ 检测到虚假的dummy-tools编译器: $DUMMY_GCC"
                echo "  💡 这是OpenWrt构建系统的占位符，不是真正的编译器"
                echo "  💡 请检查SDK是否正确解压"
              fi
              exit 1
            fi
          else
            echo "  ❌ 错误: SDK目录不存在: $COMPILER_DIR"
            echo "  💡 请检查步骤7 SDK下载是否成功"
            echo "  📁 当前/mnt/openwrt-build目录内容:"
            ls -la /mnt/openwrt-build | head -20
            exit 1
          fi
          
          # 3. 检查feeds
          echo ""
          echo "3. ✅ Feeds检查:"
          if [ -d "feeds" ]; then
            echo "  ✅ feeds 目录存在"
            echo "  📊 feeds目录大小: $(du -sh feeds 2>/dev/null | cut -f1 || echo '未知')"
            
            # 检查是否有feeds已更新
            if [ -f "feeds.conf" ] || [ -f "feeds.conf.default" ]; then
              echo "  ✅ feeds配置文件存在"
            else
              echo "  ⚠️ 警告: feeds配置文件不存在"
            fi
          else
            echo "  ❌ 错误: feeds 目录不存在"
            echo "  💡 请检查步骤10配置Feeds是否成功"
            exit 1
          fi
          
          # 4. 检查依赖包目录
          echo ""
          echo "4. ✅ 依赖包检查:"
          if [ -d "dl" ]; then
            DL_COUNT=$(find dl -type f 2>/dev/null | wc -l)
            echo "  ✅ dl 目录存在，文件数: $DL_COUNT 个"
            echo "  📊 dl目录大小: $(du -sh dl 2>/dev/null | cut -f1 || echo '未知')"
            
            if [ $DL_COUNT -eq 0 ]; then
              echo "  ⚠️ 警告: dl目录为空，编译时会下载依赖包"
            fi
          else
            echo "  ⚠️ 警告: dl 目录不存在，将在编译时创建并下载依赖"
          fi
          
          # 5. 检查磁盘空间
          echo ""
          echo "5. ✅ 磁盘空间检查:"
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1 | awk '{print $1}')
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "  📊 /mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 10 ]; then
            echo "  ❌ 错误: 磁盘空间不足 (需要至少10G，当前${AVAILABLE_GB}G)"
            echo "  💡 请清理磁盘空间或增加存储"
            exit 1
          elif [ $AVAILABLE_GB -lt 20 ]; then
            echo "  ⚠️ 警告: 磁盘空间较低 (建议至少20G，当前${AVAILABLE_GB}G)"
          else
            echo "  ✅ 磁盘空间充足"
          fi
          
          # 6. 检查USB 3.0配置 - 关键修复
          echo ""
          echo "6. ✅ USB 3.0配置检查（自动修复）:"
          USB_FIXED=0
          
          if ! grep -q "^CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" .config; then
            echo "  ❌ 错误: USB 3.0驱动未启用 (kmod-usb-xhci-hcd)"
            echo "  🔧 正在自动修复..."
            echo "CONFIG_PACKAGE_kmod-usb-xhci-hcd=y" >> .config
            echo "  ✅ 已强制添加: kmod-usb-xhci-hcd"
            USB_FIXED=1
          else
            echo "  ✅ kmod-usb-xhci-hcd: 已启用"
          fi
          
          if ! grep -q "^CONFIG_PACKAGE_kmod-usb3=y" .config; then
            echo "  ❌ 错误: USB 3.0驱动未启用 (kmod-usb3)"
            echo "  🔧 正在自动修复..."
            echo "CONFIG_PACKAGE_kmod-usb3=y" >> .config
            echo "  ✅ 已强制添加: kmod-usb3"
            USB_FIXED=1
          else
            echo "  ✅ kmod-usb3: 已启用"
          fi
          
          # 根据平台添加专用USB驱动
          if [ "$TARGET" = "ipq40xx" ] || grep -q "^CONFIG_TARGET_ipq40xx=y" .config 2>/dev/null; then
            if ! grep -q "^CONFIG_PACKAGE_kmod-usb-dwc3-qcom=y" .config; then
              echo "  ℹ️ 检测到IPQ40xx平台，添加专用驱动..."
              echo "CONFIG_PACKAGE_kmod-usb-dwc3-qcom=y" >> .config
              echo "  ✅ 已添加: kmod-usb-dwc3-qcom"
              USB_FIXED=1
            fi
            if ! grep -q "^CONFIG_PACKAGE_kmod-phy-qcom-dwc3=y" .config; then
              echo "CONFIG_PACKAGE_kmod-phy-qcom-dwc3=y" >> .config
              echo "  ✅ 已添加: kmod-phy-qcom-dwc3"
              USB_FIXED=1
            fi
          fi
          
          if [ $USB_FIXED -eq 1 ]; then
            echo "  🔄 运行 make defconfig 应用USB配置修复..."
            make defconfig
            echo "  ✅ USB配置修复完成"
          fi
          
          # 7. 检查TurboACC配置（正常模式）- 关键修复
          echo ""
          echo "7. ✅ TurboACC配置检查（自动修复）:"
          TURBOACC_FIXED=0
          
          if [ "$CONFIG_MODE" = "normal" ]; then
            if ! grep -q "^CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
              echo "  ❌ 错误: TurboACC未启用 (正常模式必需)"
              echo "  🔧 正在自动修复..."
              echo "CONFIG_PACKAGE_luci-app-turboacc=y" >> .config
              echo "  ✅ 已强制添加: luci-app-turboacc"
              TURBOACC_FIXED=1
            else
              echo "  ✅ luci-app-turboacc: 已启用"
            fi
            
            if ! grep -q "^CONFIG_PACKAGE_kmod-shortcut-fe=y" .config; then
              echo "  ❌ 错误: kmod-shortcut-fe未启用 (TurboACC必需)"
              echo "  🔧 正在自动修复..."
              echo "CONFIG_PACKAGE_kmod-shortcut-fe=y" >> .config
              echo "  ✅ 已强制添加: kmod-shortcut-fe"
              TURBOACC_FIXED=1
            else
              echo "  ✅ kmod-shortcut-fe: 已启用"
            fi
            
            if ! grep -q "^CONFIG_PACKAGE_kmod-fast-classifier=y" .config; then
              echo "  ❌ 错误: kmod-fast-classifier未启用 (TurboACC必需)"
              echo "  🔧 正在自动修复..."
              echo "CONFIG_PACKAGE_kmod-fast-classifier=y" >> .config
              echo "  ✅ 已强制添加: kmod-fast-classifier"
              TURBOACC_FIXED=1
            else
              echo "  ✅ kmod-fast-classifier: 已启用"
            fi
          else
            echo "  ℹ️ 基础模式，不检查TurboACC配置"
          fi
          
          # 8. 检查TCP BBR配置
          echo ""
          echo "8. ✅ TCP BBR拥塞控制检查（自动修复）:"
          BBR_FIXED=0
          
          if ! grep -q "^CONFIG_PACKAGE_kmod-tcp-bbr=y" .config; then
            echo "  ❌ 错误: TCP BBR未启用"
            echo "  🔧 正在自动修复..."
            echo "CONFIG_PACKAGE_kmod-tcp-bbr=y" >> .config
            echo "  ✅ 已强制添加: kmod-tcp-bbr"
            BBR_FIXED=1
          else
            echo "  ✅ kmod-tcp-bbr: 已启用"
          fi
          
          if ! grep -q "^CONFIG_DEFAULT_TCP_CONG=\"bbr\"" .config; then
            echo "  ❌ 错误: 默认拥塞控制算法未设置为BBR"
            echo "  🔧 正在自动修复..."
            echo "CONFIG_DEFAULT_TCP_CONG=\"bbr\"" >> .config
            echo "  ✅ 已设置默认拥塞控制算法: BBR"
            BBR_FIXED=1
          fi
          
          # 9. 检查kmod-ath10k-ct冲突 - 关键修复
          echo ""
          echo "9. ✅ kmod-ath10k-ct冲突检查（自动修复）:"
          ATH10K_FIXED=0
          
          if grep -q "^CONFIG_PACKAGE_kmod-ath10k=y" .config; then
            echo "  ⚠️ 发现冲突: kmod-ath10k 已启用"
            echo "  🔧 正在自动修复..."
            sed -i 's/^CONFIG_PACKAGE_kmod-ath10k=y/# CONFIG_PACKAGE_kmod-ath10k is not set/' .config
            echo "  ✅ 已禁用: kmod-ath10k"
            ATH10K_FIXED=1
          fi
          
          if grep -q "^CONFIG_PACKAGE_kmod-ath10k-pci=y" .config; then
            echo "  ⚠️ 发现冲突: kmod-ath10k-pci 已启用"
            echo "  🔧 正在自动修复..."
            sed -i 's/^CONFIG_PACKAGE_kmod-ath10k-pci=y/# CONFIG_PACKAGE_kmod-ath10k-pci is not set/' .config
            echo "  ✅ 已禁用: kmod-ath10k-pci"
            ATH10K_FIXED=1
          fi
          
          if grep -q "^CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers=y" .config; then
            echo "  ⚠️ 发现潜在冲突: kmod-ath10k-ct-smallbuffers 已启用"
            echo "  🔧 正在自动修复..."
            sed -i 's/^CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers=y/# CONFIG_PACKAGE_kmod-ath10k-ct-smallbuffers is not set/' .config
            echo "  ✅ 已禁用: kmod-ath10k-ct-smallbuffers"
            ATH10K_FIXED=1
          fi
          
          if ! grep -q "^CONFIG_PACKAGE_kmod-ath10k-ct=y" .config; then
            echo "  ❌ 错误: kmod-ath10k-ct 未启用"
            echo "  🔧 正在自动修复..."
            echo "CONFIG_PACKAGE_kmod-ath10k-ct=y" >> .config
            echo "  ✅ 已强制添加: kmod-ath10k-ct"
            ATH10K_FIXED=1
          else
            echo "  ✅ kmod-ath10k-ct: 已启用"
          fi
          
          if [ $ATH10K_FIXED -eq 1 ]; then
            echo "  🔄 运行 make defconfig 应用ath10k修复..."
            make defconfig
            echo "  ✅ kmod-ath10k-ct冲突修复完成"
          fi
          
          # 10. 如果修复了任何配置，重新运行defconfig
          if [ $USB_FIXED -eq 1 ] || [ $TURBOACC_FIXED -eq 1 ] || [ $BBR_FIXED -eq 1 ] || [ $ATH10K_FIXED -eq 1 ]; then
            echo ""
            echo "🔄 配置已修复，重新运行 make defconfig..."
            make defconfig
            echo "✅ 所有配置修复完成"
          fi
          
          # 11. 检查build_firmware_main.sh脚本
          echo ""
          echo "11. ✅ 主脚本检查:"
          if [ -f "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" ]; then
            echo "  ✅ 主脚本存在: firmware-config/scripts/build_firmware_main.sh"
            if [ -x "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh" ]; then
              echo "  ✅ 主脚本有执行权限"
            else
              echo "  ❌ 错误: 主脚本没有执行权限"
              chmod +x "${{ github.workspace }}/firmware-config/scripts/build_firmware_main.sh"
              echo "  ✅ 已修复执行权限"
            fi
          else
            echo "  ❌ 错误: 主脚本不存在"
            echo "  💡 请检查步骤1源代码下载是否成功"
            exit 1
          fi
          
          # 所有检查通过
          echo ""
          echo "========================================"
          echo "✅✅✅ 所有前置检查通过，配置已修复，可以开始编译 ✅✅✅"
          echo "========================================"
          echo "📋 编译配置摘要:"
          echo "  - 设备: $DEVICE"
          echo "  - 版本: $SELECTED_BRANCH"
          echo "  - 目标: $TARGET/$SUBTARGET"
          echo "  - 配置模式: $CONFIG_MODE"
          echo "  - SDK目录: $COMPILER_DIR"
          echo "  - 磁盘空间: ${AVAILABLE_GB}G"
          echo "  - USB 3.0驱动: $([ $USB_FIXED -eq 1 ] && echo '已修复' || echo '正常')"
          echo "  - TurboACC: $([ $TURBOACC_FIXED -eq 1 ] && echo '已修复' || echo '正常')"
          echo "  - TCP BBR: $([ $BBR_FIXED -eq 1 ] && echo '已修复' || echo '正常')"
          echo "  - kmod-ath10k-ct: $([ $ATH10K_FIXED -eq 1 ] && echo '已修复' || echo '正常')"
          echo ""
          
          echo "🟢 步骤 21 完成"

      # 步骤 22: 编译固件前的空间检查
      - name: "22. 编译固件前的空间检查"
        run: |
          echo "=== 步骤 22: 编译固件前的空间检查 ==="
          echo "🕐 检查时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 22 失败，退出代码: $?"; exit 1' ERR
          
          df -h /mnt
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1 | awk '{print $1}')
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "/mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 10 ]; then
            echo "❌ 错误: 编译前空间不足 (需要至少10G，当前${AVAILABLE_GB}G)"
            exit 1
          elif [ $AVAILABLE_GB -lt 20 ]; then
            echo "⚠️ 警告: 编译前空间较低 (建议至少20G，当前${AVAILABLE_GB}G)"
          else
            echo "✅ 编译前空间充足"
          fi
          
          echo "🟢 步骤 22 完成"

      # 步骤 23: 编译固件（智能并行优化版）
      - name: "23. 编译固件（智能并行优化版）"
        run: |
          echo "=== 步骤 23: 编译固件（智能并行优化版） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 23 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          # 获取系统信息
          CPU_CORES=$(nproc)
          TOTAL_MEM=$(free -m | awk '/^Mem:/{print $2}')
          
          echo "🔧 系统信息:"
          echo "  CPU核心数: $CPU_CORES"
          echo "  内存大小: ${TOTAL_MEM}MB"
          echo "  并行优化: ${{ env.ENABLE_PARALLEL }}"
          
          # 智能判断最佳并行任务数 - 优化版
          if [ "${{ env.ENABLE_PARALLEL }}" = "true" ]; then
            echo "🧠 智能判断最佳并行任务数..."
            
            # GitHub Actions Runner 优化配置
            if [ $CPU_CORES -ge 4 ]; then
              if [ $TOTAL_MEM -ge 8000 ]; then
                MAKE_JOBS=4
                echo "✅ 检测到高性能Runner (4核+8GB)"
              else
                MAKE_JOBS=3
                echo "✅ 检测到标准Runner (4核)"
              fi
            elif [ $CPU_CORES -ge 2 ]; then
              if [ $TOTAL_MEM -ge 7000 ]; then
                MAKE_JOBS=3
                echo "✅ 检测到GitHub标准Runner (2核7GB)"
              else
                MAKE_JOBS=2
                echo "✅ 检测到2核Runner"
              fi
            else
              MAKE_JOBS=2
              echo "⚠️ 检测到单核Runner"
            fi
            
            echo "🎯 决定使用 $MAKE_JOBS 个并行任务"
          else
            MAKE_JOBS=1
            echo "🔄 禁用并行优化，使用单线程编译"
          fi
          
          echo ""
          echo "🚀 开始编译固件"
          echo "💡 编译配置:"
          echo "  - 并行任务: $MAKE_JOBS"
          echo "  - 设备: ${{ github.event.inputs.device_name }}"
          echo "  - 版本: ${{ github.event.inputs.version_selection }}"
          echo "  - 配置模式: ${{ github.event.inputs.config_mode }}"
          echo "  - 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置编译环境变量
          export FORCE_UNSAFE_CONFIGURE=1
          
          # 开始编译，使用stdbuf防止stdout错误
          START_TIME=$(date +%s)
          stdbuf -oL -eL time make -j$MAKE_JOBS V=s 2>&1 | tee build.log
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          
          echo ""
          echo "📊 编译统计:"
          echo "  - 总耗时: $((DURATION / 60))分钟$((DURATION % 60))秒"
          echo "  - 退出代码: $BUILD_EXIT_CODE"
          
          if [ $BUILD_EXIT_CODE -eq 0 ]; then
            echo "✅ 固件编译成功"
            
            if [ -d "bin/targets" ]; then
              FIRMWARE_COUNT=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
              echo "✅ 生成固件文件: $FIRMWARE_COUNT 个"
              
              # 显示前3个固件文件
              echo "📁 生成的固件文件 (前3个):"
              find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | head -3 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "  📄 $(basename "$file") ($SIZE)"
              done
            fi
          else
            echo "❌ 错误: 编译失败，退出代码: $BUILD_EXIT_CODE"
            echo "🔍 编译日志中的错误摘要:"
            grep -i "error\|failed" build.log | tail -20 || true
            exit $BUILD_EXIT_CODE
          fi
          
          echo "🟢 步骤 23 完成"

      # 步骤 24: 检查构建产物（修复版）
      - name: "24. 检查构建产物（修复版）"
        if: success()
        run: |
          echo "=== 步骤 24: 检查构建产物（修复版） ==="
          echo "🕐 开始时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理
          set -e
          trap 'echo "❌ 步骤 24 失败，退出代码: $?"; exit 1' ERR
          
          cd /mnt/openwrt-build
          
          if [ -d "bin/targets" ]; then
            echo "✅ 找到固件目录"
            
            # 统计各种类型文件
            FIRMWARE_COUNT=0
            PACKAGE_COUNT=0
            OTHER_COUNT=0
            
            # 计算文件数量
            echo "📊 正在统计文件..."
            
            # 统计固件文件（.bin和.img）
            FIRMWARE_COUNT=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            # 统计包文件（.gz和.ipk）
            PACKAGE_COUNT=$(find bin/targets -type f \( -name "*.gz" -o -name "*.ipk" \) 2>/dev/null | wc -l)
            
            # 统计其他文件（排除上面两种类型）
            OTHER_COUNT=$(find bin/targets -type f 2>/dev/null | wc -l)
            OTHER_COUNT=$((OTHER_COUNT - FIRMWARE_COUNT - PACKAGE_COUNT))
            
            echo "=========================================="
            echo "📈 构建产物统计:"
            echo "  固件文件: $FIRMWARE_COUNT 个 (.bin/.img)"
            echo "  包文件: $PACKAGE_COUNT 个 (.gz/.ipk)"
            echo "  其他文件: $OTHER_COUNT 个"
            echo "  总文件数: $((FIRMWARE_COUNT + PACKAGE_COUNT + OTHER_COUNT)) 个"
            echo ""
            
            # 显示所有固件文件的详细信息
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "📁 固件文件详细信息:"
              echo "------------------------------------------"
              find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                FULL_SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
                FILE_NAME=$(basename "$file")
                FILE_PATH=$(echo "$file" | sed "s|/mnt/openwrt-build/||")
                
                echo "🎯 文件: $FILE_NAME"
                echo "  大小: $SIZE ($FULL_SIZE 字节)"
                echo "  路径: $FILE_PATH"
                
                # 判断文件类型
                if [[ "$FILE_NAME" == *factory* ]]; then
                  echo "  类型: 🏭 工厂固件 (用于首次刷机)"
                elif [[ "$FILE_NAME" == *sysupgrade* ]]; then
                  echo "  类型: 🔄 系统升级固件 (用于已安装OpenWrt的设备)"
                elif [[ "$FILE_NAME" == *initramfs* ]]; then
                  echo "  类型: 🚀 内存启动固件 (用于测试和救援)"
                else
                  echo "  类型: 🔧 普通固件"
                fi
                
                echo ""
              done
            else
              echo "⚠️ 警告: 未找到任何固件文件 (.bin/.img)"
              echo "🔍 目录内容 (前10个文件):"
              find bin/targets -type f 2>/dev/null | head -10 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "  📄 $(basename "$file") ($SIZE)"
              done
            fi
            
            # 计算总大小
            echo "📏 大小统计:"
            TOTAL_SIZE=0
            find bin/targets -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
              SIZE=$(stat -c%s "$file" 2>/dev/null || echo "0")
              TOTAL_SIZE=$((TOTAL_SIZE + SIZE))
            done
            
            if [ $TOTAL_SIZE -gt 0 ]; then
              TOTAL_SIZE_MB=$((TOTAL_SIZE / 1024 / 1024))
              echo "  固件总大小: ${TOTAL_SIZE_MB}MB"
              
              if [ $TOTAL_SIZE_MB -lt 5 ]; then
                echo "  ⚠️ 警告: 固件文件可能太小"
              elif [ $TOTAL_SIZE_MB -gt 100 ]; then
                echo "  ⚠️ 警告: 固件文件可能太大"
              else
                echo "  ✅ 固件大小正常"
              fi
            fi
            
            echo "=========================================="
            echo "✅ 构建产物检查完成"
          else
            echo "❌ 错误: 未找到固件目录"
            echo "⚠️ bin/targets目录不存在"
            exit 1
          fi
          
          echo "✅ 完成时间: $(date +'%Y-%m-%d %H:%M:%S')"
          echo "🟢 步骤 24 完成"

      # 步骤 25: 上传固件原始目录（使用精确到秒的时间戳）
      - name: "25. 上传固件原始目录"
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ env.TIMESTAMP_SEC }}
          path: /mnt/openwrt-build/bin/targets/
          retention-days: 7
          if-no-files-found: error

      # 步骤 26: 上传配置文件（使用精确到秒的时间戳）
      - name: "26. 上传配置文件"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: config-${{ env.TIMESTAMP_SEC }}
          path: ${{ github.workspace }}/firmware-config/config-backup/
          retention-days: 7
          if-no-files-found: error

      # 步骤 27: 编译后空间检查（修复版）
      - name: "27. 编译后空间检查（修复版）"
        if: always()
        run: |
          echo "=== 步骤 27: 编译后空间检查（修复版） ==="
          echo "🕐 检查时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，只是检查
          trap 'echo "⚠️ 步骤 27 检查过程中出现错误，继续执行..."' ERR
          
          echo "📊 磁盘使用情况:"
          df -h /mnt
          
          # 修复：使用正确的df选项获取可用空间
          AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1 | awk '{print $1}')
          AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
          echo "/mnt 可用空间: ${AVAILABLE_GB}G"
          
          if [ $AVAILABLE_GB -lt 5 ]; then
            echo "⚠️ 警告: 磁盘空间较低，建议清理"
          else
            echo "✅ 磁盘空间充足"
          fi
          
          echo "🟢 步骤 27 完成"

      # 步骤 28: 编译后总结（增强版）- 移除多余的日期格式
      - name: "28. 编译后总结（增强版）"
        if: always()
        run: |
          echo "=== 步骤 28: 编译后总结（增强版） ==="
          echo "🕐 总结时间: $(date +'%Y-%m-%d %H:%M:%S')"
          
          # 设置错误处理 - 这里不退出，总结不应该失败
          trap 'echo "⚠️ 步骤 28 总结过程中出现错误，继续执行..."' ERR
          
          echo "🚀 构建总结报告"
          echo "========================================"
          echo "设备: ${{ github.event.inputs.device_name }}"
          echo "版本: ${{ github.event.inputs.version_selection }}"
          echo "配置模式: ${{ github.event.inputs.config_mode }}"
          echo "时间戳: ${{ env.TIMESTAMP_SEC }}"
          echo "并行优化: ${{ github.event.inputs.enable_parallel }}"
          echo ""
          
          # 检查构建产物
          if [ -d "/mnt/openwrt-build/bin/targets" ]; then
            # 修复：正确统计固件文件
            FIRMWARE_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            
            echo "📦 构建产物:"
            echo "  固件数量: $FIRMWARE_COUNT 个 (.bin/.img)"
            
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "  产物位置: /mnt/openwrt-build/bin/targets/"
              echo "  下载名称: firmware-${{ env.TIMESTAMP_SEC }}"
              
              # 显示所有固件文件信息
              echo "  固件文件详情:"
              find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                FILE_NAME=$(basename "$file")
                
                if [[ "$FILE_NAME" == *factory* ]]; then
                  TYPE="🏭 工厂固件"
                elif [[ "$FILE_NAME" == *sysupgrade* ]]; then
                  TYPE="🔄 升级固件"
                elif [[ "$FILE_NAME" == *initramfs* ]]; then
                  TYPE="🚀 内存固件"
                else
                  TYPE="🔧 普通固件"
                fi
                
                echo "    🎯 $FILE_NAME ($SIZE) - $TYPE"
              done
              
              # 统计包文件
              PACKAGE_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.gz" -o -name "*.ipk" \) 2>/dev/null | wc -l)
              OTHER_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f 2>/dev/null | wc -l)
              OTHER_COUNT=$((OTHER_COUNT - FIRMWARE_COUNT - PACKAGE_COUNT))
              
              echo "  包文件数量: $PACKAGE_COUNT 个 (.gz/.ipk)"
              echo "  其他文件数量: $OTHER_COUNT 个"
            else
              echo "  ⚠️ 构建结果: 编译完成但未生成固件文件"
              echo "  🔍 已生成的其他文件:"
              find "/mnt/openwrt-build/bin/targets" -type f 2>/dev/null | head -5 | while read file; do
                SIZE=$(ls -lh "$file" 2>/dev/null | awk '{print $5}' || echo "未知")
                echo "    📄 $(basename "$file") ($SIZE)"
              done
            fi
          else
            echo "📦 构建产物: 未生成任何文件"
          fi
          
          # 构建状态总结
          echo ""
          echo "📊 构建状态总结:"
          if [ -d "/mnt/openwrt-build/bin/targets" ]; then
            FIRMWARE_COUNT=$(find "/mnt/openwrt-build/bin/targets" -type f \( -name "*.bin" -o -name "*.img" \) 2>/dev/null | wc -l)
            if [ $FIRMWARE_COUNT -gt 0 ]; then
              echo "  ✅ 构建结果: 成功生成 $FIRMWARE_COUNT 个固件文件"
              echo "  📁 Artifact名称: firmware-${{ env.TIMESTAMP_SEC }}"
            else
              echo "  ⚠️ 构建结果: 编译完成但未生成固件文件"
            fi
          else
            echo "  ❌ 构建结果: 失败"
          fi
          
          # 编译器信息
          echo ""
          echo "🔧 编译器信息:"
          
          # 检查SDK编译器版本
          if [ -d "/mnt/openwrt-build" ]; then
            # 查找真正的GCC，排除虚假编译器
            GCC_FILE=$(find "/mnt/openwrt-build" -type f -executable \
              -name "*gcc" \
              ! -name "*gcc-ar" \
              ! -name "*gcc-ranlib" \
              ! -name "*gcc-nm" \
              ! -path "*dummy-tools*" \
              ! -path "*scripts*" \
              2>/dev/null | head -1)
            
            if [ -n "$GCC_FILE" ] && [ -x "$GCC_FILE" ]; then
              SDK_VERSION=$("$GCC_FILE" --version 2>&1 | head -1)
              MAJOR_VERSION=$(echo "$SDK_VERSION" | grep -o "[0-9]\+" | head -1)
              
              if [ "$MAJOR_VERSION" = "12" ]; then
                echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
                echo "  🎯 SDK GCC: 12.3.0 (OpenWrt 23.05 SDK，用于交叉编译固件)"
              elif [ "$MAJOR_VERSION" = "8" ]; then
                echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
                echo "  🎯 SDK GCC: 8.4.0 (OpenWrt 21.02 SDK，用于交叉编译固件)"
              else
                echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
                echo "  🎯 SDK GCC: $MAJOR_VERSION.x (用于交叉编译固件)"
              fi
            else
              echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
              echo "  🎯 SDK GCC: 未检测到版本（可能检测到虚假的dummy-tools编译器）"
            fi
          else
            echo "  🖥️ 系统GCC: 11.4.0 (用于编译工具链)"
            echo "  🎯 SDK GCC: 未下载SDK，使用自动构建的编译器"
          fi
          
          echo "  💡 这是正常的：系统编译器编译工具链，SDK编译器编译固件"
          
          # SDK下载状态检查
          echo ""
          echo "📦 SDK下载状态:"
          if [ -f "/mnt/openwrt-build/build_env.sh" ]; then
            source /mnt/openwrt-build/build_env.sh
            if [ -n "$COMPILER_DIR" ] && [ -d "$COMPILER_DIR" ]; then
              echo "  ✅ SDK已下载: $COMPILER_DIR"
              echo "  📊 目录大小: $(du -sh "$COMPILER_DIR" 2>/dev/null | cut -f1 || echo '未知')"
            else
              echo "  ❌ SDK未下载或目录不存在"
            fi
          else
            echo "  ❌ 环境文件不存在"
          fi
          
          echo ""
          echo "✅ 构建流程完成"
          echo "📁 所有Artifact使用精确到秒的时间戳命名: ${{ env.TIMESTAMP_SEC }}"
          echo "========================================"
          echo "🟢 步骤 28 完成"

name: OpenWrt 智能固件构建工作流（完整优化版）

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: '设备名称 (如: ac42u, ac58u, mi4a 等)'
        required: true
        default: 'ac42u'
        type: string
      old_device:
        description: '是否为老旧设备 (性能较差的设备建议选择true)'
        required: true
        default: false
        type: boolean
      version_spec:
        description: '版本规格 (可选，如: openwrt-23.05 或 immortalwrt:master)'
        required: false
        type: string
        default: ''
      config_type:
        description: '配置类型 (minimal:基础功能, normal:完整功能, custom:自定义)'
        required: true
        default: 'minimal'
        type: choice
        options:
          - minimal
          - normal
          - custom
      extra_packages:
        description: '额外安装插件 (空格分隔的包名)'
        required: false
        type: string
      disabled_plugins:
        description: '禁用插件 (空格分隔的包名，如: luci-app-accesscontrol luci-app-ddns)'
        required: false
        type: string
        default: ''
      save_config:
        description: '保存配置文件到仓库'
        required: false
        default: true
        type: boolean
      custom_install:
        description: '启用自定义安装 (IPK和脚本)'
        required: false
        default: true
        type: boolean
      enable_cache:
        description: '启用编译缓存 (显著加速后续编译)'
        required: false
        default: true
        type: boolean

env:
  BUILD_DIR: /mnt/openwrt-build
  MIRROR_SOURCE: "tuna"
  CACHE_ENABLED: true

jobs:
  build-firmware:
    runs-on: ubuntu-latest
    
    steps:
    - name: 初始空间检查
      run: |
        echo "=== 初始磁盘空间检查 ==="
        df -h
        AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
        AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
        echo "/mnt 可用空间: ${AVAILABLE_GB}G"
        if [ $AVAILABLE_GB -lt 50 ]; then
          echo "错误: /mnt 空间不足50G"
          exit 1
        fi

    - name: 检出配置仓库
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 设置编译环境
      run: |
        echo "=== 安装编译依赖包 ==="
        sudo apt-get update
        sudo apt-get install -y build-essential libncurses5-dev libssl-dev python3 unzip zlib1g-dev subversion gcc-multilib git curl file
        sudo apt-get install -y ninja-build automake autoconf libtool pkg-config gettext help2man texinfo gawk flex bison rsync wget aria2 python3-pip libelf-dev liblz4-dev zstd libssl-dev libcurl4-openssl-dev
        pip3 install requests urllib3
        echo "✅ 编译环境设置完成"

    - name: 创建构建目录并设置权限
      run: |
        echo "=== 创建构建目录 ==="
        sudo mkdir -p $BUILD_DIR
        sudo chown -R $USER:$USER $BUILD_DIR
        sudo chmod -R 755 $BUILD_DIR
        sudo chmod u+w $BUILD_DIR
        echo "✅ 构建目录创建完成"
        touch $BUILD_DIR/test_write.txt && echo "✅ 写入测试成功" && rm $BUILD_DIR/test_write.txt

    - name: 复制脚本到构建目录
      run: |
        cd $BUILD_DIR
        echo "=== 复制脚本到构建目录 ==="
        cd $GITHUB_WORKSPACE
        VERSION_SCRIPT=$(find . -name "complete_version_detector.sh" -type f | head -1)
        DEVICE_SCRIPT=$(find . -name "device_detection.sh" -type f | head -1)
        ERROR_SCRIPT=$(find . -name "error_analysis.sh" -type f | head -1)
        PRE_DOWNLOAD_SCRIPT=$(find . -name "pre_download.sh" -type f | head -1)
        
        if [ -z "$VERSION_SCRIPT" ] || [ -z "$DEVICE_SCRIPT" ]; then
          echo "❌ 错误: 找不到必要的检测脚本"
          exit 1
        fi
        
        echo "✅ 找到版本检测脚本: $VERSION_SCRIPT"
        echo "✅ 找到设备检测脚本: $DEVICE_SCRIPT"
        
        cp "$VERSION_SCRIPT" $BUILD_DIR/complete_version_detector.sh
        cp "$DEVICE_SCRIPT" $BUILD_DIR/device_detection.sh
        
        if [ -n "$ERROR_SCRIPT" ]; then
          echo "✅ 找到错误分析脚本: $ERROR_SCRIPT"
          cp "$ERROR_SCRIPT" $BUILD_DIR/error_analysis.sh
        else
          echo "⚠️ 警告: 未找到错误分析脚本，将使用内置版本"
        fi

        if [ -n "$PRE_DOWNLOAD_SCRIPT" ]; then
          echo "✅ 找到预下载脚本: $PRE_DOWNLOAD_SCRIPT"
          cp "$PRE_DOWNLOAD_SCRIPT" $BUILD_DIR/pre_download.sh
        fi
        
        cd $BUILD_DIR
        chmod +x complete_version_detector.sh device_detection.sh error_analysis.sh pre_download.sh 2>/dev/null || true
        echo "✅ 脚本复制完成"

    - name: 智能版本检测
      id: version-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能版本检测 ==="
        sudo chown -R $USER:$USER . 2>/dev/null || true
        chmod u+w . 2>/dev/null || true
        
        echo "=== 开始版本检测 ==="
        echo "设备名称: ${{ github.event.inputs.device_name }}"
        echo "版本规格: ${{ github.event.inputs.version_spec }}"
        echo "老旧设备: ${{ github.event.inputs.old_device }}"
        
        set +e
        OUTPUT=$(./complete_version_detector.sh "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_spec }}" "${{ github.event.inputs.old_device }}" 2>&1)
        SCRIPT_EXIT_CODE=$?
        set -e
        
        echo "脚本输出:"
        echo "$OUTPUT"
        echo "脚本退出代码: $SCRIPT_EXIT_CODE"
        
        SELECTED_REPO=$(echo "$OUTPUT" | grep "^SELECTED_REPO=" | head -1 | cut -d'=' -f2)
        SELECTED_BRANCH=$(echo "$OUTPUT" | grep "^SELECTED_BRANCH=" | head -1 | cut -d'=' -f2)
        SELECTED_REPO_URL=$(echo "$OUTPUT" | grep "^SELECTED_REPO_URL=" | head -1 | cut -d'=' -f2)
        
        if [ -n "$SELECTED_REPO" ] && [ -n "$SELECTED_BRANCH" ] && [ -n "$SELECTED_REPO_URL" ]; then
            echo "✅ 从脚本输出中成功提取版本信息"
            echo "SELECTED_REPO=$SELECTED_REPO" >> $GITHUB_ENV
            echo "SELECTED_BRANCH=$SELECTED_BRANCH" >> $GITHUB_ENV
            echo "SELECTED_REPO_URL=$SELECTED_REPO_URL" >> $GITHUB_ENV
            echo "✅ 环境变量已设置:"
            echo "  仓库: $SELECTED_REPO"
            echo "  分支: $SELECTED_BRANCH"
            echo "  URL: $SELECTED_REPO_URL"
        else
            echo "❌ 无法从脚本输出中提取版本信息"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 版本检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但无法提取版本信息，使用默认值"
                echo "SELECTED_REPO=immortalwrt" >> $GITHUB_ENV
                echo "SELECTED_BRANCH=master" >> $GITHUB_ENV
                echo "SELECTED_REPO_URL=https://github.com/immortalwrt/immortalwrt.git" >> $GITHUB_ENV
                echo "✅ 使用默认版本信息"
            fi
        fi

    - name: 备份检测脚本到临时目录
      run: |
        echo "=== 备份检测脚本到临时目录 ==="
        mkdir -p /tmp/build-scripts-backup
        cp $BUILD_DIR/complete_version_detector.sh /tmp/build-scripts-backup/
        cp $BUILD_DIR/device_detection.sh /tmp/build-scripts-backup/
        if [ -f "$BUILD_DIR/error_analysis.sh" ]; then
          cp $BUILD_DIR/error_analysis.sh /tmp/build-scripts-backup/
        fi
        if [ -f "$BUILD_DIR/pre_download.sh" ]; then
          cp $BUILD_DIR/pre_download.sh /tmp/build-scripts-backup/
        fi
        echo "✅ 脚本备份完成"

    - name: 清理构建目录准备克隆
      run: |
        cd $BUILD_DIR
        echo "=== 清理构建目录准备克隆 ==="
        echo "当前目录内容:"
        ls -la
        sudo rm -rf ./* ./.git* 2>/dev/null || true
        sudo rm -rf .[!.]* 2>/dev/null || true
        echo "清理后目录内容:"
        ls -la
        echo "✅ 目录清理完成"

    - name: 克隆选定版本的源码
      run: |
        cd $BUILD_DIR
        echo "=== 克隆选定版本的源码 ==="
        echo "仓库: $SELECTED_REPO_URL"
        echo "分支: $SELECTED_BRANCH"
        
        if [ -z "$SELECTED_REPO_URL" ] || [ -z "$SELECTED_BRANCH" ]; then
          echo "❌ 错误: 环境变量未正确设置"
          exit 1
        fi
        
        echo "检查目录状态..."
        FILE_COUNT=$(ls -A | wc -l)
        if [ $FILE_COUNT -ne 0 ]; then
          echo "❌ 错误: 目录非空，无法克隆"
          exit 1
        fi
        
        MAX_RETRIES=3
        RETRY_COUNT=0
        CLONE_SUCCESS=false
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$CLONE_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "克隆尝试: $RETRY_COUNT/$MAX_RETRIES"
          
          if git clone --depth 1 --branch "$SELECTED_BRANCH" "$SELECTED_REPO_URL" .; then
            echo "✅ 源码克隆完成"
            echo "✅ 成功克隆仓库: $SELECTED_REPO, 分支: $SELECTED_BRANCH"
            CLONE_SUCCESS=true
          else
            echo "❌ 克隆失败，尝试 $RETRY_COUNT/$MAX_RETRIES"
            
            if echo "$SELECTED_REPO_URL" | grep -q "github.com" && [ $RETRY_COUNT -eq 2 ]; then
              echo "🔄 尝试使用镜像源..."
              MIRROR_URL=$(echo "$SELECTED_REPO_URL" | sed 's/github.com/github.com.cnpmjs.org/')
              rm -rf ./* ./.git* 2>/dev/null || true
              if git clone --depth 1 --branch "$SELECTED_BRANCH" "$MIRROR_URL" .; then
                echo "✅ 使用镜像源克隆成功"
                CLONE_SUCCESS=true
                break
              fi
            fi
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "❌ 源码克隆失败，达到最大重试次数"
              exit 1
            fi
            sleep 10
            rm -rf ./* ./.git* 2>/dev/null || true
          fi
        done

    - name: 恢复检测脚本
      run: |
        cd $BUILD_DIR
        echo "=== 恢复检测脚本 ==="
        cp /tmp/build-scripts-backup/complete_version_detector.sh ./
        cp /tmp/build-scripts-backup/device_detection.sh ./
        if [ -f "/tmp/build-scripts-backup/error_analysis.sh" ]; then
          cp /tmp/build-scripts-backup/error_analysis.sh ./
        fi
        if [ -f "/tmp/build-scripts-backup/pre_download.sh" ]; then
          cp /tmp/build-scripts-backup/pre_download.sh ./
        fi
        chmod +x complete_version_detector.sh device_detection.sh error_analysis.sh pre_download.sh 2>/dev/null || true
        echo "✅ 脚本恢复完成"

    - name: 重新复制配置文件和错误分析脚本
      run: |
        cd $BUILD_DIR
        echo "=== 重新复制配置文件和错误分析脚本 ==="
        cd $GITHUB_WORKSPACE
        
        echo "=== 查找配置文件 ==="
        CONFIG_FILES=$(find firmware-config/configs -name "*.config" -type f 2>/dev/null || true)
        if [ -n "$CONFIG_FILES" ]; then
          echo "✅ 找到配置文件:"
          echo "$CONFIG_FILES"
          mkdir -p $BUILD_DIR/config-templates
          for config_file in $CONFIG_FILES; do
            filename=$(basename "$config_file")
            cp "$config_file" $BUILD_DIR/config-templates/
            echo "✅ 复制: $filename"
          done
          echo "✅ 所有配置文件复制完成"
          echo "当前配置模板目录内容:"
          ls -la $BUILD_DIR/config-templates/
        else
          echo "❌ 错误: 未找到任何配置文件"
          exit 1
        fi
        
        # 重新复制错误分析脚本（如果仓库中有更新）
        ERROR_SCRIPT=$(find . -name "error_analysis.sh" -type f | head -1)
        if [ -n "$ERROR_SCRIPT" ]; then
          echo "✅ 找到错误分析脚本: $ERROR_SCRIPT"
          cp "$ERROR_SCRIPT" $BUILD_DIR/error_analysis.sh
          chmod +x $BUILD_DIR/error_analysis.sh
        else
          echo "⚠️ 警告: 未找到错误分析脚本，将使用备份版本"
        fi

        # 重新复制预下载脚本
        PRE_DOWNLOAD_SCRIPT=$(find . -name "pre_download.sh" -type f | head -1)
        if [ -n "$PRE_DOWNLOAD_SCRIPT" ]; then
          echo "✅ 找到预下载脚本: $PRE_DOWNLOAD_SCRIPT"
          cp "$PRE_DOWNLOAD_SCRIPT" $BUILD_DIR/pre_download.sh
          chmod +x $BUILD_DIR/pre_download.sh
        fi
        
        echo "✅ 配置文件和脚本重新复制完成"

    - name: 智能设备检测与别名转换
      id: device-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能设备检测与别名转换 ==="
        
        declare -A DEVICE_ALIAS_MAP
        DEVICE_ALIAS_MAP=(["ac42u"]="asus_rt-ac42u" ["acrh17"]="asus_rt-ac42u" ["rt-acrh17"]="asus_rt-ac42u" ["ac58u"]="asus_rt-ac58u" ["acrh13"]="asus_rt-ac58u" ["rt-ac58u"]="asus_rt-ac58u" ["rt-acrh13"]="asus_rt-ac58u" ["mi4a"]="xiaomi_mi-router-4a-gigabit" ["r4a"]="xiaomi_mi-router-4a-gigabit" ["mi3g"]="xiaomi_mi-router-3g" ["r3g"]="xiaomi_mi-router-3g")
        
        INPUT_DEVICE="${{ github.event.inputs.device_name }}"
        echo "输入设备名称: $INPUT_DEVICE"
        
        if [ -n "${DEVICE_ALIAS_MAP[$INPUT_DEVICE]}" ]; then
          ACTUAL_DEVICE="${DEVICE_ALIAS_MAP[$INPUT_DEVICE]}"
          echo "✅ 检测到设备通用名称 '$INPUT_DEVICE'，转换为实际设备标识 '$ACTUAL_DEVICE'"
        else
          ACTUAL_DEVICE="$INPUT_DEVICE"
          echo "ℹ️ 使用原始设备名称: $ACTUAL_DEVICE (未找到别名映射)"
        fi
        
        if [ ! -f "device_detection.sh" ]; then
          echo "❌ 错误: 设备检测脚本不存在"
          exit 1
        fi
        chmod +x device_detection.sh
        
        echo "=== 开始设备检测 ==="
        TEMP_LOG=$(mktemp)
        
        set +e
        ./device_detection.sh "$ACTUAL_DEVICE" 2>&1 | tee "$TEMP_LOG"
        SCRIPT_EXIT_CODE=$?
        set -e
        
        echo "=== 脚本退出代码: $SCRIPT_EXIT_CODE ==="
        
        PLATFORM=$(grep "^PLATFORM=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_SHORT_NAME=$(grep "^DEVICE_SHORT_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_FULL_NAME=$(grep "^DEVICE_FULL_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        
        echo "=== 提取的设备信息 ==="
        echo "平台(PLATFORM): '$PLATFORM'"
        echo "设备短名称(DEVICE_SHORT_NAME): '$DEVICE_SHORT_NAME'"
        echo "设备全名称(DEVICE_FULL_NAME): '$DEVICE_FULL_NAME'"
        
        rm -f "$TEMP_LOG"
        
        if [ -n "$PLATFORM" ] && [ -n "$DEVICE_SHORT_NAME" ] && [ -n "$DEVICE_FULL_NAME" ]; then
            echo "✅ 从脚本输出中成功提取设备信息"
            echo "PLATFORM=$PLATFORM" >> $GITHUB_ENV
            echo "DEVICE_SHORT_NAME=$DEVICE_SHORT_NAME" >> $GITHUB_ENV
            echo "DEVICE_FULL_NAME=$DEVICE_FULL_NAME" >> $GITHUB_ENV
            echo "✅ 设备环境变量已设置:"
            echo "  平台: $PLATFORM"
            echo "  设备短名称: $DEVICE_SHORT_NAME"
            echo "  设备全名称: $DEVICE_FULL_NAME"
        else
            echo "❌ 无法从脚本输出中提取设备信息"
            if [ $SCRIPT_EXIT_CODE -ne 0 ]; then
                echo "❌ 设备检测失败"
                exit 1
            else
                echo "⚠️ 脚本成功但无法提取设备信息，使用备用设备映射"
                case "$ACTUAL_DEVICE" in
                    "asus_rt-ac42u"|"ac42u"|"acrh17"|"rt-acrh17")
                        echo "PLATFORM=ipq40xx" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=asus_rt-ac42u" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    "asus_rt-ac58u"|"ac58u"|"acrh13"|"rt-acrh13")
                        echo "PLATFORM=ipq40xx" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=asus_rt-ac58u" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    "xiaomi_mi-router-4a-gigabit"|"mi4a"|"r4a")
                        echo "PLATFORM=ramips" >> $GITHUB_ENV
                        echo "DEVICE_SHORT_NAME=xiaomi_mi-router-4a-gigabit" >> $GITHUB_ENV
                        echo "DEVICE_FULL_NAME=$ACTUAL_DEVICE" >> $GITHUB_ENV
                        ;;
                    *)
                        echo "❌ 未知设备，无法设置默认值"
                        exit 1
                        ;;
                esac
                echo "✅ 已使用备用设备信息"
            fi
        fi

    - name: 更新安装feeds
      run: |
        cd $BUILD_DIR
        echo "=== 更新和安装feeds ==="
        ./scripts/feeds update -a
        ./scripts/feeds install -a

    - name: 使用外部配置文件进行配置
      run: |
        cd $BUILD_DIR
        echo "=== 使用外部配置文件进行配置 ==="
        
        > .config
        
        echo "CONFIG_TARGET_${PLATFORM}=y" >> .config
        echo "CONFIG_TARGET_${PLATFORM}_generic=y" >> .config
        
        CORRECT_DEVICE_CONFIG="CONFIG_TARGET_${PLATFORM}_generic_DEVICE_${DEVICE_SHORT_NAME}"
        echo "${CORRECT_DEVICE_CONFIG}=y" >> .config
        echo "使用的设备配置项: ${CORRECT_DEVICE_CONFIG}=y"
        
        echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        echo "CONFIG_TARGET_IMAGES_GZIP=y" >> .config
        echo "CONFIG_TARGET_IMAGES_PAD=y" >> .config
        
        CONFIG_TYPE="${{ github.event.inputs.config_type }}"
        echo "配置类型: $CONFIG_TYPE"
        
        if [ "$CONFIG_TYPE" = "minimal" ]; then
            CONFIG_FILE="config-templates/minimal.config"
        elif [ "$CONFIG_TYPE" = "normal" ] || [ "$CONFIG_TYPE" = "custom" ]; then
            IS_OLD_VERSION=0
            if [ "${{ github.event.inputs.old_device }}" = "true" ]; then
                IS_OLD_VERSION=1
                echo "✅ 用户指定为老旧设备，使用旧版本配置"
            else
                if echo "$SELECTED_BRANCH" | grep -q -E "19\.07|21\.02|17\.01|lede"; then
                    IS_OLD_VERSION=1
                    echo "✅ 检测到旧版本分支: $SELECTED_BRANCH"
                fi
                if [ "$SELECTED_REPO" = "lede" ] || [ "$SELECTED_REPO" = "openwrt-19.07" ] || [ "$SELECTED_REPO" = "openwrt-21.02" ]; then
                    IS_OLD_VERSION=1
                    echo "✅ 检测到旧版本仓库: $SELECTED_REPO"
                fi
                case "${{ github.event.inputs.device_name }}" in
                    "wr841n"|"wr842n"|"wr941n"|"mr3420"|"ar71xx"*)
                        IS_OLD_VERSION=1
                        echo "✅ 检测到老旧设备型号: ${{ github.event.inputs.device_name }}"
                        ;;
                esac
            fi
            
            if [ "$IS_OLD_VERSION" -eq 1 ]; then
                echo "✅ 最终决定: 使用旧版本配置"
                CONFIG_FILE="config-templates/normal-old.config"
            else
                echo "✅ 最终决定: 使用新版本配置"
                CONFIG_FILE="config-templates/normal-new.config"
            fi
        else
            echo "❌ 未知的配置类型: $CONFIG_TYPE"
            exit 1
        fi
        
        if [ -f "$CONFIG_FILE" ]; then
            echo "✅ 找到配置文件: $CONFIG_FILE"
            cat "$CONFIG_FILE" >> .config
            echo "✅ 配置已加载: $(basename "$CONFIG_FILE")"
        else
            echo "❌ 错误: 找不到配置文件 $CONFIG_FILE"
            exit 1
        fi
        
        # 强制启用必要的包
        echo "# 强制启用基础包" >> .config
        echo "CONFIG_PACKAGE_luci-i18n-base-zh-cn=y" >> .config
        echo "CONFIG_PACKAGE_luci-i18n-firewall-zh-cn=y" >> .config
        
        if [ "$CONFIG_TYPE" = "normal" ] || [ "$CONFIG_TYPE" = "custom" ]; then
            echo "# 强制启用正常模式插件" >> .config
            echo "CONFIG_PACKAGE_luci-app-turboacc=y" >> .config
            echo "CONFIG_PACKAGE_luci-app-sqm=y" >> .config
        fi
        
        if [ "$CONFIG_TYPE" = "custom" ] && [ -n "${{ github.event.inputs.extra_packages }}" ]; then
            echo "# 额外包配置" >> .config
            for pkg in ${{ github.event.inputs.extra_packages }}; do
                pkg_clean=$(echo "$pkg" | tr '-' '_' | tr -cd '[:alnum:]_')
                echo "CONFIG_PACKAGE_${pkg_clean}=y" >> .config
                echo "✅ 添加额外包: CONFIG_PACKAGE_${pkg_clean}=y"
            done
        fi
        
        if [ -n "${{ github.event.inputs.disabled_plugins }}" ]; then
            echo "# 禁用插件配置" >> .config
            for plugin in ${{ github.event.inputs.disabled_plugins }}; do
                plugin_clean=$(echo "$plugin" | tr '-' '_' | tr -cd '[:alnum:]_')
                echo "# CONFIG_PACKAGE_${plugin_clean} is not set" >> .config
                echo "✅ 禁用插件: $plugin (CONFIG_PACKAGE_${plugin_clean})"
            done
        fi
        
        echo "运行 make defconfig..."
        make defconfig
        
        echo "=== 最终配置验证 ==="
        if grep -q "^${CORRECT_DEVICE_CONFIG}=y" .config; then
            echo "✅ 设备 $DEVICE_SHORT_NAME 已成功启用"
        else
            echo "❌ 设备 $DEVICE_SHORT_NAME 启用失败，构建终止"
            exit 1
        fi

    - name: 构建时集成自定义文件
      if: github.event.inputs.custom_install == 'true'
      run: |
        cd $BUILD_DIR
        echo "=== 构建时集成自定义文件 ==="
        
        # 创建自定义目录
        mkdir -p files/root/custom-install
        
        # 复制IPK文件
        cd $GITHUB_WORKSPACE
        IPK_FILES=$(find firmware-config/custom-files -name "*.ipk" -type f 2>/dev/null || true)
        if [ -n "$IPK_FILES" ]; then
            echo "✅ 找到IPK文件:"
            echo "$IPK_FILES"
            for ipk in $IPK_FILES; do
                cp "$ipk" $BUILD_DIR/files/root/custom-install/
                echo "✅ 复制IPK: $(basename "$ipk")"
            done
        else
            echo "ℹ️ 未找到IPK文件"
        fi
        
        # 复制脚本文件
        SCRIPT_FILES=$(find firmware-config/custom-files -name "*.sh" -type f 2>/dev/null | grep -v "detector\|analysis" || true)
        if [ -n "$SCRIPT_FILES" ]; then
            echo "✅ 找到脚本文件:"
            echo "$SCRIPT_FILES"
            for script in $SCRIPT_FILES; do
                cp "$script" $BUILD_DIR/files/root/custom-install/
                chmod +x $BUILD_DIR/files/root/custom-install/$(basename "$script")
                echo "✅ 复制脚本: $(basename "$script")"
            done
        else
            echo "ℹ️ 未找到脚本文件"
        fi
        
        # 创建构建时安装脚本 - 使用本地opkg安装
        echo '#!/bin/sh' > $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'echo "=== 开始构建时自定义安装 ==="' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '# 构建时安装IPK文件 - 使用本地opkg安装' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'if ls /root/custom-install/*.ipk >/dev/null 2>&1; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "构建时安装IPK文件..."' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    for ipk in /root/custom-install/*.ipk; do' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        echo "安装: $(basename $ipk)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        # 使用opkg本地安装，不依赖网络' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        opkg install "$ipk" --force-depends || echo "安装失败: $(basename $ipk)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    done' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'else' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "未找到IPK文件"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '# 执行构建时脚本' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'if ls /root/custom-install/*.sh >/dev/null 2>&1; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "执行构建时脚本..."' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    for script in /root/custom-install/*.sh; do' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        if [ "$(basename $script)" != "build-time-install.sh" ]; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '            echo "执行: $(basename $script)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '            sh "$script" || echo "执行失败: $(basename $script)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    done' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'else' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "未找到脚本文件"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '# 清理安装文件' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'rm -rf /root/custom-install' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'echo "=== 构建时自定义安装完成 ==="' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        
        chmod +x $BUILD_DIR/files/root/custom-install/build-time-install.sh
        
        # 创建开机执行脚本，在系统启动时运行构建时安装
        mkdir -p $BUILD_DIR/files/etc
        echo '#!/bin/sh' > $BUILD_DIR/files/etc/rc.local
        echo '' >> $BUILD_DIR/files/etc/rc.local
        echo '# 在后台执行构建时自定义安装' >> $BUILD_DIR/files/etc/rc.local
        echo '[ -f /root/custom-install/build-time-install.sh ] && {' >> $BUILD_DIR/files/etc/rc.local
        echo '    /root/custom-install/build-time-install.sh >/tmp/build-time-install.log 2>&1 &' >> $BUILD_DIR/files/etc/rc.local
        echo '}' >> $BUILD_DIR/files/etc/rc.local
        echo '' >> $BUILD_DIR/files/etc/rc.local
        echo 'exit 0' >> $BUILD_DIR/files/etc/rc.local
        
        chmod +x $BUILD_DIR/files/etc/rc.local
        echo "✅ 构建时自定义安装配置完成"

    - name: 修复网络和下载环境
      run: |
        cd $BUILD_DIR
        echo "=== 修复网络和下载环境 ==="
        
        # 设置Git和curl重试
        git config --global http.postBuffer 524288000
        git config --global http.lowSpeedLimit 0
        git config --global http.lowSpeedTime 999999
        
        # 设置环境变量
        export GIT_SSL_NO_VERIFY=1
        export PYTHONHTTPSVERIFY=0
        
        # 创建下载目录并设置权限
        mkdir -p dl
        chmod 755 dl
        
        echo "✅ 网络环境修复完成"

    - name: 运行预下载脚本
      run: |
        cd $BUILD_DIR
        echo "=== 运行预下载脚本 ==="
        
        if [ -f "pre_download.sh" ]; then
            chmod +x pre_download.sh
            echo "开始预下载常见依赖包..."
            ./pre_download.sh
            echo "✅ 预下载完成"
        else
            echo "⚠️ 未找到预下载脚本，跳过预下载步骤"
        fi

    - name: 加强下载DL库并验证完整性
      run: |
        cd $BUILD_DIR
        echo "=== 加强下载DL库并验证完整性 ==="
        
        mkdir -p dl
        chmod 755 dl
        
        export GIT_SSL_NO_VERIFY=1
        export PYTHONHTTPSVERIFY=0
        
        # 设置国内镜像源
        echo "=== 设置国内镜像源: $MIRROR_SOURCE ==="
        case "$MIRROR_SOURCE" in
            "tuna")
                MIRROR_URL="https://mirrors.tuna.tsinghua.edu.cn/openwrt"
                ;;
            "ustc")
                MIRROR_URL="https://mirrors.ustc.edu.cn/openwrt"
                ;;
            "tencent")
                MIRROR_URL="https://mirrors.cloud.tencent.com/openwrt"
                ;;
            "huawei")
                MIRROR_URL="https://mirrors.huaweicloud.com/openwrt"
                ;;
            *)
                MIRROR_URL="https://mirrors.tuna.tsinghua.edu.cn/openwrt"
                ;;
        esac
        
        # 设置feeds.conf.default使用镜像
        if [ -f "feeds.conf.default" ]; then
            cp feeds.conf.default feeds.conf.default.backup
            sed -i "s|https://github.com|$MIRROR_URL|g" feeds.conf.default
            sed -i "s|git://github.com|$MIRROR_URL|g" feeds.conf.default
            echo "✅ 已设置feeds镜像源"
        fi
        
        MAX_DOWNLOAD_RETRIES=5
        RETRY_COUNT=0
        DOWNLOAD_SUCCESS=false
        
        # 预先下载关键依赖
        echo "=== 预先下载关键依赖 ==="
        make -j1 tools/install V=s 2>&1 | grep -E "Downloading|error" || true
        make -j1 toolchain/install V=s 2>&1 | grep -E "Downloading|error" || true
        
        # 清理可能损坏的文件
        find dl -name "*.tmp" -delete 2>/dev/null || true
        find dl -size 0 -delete 2>/dev/null || true
        
        while [ $RETRY_COUNT -lt $MAX_DOWNLOAD_RETRIES ] && [ "$DOWNLOAD_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "=== 下载尝试 $RETRY_COUNT/$MAX_DOWNLOAD_RETRIES ==="
          
          # 使用单线程下载确保稳定性
          if make -j1 download V=s 2>&1 | tee download_attempt_${RETRY_COUNT}.log; then
            echo "✅ 下载命令执行成功"
            
            # 检查是否有关键错误
            if grep -q "404" download_attempt_${RETRY_COUNT}.log; then
              echo "⚠️ 检测到404错误，尝试修复..."
              # 记录失败的包
              FAILED_PACKAGES=$(grep "404" download_attempt_${RETRY_COUNT}.log | grep -oE '[a-zA-Z0-9_.-]+\.(tar\.|zip|gz|bz2)' | sort -u)
              if [ -n "$FAILED_PACKAGES" ]; then
                echo "有问题的包: $FAILED_PACKAGES"
                for pkg in $FAILED_PACKAGES; do
                  find dl -name "*$pkg*" -delete 2>/dev/null || true
                done
                # 继续重试
                continue
              fi
            else
              DOWNLOAD_SUCCESS=true
            fi
          else
            echo "❌ 下载命令执行失败"
            
            if [ $RETRY_COUNT -eq $MAX_DOWNLOAD_RETRIES ]; then
              echo "❌ 达到最大重试次数，下载失败"
              echo "=== 最后尝试单线程下载 ==="
              make -j1 download V=s
              break
            else
              echo "🔄 等待15秒后重试..."
              sleep 15
              # 清理可能的损坏文件
              find dl -name "*.tmp" -delete 2>/dev/null || true
              find dl -size 0 -delete 2>/dev/null || true
            fi
          fi
        done
        
        echo "=== 下载完整性详细检查 ==="
        EMPTY_FILES=$(find dl -type f -size 0 2>/dev/null | wc -l)
        if [ "$EMPTY_FILES" -gt 0 ]; then
          echo "❌ 发现 $EMPTY_FILES 个空文件，删除后重新下载..."
          find dl -type f -size 0 -delete
          echo "重新下载空文件..."
          make -j1 download V=s
        fi
        
        # 验证关键文件
        echo "=== 验证关键文件 ==="
        CRITICAL_FILES=("lz4" "zlib" "openssl" "libtool" "automake")
        for file in "${CRITICAL_FILES[@]}"; do
          if find dl -name "*${file}*" | grep -q .; then
            echo "✅ 找到关键文件: $file"
          else
            echo "⚠️ 未找到关键文件: $file"
          fi
        done
        
        DL_COUNT=$(find dl -type f | wc -l)
        DL_SIZE=$(du -sh dl | cut -f1)
        echo "✅ 下载统计: $DL_COUNT 个文件，总大小: $DL_SIZE"

    - name: 验证软件包配置
      run: |
        cd $BUILD_DIR
        echo "=== 验证软件包配置 ==="
        
        # 检查关键软件包是否被正确配置
        echo "=== 关键软件包配置状态 ==="
        
        # 基础软件包
        for pkg in "luci" "luci-base" "luci-theme-bootstrap"; do
          if grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
            echo "✅ $pkg: 已启用"
          else
            echo "❌ $pkg: 未启用"
          fi
        done
        
        # 中文语言包
        for pkg in "luci-i18n-base-zh-cn" "luci-i18n-firewall-zh-cn"; do
          if grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
            echo "✅ $pkg: 已启用"
          else
            echo "❌ $pkg: 未启用"
          fi
        done
        
        # 根据配置类型检查插件
        if [ "${{ github.event.inputs.config_type }}" = "normal" ] || [ "${{ github.event.inputs.config_type }}" = "custom" ]; then
          echo "=== 正常模式插件检查 ==="
          for pkg in "luci-app-turboacc" "luci-app-sqm" "luci-app-upnp"; do
            if grep -q "CONFIG_PACKAGE_${pkg}=y" .config; then
              echo "✅ $pkg: 已启用"
            else
              echo "❌ $pkg: 未启用"
            fi
          done
        fi
        
        echo "=== 配置验证完成 ==="

    - name: 应用配置并编译
      run: |
        cd $BUILD_DIR
        echo "::group::📱 编译日志"
        echo "编译开始时间: $(date)"
        
        export FORCE_UNSAFE_CONFIGURE=1
        
        # 更保守的并行设置，避免内存不足
        AVAILABLE_CORES=$(nproc)
        AVAILABLE_MEMORY_GB=$(free -g | awk 'NR==2{print $2}')
        
        if [ $AVAILABLE_MEMORY_GB -ge 16 ] && [ $AVAILABLE_CORES -ge 8 ]; then
            BUILD_JOBS=$((AVAILABLE_CORES - 3))
            echo "✅ 高性能模式: 使用 $BUILD_JOBS 个并行任务 (内存: ${AVAILABLE_MEMORY_GB}G)"
        elif [ $AVAILABLE_MEMORY_GB -ge 8 ] && [ $AVAILABLE_CORES -ge 4 ]; then
            BUILD_JOBS=$((AVAILABLE_CORES - 2))
            echo "✅ 平衡模式: 使用 $BUILD_JOBS 个并行任务 (内存: ${AVAILABLE_MEMORY_GB}G)"
        else
            BUILD_JOBS=2
            echo "✅ 保守模式: 使用 $BUILD_JOBS 个并行任务 (内存: ${AVAILABLE_MEMORY_GB}G)"
        fi
        
        echo "🚀 开始分阶段编译..."
        START_TIME=$(date +%s)
        
        # 分阶段编译，提高稳定性
        echo "=== 阶段1: 编译工具链 ==="
        make -j$BUILD_JOBS tools/compile V=s 2>&1 | tee -a build_detailed.log
        
        echo "=== 阶段2: 编译工具 ==="
        make -j$BUILD_JOBS toolchain/compile V=s 2>&1 | tee -a build_detailed.log
        
        echo "=== 阶段3: 完整编译 ==="
        set +e
        time make -j$BUILD_JOBS V=s 2>&1 | tee -a build_detailed.log
        COMPILE_EXIT_CODE=$?
        set -e
        
        END_TIME=$(date +%s)
        
        COMPILE_TIME=$((END_TIME - START_TIME))
        echo "=== 编译时间统计 ==="
        echo "总编译时间: $((COMPILE_TIME / 60))分钟$((COMPILE_TIME % 60))秒"
        
        if [ -d "bin/targets" ]; then
            echo "::endgroup::"
            echo "::notice::🎉 编译成功完成！"
            echo "✅ 编译完成，找到目标文件"
            FIRMWARE_LIST=$(find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) 2>/dev/null | sort)
            if [ -n "$FIRMWARE_LIST" ]; then
                echo "🎉 生成的固件:"
                echo "$FIRMWARE_LIST"
            fi
            if [ $COMPILE_EXIT_CODE -ne 0 ]; then
                echo "⚠️ 编译过程有警告，但生成了固件文件"
            fi
        else
            echo "::endgroup::"
            echo "::notice::❌ 编译失败"
            echo "❌ 编译失败，未生成目标文件"
            if [ $COMPILE_EXIT_CODE -eq 0 ]; then
                echo "❌ 编译命令成功但未生成目标文件"
                echo "=== 构建目录结构 ==="
                find . -maxdepth 3 -type d | sort | head -20
            fi
            exit 1
        fi

    - name: 运行错误分析并自动修复
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 运行错误分析并自动修复 ==="
        
        # 检查常见的下载失败包
        if grep -q "csstidy.*404" build_detailed.log; then
            echo "🔄 检测到csstidy下载失败，尝试手动修复..."
            rm -f dl/csstidy* 2>/dev/null || true
            wget -O dl/csstidy-fixed.tar.gz "https://gitee.com/mirrors/csstidy/repository/archive/707feaec556c40c999514a598b1a1ea5b50826c6.tar.gz" || true
        fi
        
        if [ ! -f "error_analysis.sh" ]; then
            echo "创建基础错误分析脚本..."
            cat > error_analysis.sh << 'EOF'
#!/bin/bash
set -e

BUILD_DIR="${1:-.}"
LOG_FILE="$BUILD_DIR/build_detailed.log"
REPORT_FILE="$BUILD_DIR/error_analysis.log"

echo "=== 固件构建错误分析报告 ===" > "$REPORT_FILE"
echo "生成时间: $(date)" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

if [ ! -f "$LOG_FILE" ]; then
    echo "❌ 错误: 找不到构建日志文件 $LOG_FILE" | tee -a "$REPORT_FILE"
    exit 1
fi

echo "=== 构建结果摘要 ===" >> "$REPORT_FILE"
if [ -d "$BUILD_DIR/bin/targets" ]; then
    echo "✅ 构建状态: 成功" >> "$REPORT_FILE"
    FIRMWARE_FILES=$(find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) 2>/dev/null | wc -l)
    echo "✅ 生成的固件文件: $FIRMWARE_FILES" >> "$REPORT_FILE"
    find "$BUILD_DIR/bin/targets" -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) 2>/dev/null >> "$REPORT_FILE"
else
    echo "❌ 构建状态: 失败" >> "$REPORT_FILE"
fi

echo "" >> "$REPORT_FILE"
echo "=== 关键错误检查 ===" >> "$REPORT_FILE"

# 详细错误分类统计
ERROR_COUNT=$(grep -c "error:" "$LOG_FILE" 2>/dev/null || true)
WARNING_COUNT=$(grep -c "warning:" "$LOG_FILE" 2>/dev/null || true)
CURL_404_COUNT=$(grep -c "curl.*404" "$LOG_FILE" 2>/dev/null || true)
BROKEN_PIPE_COUNT=$(grep -c "Broken pipe" "$LOG_FILE" 2>/dev/null || true)
DOWNLOAD_FAIL_COUNT=$(grep -c "Download failed" "$LOG_FILE" 2>/dev/null || true)

echo "📊 错误统计:" >> "$REPORT_FILE"
echo "- 编译错误: $ERROR_COUNT" >> "$REPORT_FILE"
echo "- 警告: $WARNING_COUNT" >> "$REPORT_FILE"
echo "- 网络错误: $CURL_404_COUNT" >> "$REPORT_FILE"
echo "- 管道错误: $BROKEN_PIPE_COUNT" >> "$REPORT_FILE"
echo "- 下载失败: $DOWNLOAD_FAIL_COUNT" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

if [ "$ERROR_COUNT" -gt 0 ]; then
    echo "❌ 发现编译错误:" >> "$REPORT_FILE"
    grep "error:" "$LOG_FILE" | head -10 | sed 's/^/  /' >> "$REPORT_FILE"
else
    echo "✅ 未发现严重编译错误" >> "$REPORT_FILE"
fi

if [ "$CURL_404_COUNT" -gt 0 ]; then
    echo "❌ 发现网络下载错误:" >> "$REPORT_FILE"
    grep "curl.*404" "$LOG_FILE" | head -5 | sed 's/^/  /' >> "$REPORT_FILE"
fi

echo "" >> "$REPORT_FILE"
echo "=== 错误原因分析和建议 ===" >> "$REPORT_FILE"

if [ "$CURL_404_COUNT" -gt 0 ]; then
    echo "⚠️  网络下载错误" >> "$REPORT_FILE"
    echo "💡 可能原因: 依赖包URL失效或网络问题" >> "$REPORT_FILE"
    echo "💡 建议: " >> "$REPORT_FILE"
    echo "  1. 使用国内镜像源加速下载" >> "$REPORT_FILE"
    echo "  2. 手动预下载常见失败包" >> "$REPORT_FILE"
    echo "  3. 检查网络连接稳定性" >> "$REPORT_FILE"
fi

if [ "$BROKEN_PIPE_COUNT" -gt 0 ]; then
    echo "⚠️  管道错误" >> "$REPORT_FILE"
    echo "💡 这是并行编译的正常现象，不影响最终结果" >> "$REPORT_FILE"
fi

if [ "$DOWNLOAD_FAIL_COUNT" -gt 0 ]; then
    echo "⚠️  下载失败" >> "$REPORT_FILE"
    echo "💡 建议检查以下常见包:" >> "$REPORT_FILE"
    echo "  - csstidy" >> "$REPORT_FILE"
    echo "  - lua-rsa" >> "$REPORT_FILE"
    echo "  - 其他依赖包" >> "$REPORT_FILE"
fi

# 检查关键包是否编译成功
echo "" >> "$REPORT_FILE"
echo "=== 关键包编译状态 ===" >> "$REPORT_FILE"
for pkg in "luci" "luci-base" "luci-theme-bootstrap" "luci-i18n-base-zh-cn"; do
    if grep -q "Collecting package info: $pkg" "$LOG_FILE" && grep -q "Building $pkg" "$LOG_FILE"; then
        echo "✅ $pkg: 编译成功" >> "$REPORT_FILE"
    else
        echo "❌ $pkg: 编译状态未知" >> "$REPORT_FILE"
    fi
done

echo "" >> "$REPORT_FILE"
echo "=== 性能优化建议 ===" >> "$REPORT_FILE"
if [ "$ERROR_COUNT" -eq 0 ] && [ -d "$BUILD_DIR/bin/targets" ]; then
    echo "✅ 构建成功，建议:" >> "$REPORT_FILE"
    echo "  - 启用编译缓存减少下次构建时间" >> "$REPORT_FILE"
    echo "  - 使用预下载的依赖包" >> "$REPORT_FILE"
else
    echo "⚠️ 构建存在问题，建议:" >> "$REPORT_FILE"
    echo "  - 检查网络连接" >> "$REPORT_FILE"
    echo "  - 减少并行编译任务数" >> "$REPORT_FILE"
    echo "  - 使用更稳定的版本分支" >> "$REPORT_FILE"
fi

echo "✅ 错误分析完成" >> "$REPORT_FILE"

# 显示关键摘要
echo "=== 错误分析完成 ==="
echo "详细报告请查看: $REPORT_FILE"
echo ""
echo "📋 关键摘要:"
grep -E "❌|⚠️|✅|错误统计" "$REPORT_FILE" | head -15
EOF
            chmod +x error_analysis.sh
            echo "✅ 已创建基础错误分析脚本"
        fi
        
        if [ -f "error_analysis.sh" ] && [ -f "build_detailed.log" ]; then
            chmod +x error_analysis.sh
            echo "开始错误分析..."
            ./error_analysis.sh "$BUILD_DIR"
            echo "✅ 错误分析完成"
            
            if [ -f "error_analysis.log" ]; then
                echo "=== 关键错误摘要 ==="
                grep -E "❌|⚠️|✅" error_analysis.log | head -10
            fi
        else
            echo "⚠️ 错误分析条件不满足"
            if [ -f "build_detailed.log" ]; then
                echo "=== 基础错误检查 ==="
                ERROR_COUNT=$(grep -c "error:" build_detailed.log || true)
                WARNING_COUNT=$(grep -c "warning:" build_detailed.log || true)
                echo "错误数量: $ERROR_COUNT"
                echo "警告数量: $WARNING_COUNT"
                
                if [ $ERROR_COUNT -gt 0 ]; then
                    echo "❌ 发现编译错误"
                    grep "error:" build_detailed.log | head -5
                else
                    echo "✅ 未发现严重编译错误"
                fi
            fi
        fi

    - name: 验证固件生成
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 固件生成验证 ==="
        if [ -d "bin/targets" ]; then
          echo "✅ 构建成功！生成的固件:"
          find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) | sort
          for firmware in $(find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) 2>/dev/null); do
            echo "固件: $firmware"
            echo "大小: $(du -h "$firmware" | cut -f1)"
            echo ""
          done
        else
          echo "❌ 构建失败，未找到目标文件"
        fi

    - name: 生成构建报告文档
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 生成构建报告文档 ==="
        
        echo "# OpenWrt 固件构建报告" > "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 构建信息" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **设备**: ${{ env.DEVICE_FULL_NAME }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **平台**: ${{ env.PLATFORM }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **版本**: ${{ env.SELECTED_REPO }} (${{ env.SELECTED_BRANCH }})" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **配置类型**: ${{ github.event.inputs.config_type }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **构建时间**: $(date)" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **编译时长**: $((COMPILE_TIME / 60))分钟$((COMPILE_TIME % 60))秒" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 构建状态" >> "$GITHUB_WORKSPACE/构建报告.md"
        
        if [ -d "bin/targets" ]; then
            echo "✅ **构建状态**: 成功" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "## 生成的固件" >> "$GITHUB_WORKSPACE/构建报告.md"
            find bin/targets -name "*.bin" -o -name "*.img" | while read firmware; do
                FIRMWARE_NAME=$(basename "$firmware")
                FIRMWARE_SIZE=$(du -h "$firmware" | cut -f1)
                echo "- **$FIRMWARE_NAME** ($FIRMWARE_SIZE)" >> "$GITHUB_WORKSPACE/构建报告.md"
            done
            
            echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "## 包含的功能" >> "$GITHUB_WORKSPACE/构建报告.md"
            
            # 动态检查实际包含的包
            if grep -q "CONFIG_PACKAGE_luci-i18n-base-zh-cn=y" .config; then
                echo "- ✅ 中文界面支持" >> "$GITHUB_WORKSPACE/构建报告.md"
            else
                echo "- ❌ 中文界面支持" >> "$GITHUB_WORKSPACE/构建报告.md"
            fi
            
            echo "- ✅ Bootstrap主题" >> "$GITHUB_WORKSPACE/构建报告.md"
            
            if [ "${{ github.event.inputs.config_type }}" = "normal" ] || [ "${{ github.event.inputs.config_type }}" = "custom" ]; then
                if grep -q "CONFIG_PACKAGE_luci-app-turboacc=y" .config; then
                    echo "- ✅ TurboACC网络加速" >> "$GITHUB_WORKSPACE/构建报告.md"
                else
                    echo "- ❌ TurboACC网络加速" >> "$GITHUB_WORKSPACE/构建报告.md"
                fi
                if grep -q "CONFIG_PACKAGE_luci-app-sqm=y" .config; then
                    echo "- ✅ SQM智能队列管理" >> "$GITHUB_WORKSPACE/构建报告.md"
                else
                    echo "- ❌ SQM智能队列管理" >> "$GITHUB_WORKSPACE/构建报告.md"
                fi
                echo "- ✅ UPnP自动端口映射" >> "$GITHUB_WORKSPACE/构建报告.md"
            fi
            
            if [ "${{ github.event.inputs.custom_install }}" = "true" ]; then
                echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
                echo "## 自定义安装" >> "$GITHUB_WORKSPACE/构建报告.md"
                echo "- ✅ 自动安装自定义IPK包" >> "$GITHUB_WORKSPACE/构建报告.md"
                echo "- ✅ 自动执行自定义脚本" >> "$GITHUB_WORKSPACE/构建报告.md"
                echo "- ⚠️ 注意: 自定义安装将在首次启动时自动执行" >> "$GITHUB_WORKSPACE/构建报告.md"
            fi
        else
            echo "❌ **构建状态**: 失败" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "## 错误信息" >> "$GITHUB_WORKSPACE/构建报告.md"
            if [ -f "build_detailed.log" ]; then
                grep -E "error:|Error" build_detailed.log | head -10 >> "$GITHUB_WORKSPACE/构建报告.md"
            fi
        fi
        
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 刷机说明" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "1. 下载对应的固件文件" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "2. 进入路由器管理界面 → 系统 → 备份/升级" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "3. 选择固件文件进行刷机" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "4. 等待路由器重启完成" >> "$GITHUB_WORKSPACE/构建报告.md"
        
        echo "✅ 构建报告已生成"

    - name: 保存配置文件到仓库
      if: success() && github.event.inputs.save_config == 'true'
      run: |
        echo "=== 保存配置文件到仓库 ==="
        CONFIG_FILENAME="${{ github.event.inputs.device_name }}-${{ github.event.inputs.config_type }}.config"
        mkdir -p $GITHUB_WORKSPACE/firmware-config/configs
        
        if [ ! -f "$BUILD_DIR/.config" ]; then
          echo "❌ 错误: 源配置文件不存在"
          exit 1
        fi
        
        if [ -f "$GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME" ]; then
          if diff -q "$BUILD_DIR/.config" "$GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME" >/dev/null; then
            echo "ℹ️ 配置文件无变化，跳过保存"
            echo "CONFIG_UNCHANGED=true" >> $GITHUB_ENV
            exit 0
          else
            echo "✅ 检测到配置文件变化，将保存新配置"
          fi
        else
          echo "✅ 配置文件不存在，将创建新配置"
        fi
        
        cp $BUILD_DIR/.config $GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME
        
        if [ -f "$GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME" ]; then
          echo "✅ 配置文件已保存为: firmware-config/configs/$CONFIG_FILENAME"
          echo "CONFIG_UNCHANGED=false" >> $GITHUB_ENV
        else
          echo "❌ 错误: 配置文件保存失败"
          exit 1
        fi

    - name: 提交配置文件更改
      if: success() && github.event.inputs.save_config == 'true' && env.CONFIG_UNCHANGED == 'false'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== 提交配置文件更改 ==="
        cd $GITHUB_WORKSPACE
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
        git add firmware-config/configs/
        git add "构建报告.md" 2>/dev/null || true
        
        if git diff --staged --quiet; then
          echo "ℹ️ 没有配置文件更改需要提交"
          exit 0
        fi
        
        git commit -m "自动保存配置文件: ${{ github.event.inputs.device_name }}-${{ github.event.inputs.config_type }} [skip ci]"
        git pull origin main --rebase --no-edit
        git push origin main
        
        echo "✅ 配置文件提交完成"

    - name: 上传编译产物
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ github.event.inputs.device_name }}-${{ env.SELECTED_BRANCH }}-${{ github.event.inputs.config_type }}
        path: ${{ env.BUILD_DIR }}/bin/targets/
        retention-days: 7

    - name: 上传配置和日志
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-info-${{ github.event.inputs.device_name }}-${{ github.event.inputs.config_type }}
        path: |
          ${{ env.BUILD_DIR }}/.config
          ${{ env.BUILD_DIR }}/build_detailed.log
          ${{ env.BUILD_DIR }}/error_analysis.log
          ${{ env.BUILD_DIR }}/download_attempt_*.log
          $GITHUB_WORKSPACE/构建报告.md
        retention-days: 7

    - name: 清理构建目录
      if: always()
      run: |
        echo "=== 清理构建目录 ==="
        sudo rm -rf $BUILD_DIR
        echo "✅ 构建目录已清理"

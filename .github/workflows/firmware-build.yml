# OpenWrt 智能固件构建工作流
# 支持自定义设备、版本选择、配置类型和构建时自定义安装
name: OpenWrt Firmware Builder

# 触发条件：手动触发工作流
on:
  workflow_dispatch:
    inputs:
      # 设备名称输入参数
      device_name:
        description: '设备名称 (如: ac42u, ac58u, mi4a 等)'
        required: true
        default: 'ac42u'
        type: string
      # 是否为老旧设备
      old_device:
        description: '是否为老旧设备 (性能较差的设备建议选择true)'
        required: true
        default: false
        type: boolean
      # 版本规格
      version_spec:
        description: '版本规格 (可选，如: openwrt-23.05 或 immortalwrt:master)'
        required: false
        type: string
        default: ''
      # 配置类型选择
      config_type:
        description: '配置类型'
        required: true
        default: 'minimal'
        type: choice
        options:
          - minimal
          - normal
          - custom
      # 额外安装包
      extra_packages:
        description: '额外安装插件 (空格分隔的包名)'
        required: false
        type: string
      # 禁用插件
      disabled_plugins:
        description: '禁用插件 (空格分隔的包名)'
        required: false
        type: string
        default: ''
      # 是否保存配置
      save_config:
        description: '保存配置文件到仓库'
        required: false
        default: true
        type: boolean
      # 是否启用自定义安装
      custom_install:
        description: '启用自定义安装 (IPK和脚本)'
        required: false
        default: true
        type: boolean

# 环境变量定义
env:
  BUILD_DIR: /mnt/openwrt-build  # 构建目录路径

# 工作定义
jobs:
  build-firmware:
    runs-on: ubuntu-latest  # 使用最新版Ubuntu运行器
    
    steps:
    # 步骤1: 检查磁盘空间
    - name: 检查磁盘空间
      run: |
        echo "=== 磁盘空间检查 ==="
        df -h
        # 计算可用空间
        AVAILABLE_SPACE=$(df /mnt --output=avail | tail -1)
        AVAILABLE_GB=$((AVAILABLE_SPACE / 1024 / 1024))
        echo "/mnt 可用空间: ${AVAILABLE_GB}G"
        # 检查空间是否充足
        if [ $AVAILABLE_GB -lt 50 ]; then
          echo "错误: /mnt 空间不足50G"
          exit 1
        fi

    # 步骤2: 检出代码仓库
    - name: 检出代码仓库
      uses: actions/checkout@v4

    # 步骤3: 安装编译依赖
    - name: 安装编译依赖
      run: |
        echo "=== 安装编译依赖包 ==="
        sudo apt-get update
        # 安装基础编译工具
        sudo apt-get install -y build-essential libncurses5-dev libssl-dev python3 unzip zlib1g-dev subversion gcc-multilib git curl file
        # 安装OpenWrt编译特定依赖
        sudo apt-get install -y ninja-build automake autoconf libtool pkg-config gettext help2man texinfo gawk flex bison rsync wget aria2 python3-pip libelf-dev liblz4-dev zstd libssl-dev libcurl4-openssl-dev
        # 安装Python依赖
        pip3 install requests urllib3

    # 步骤4: 创建构建目录
    - name: 创建构建目录
      run: |
        echo "=== 创建构建目录 ==="
        sudo mkdir -p $BUILD_DIR
        sudo chown -R $USER:$USER $BUILD_DIR
        sudo chmod -R 755 $BUILD_DIR

    # 步骤5: 复制脚本和配置文件
    - name: 复制脚本和配置文件
      run: |
        echo "=== 复制脚本和配置文件 ==="
        cd $GITHUB_WORKSPACE
        
        # 复制检测脚本
        cp $(find . -name "complete_version_detector.sh" -type f | head -1) $BUILD_DIR/
        cp $(find . -name "device_detection.sh" -type f | head -1) $BUILD_DIR/
        
        # 复制错误分析脚本（如果存在）
        ERROR_SCRIPT=$(find . -name "error_analysis.sh" -type f | head -1)
        if [ -n "$ERROR_SCRIPT" ]; then
          cp "$ERROR_SCRIPT" $BUILD_DIR/
        fi
        
        # 创建配置模板目录并复制配置文件
        mkdir -p $BUILD_DIR/config-templates
        CONFIG_FILES=$(find firmware-config/configs -name "*.config" -type f 2>/dev/null || true)
        for config_file in $CONFIG_FILES; do
          cp "$config_file" $BUILD_DIR/config-templates/
        done
        
        # 设置脚本执行权限
        cd $BUILD_DIR
        chmod +x *.sh 2>/dev/null || true

    # 步骤6: 智能版本检测
    - name: 智能版本检测
      id: version-detection
      run: |
        cd $BUILD_DIR
        echo "=== 智能版本检测 ==="
        
        # 运行版本检测脚本
        set +e
        OUTPUT=$(./complete_version_detector.sh "${{ github.event.inputs.device_name }}" "${{ github.event.inputs.version_spec }}" "${{ github.event.inputs.old_device }}" 2>&1)
        SCRIPT_EXIT_CODE=$?
        set -e
        
        # 从脚本输出中提取版本信息
        SELECTED_REPO=$(echo "$OUTPUT" | grep "^SELECTED_REPO=" | head -1 | cut -d'=' -f2)
        SELECTED_BRANCH=$(echo "$OUTPUT" | grep "^SELECTED_BRANCH=" | head -1 | cut -d'=' -f2)
        SELECTED_REPO_URL=$(echo "$OUTPUT" | grep "^SELECTED_REPO_URL=" | head -1 | cut -d'=' -f2)
        
        # 设置环境变量
        if [ -n "$SELECTED_REPO" ] && [ -n "$SELECTED_BRANCH" ] && [ -n "$SELECTED_REPO_URL" ]; then
            echo "SELECTED_REPO=$SELECTED_REPO" >> $GITHUB_ENV
            echo "SELECTED_BRANCH=$SELECTED_BRANCH" >> $GITHUB_ENV
            echo "SELECTED_REPO_URL=$SELECTED_REPO_URL" >> $GITHUB_ENV
        else
            echo "❌ 无法提取版本信息"
            exit 1
        fi

    # 步骤7: 清理构建目录
    - name: 清理构建目录
      run: |
        cd $BUILD_DIR
        echo "=== 清理构建目录 ==="
        sudo rm -rf ./* ./.git* 2>/dev/null || true

    # 步骤8: 克隆OpenWrt源码
    - name: 克隆OpenWrt源码
      run: |
        cd $BUILD_DIR
        echo "=== 克隆OpenWrt源码 ==="
        
        MAX_RETRIES=3
        RETRY_COUNT=0
        CLONE_SUCCESS=false
        
        # 重试克隆机制
        while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$CLONE_SUCCESS" = false ]; do
          RETRY_COUNT=$((RETRY_COUNT + 1))
          echo "克隆尝试 $RETRY_COUNT/$MAX_RETRIES"
          
          if git clone --depth 1 --branch "$SELECTED_BRANCH" "$SELECTED_REPO_URL" .; then
            CLONE_SUCCESS=true
          else
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "❌ 源码克隆失败"
              exit 1
            fi
            sleep 10
            rm -rf ./* ./.git* 2>/dev/null || true
          fi
        done

    # 步骤9: 设备检测和别名转换
    - name: 设备检测和别名转换
      id: device-detection
      run: |
        cd $BUILD_DIR
        echo "=== 设备检测和别名转换 ==="
        
        # 设备别名映射表
        declare -A DEVICE_ALIAS_MAP=(
          ["ac42u"]="asus_rt-ac42u" 
          ["acrh17"]="asus_rt-ac42u" 
          ["rt-acrh17"]="asus_rt-ac42u" 
          ["ac58u"]="asus_rt-ac58u" 
          ["acrh13"]="asus_rt-ac58u" 
          ["rt-ac58u"]="asus_rt-ac58u" 
          ["rt-acrh13"]="asus_rt-ac58u" 
          ["mi4a"]="xiaomi_mi-router-4a-gigabit" 
          ["r4a"]="xiaomi_mi-router-4a-gigabit" 
          ["mi3g"]="xiaomi_mi-router-3g" 
          ["r3g"]="xiaomi_mi-router-3g"
        )
        
        # 设备名称转换
        INPUT_DEVICE="${{ github.event.inputs.device_name }}"
        if [ -n "${DEVICE_ALIAS_MAP[$INPUT_DEVICE]}" ]; then
          ACTUAL_DEVICE="${DEVICE_ALIAS_MAP[$INPUT_DEVICE]}"
        else
          ACTUAL_DEVICE="$INPUT_DEVICE"
        fi
        
        # 运行设备检测脚本
        chmod +x device_detection.sh
        TEMP_LOG=$(mktemp)
        ./device_detection.sh "$ACTUAL_DEVICE" 2>&1 | tee "$TEMP_LOG"
        
        # 提取设备信息
        PLATFORM=$(grep "^PLATFORM=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_SHORT_NAME=$(grep "^DEVICE_SHORT_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        DEVICE_FULL_NAME=$(grep "^DEVICE_FULL_NAME=" "$TEMP_LOG" | tail -1 | cut -d'=' -f2)
        rm -f "$TEMP_LOG"
        
        # 设置环境变量
        if [ -n "$PLATFORM" ] && [ -n "$DEVICE_SHORT_NAME" ] && [ -n "$DEVICE_FULL_NAME" ]; then
            echo "PLATFORM=$PLATFORM" >> $GITHUB_ENV
            echo "DEVICE_SHORT_NAME=$DEVICE_SHORT_NAME" >> $GITHUB_ENV
            echo "DEVICE_FULL_NAME=$DEVICE_FULL_NAME" >> $GITHUB_ENV
        else
            echo "❌ 设备检测失败"
            exit 1
        fi

    # 步骤10: 更新和安装feeds
    - name: 更新和安装feeds
      run: |
        cd $BUILD_DIR
        echo "=== 更新和安装feeds ==="
        ./scripts/feeds update -a
        ./scripts/feeds install -a

    # 步骤11: 配置固件
    - name: 配置固件
      run: |
        cd $BUILD_DIR
        echo "=== 配置固件 ==="
        
        # 清空并初始化配置文件
        > .config
        echo "CONFIG_TARGET_${PLATFORM}=y" >> .config
        echo "CONFIG_TARGET_${PLATFORM}_generic=y" >> .config
        echo "CONFIG_TARGET_${PLATFORM}_generic_DEVICE_${DEVICE_SHORT_NAME}=y" >> .config
        echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
        
        # 根据配置类型选择配置文件
        CONFIG_TYPE="${{ github.event.inputs.config_type }}"
        if [ "$CONFIG_TYPE" = "minimal" ]; then
            CONFIG_FILE="config-templates/minimal.config"
        else
            # 判断是否为旧版本设备
            IS_OLD_VERSION=0
            [ "${{ github.event.inputs.old_device }}" = "true" ] && IS_OLD_VERSION=1
            echo "$SELECTED_BRANCH" | grep -q -E "19\.07|21\.02|17\.01|lede" && IS_OLD_VERSION=1
            [ "$SELECTED_REPO" = "lede" ] || [ "$SELECTED_REPO" = "openwrt-19.07" ] || [ "$SELECTED_REPO" = "openwrt-21.02" ] && IS_OLD_VERSION=1
            case "${{ github.event.inputs.device_name }}" in 
              "wr841n"|"wr842n"|"wr941n"|"mr3420"|"ar71xx"*) 
                IS_OLD_VERSION=1 
                ;;
            esac
            
            # 选择新旧版本配置文件
            if [ "$IS_OLD_VERSION" -eq 1 ]; then
                CONFIG_FILE="config-templates/normal-old.config"
            else
                CONFIG_FILE="config-templates/normal-new.config"
            fi
        fi
        
        # 应用主配置文件
        [ -f "$CONFIG_FILE" ] && cat "$CONFIG_FILE" >> .config
        
        # 处理自定义配置
        if [ "$CONFIG_TYPE" = "custom" ] && [ -n "${{ github.event.inputs.extra_packages }}" ]; then
            for pkg in ${{ github.event.inputs.extra_packages }}; do
                pkg_clean=$(echo "$pkg" | tr '-' '_' | tr -cd '[:alnum:]_')
                echo "CONFIG_PACKAGE_${pkg_clean}=y" >> .config
            done
        fi
        
        # 处理禁用插件
        if [ -n "${{ github.event.inputs.disabled_plugins }}" ]; then
            for plugin in ${{ github.event.inputs.disabled_plugins }}; do
                plugin_clean=$(echo "$plugin" | tr '-' '_' | tr -cd '[:alnum:]_')
                echo "# CONFIG_PACKAGE_${plugin_clean} is not set" >> .config
            done
        fi
        
        # 生成最终配置
        make defconfig

    # 步骤12: 构建时集成自定义文件（构建时安装）
    - name: 构建时集成自定义文件
      if: github.event.inputs.custom_install == 'true'
      run: |
        cd $BUILD_DIR
        echo "=== 构建时集成自定义文件 ==="
        
        # 创建自定义安装目录
        mkdir -p files/root/custom-install
        
        # 复制IPK文件到构建目录
        cd $GITHUB_WORKSPACE
        IPK_FILES=$(find firmware-config/custom-files -name "*.ipk" -type f 2>/dev/null || true)
        for ipk in $IPK_FILES; do
            cp "$ipk" $BUILD_DIR/files/root/custom-install/
            echo "✅ 复制IPK: $(basename "$ipk")"
        done
        
        # 复制脚本文件到构建目录
        SCRIPT_FILES=$(find firmware-config/custom-files -name "*.sh" -type f 2>/dev/null | grep -v "detector\|analysis" || true)
        for script in $SCRIPT_FILES; do
            cp "$script" $BUILD_DIR/files/root/custom-install/
            chmod +x $BUILD_DIR/files/root/custom-install/$(basename "$script")
            echo "✅ 复制脚本: $(basename "$script")"
        done
        
        # 创建构建时安装脚本 - 在构建过程中执行本地安装
        echo '#!/bin/sh' > $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'echo "=== 开始构建时自定义安装 ==="' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '# 构建时安装IPK文件 - 使用本地opkg安装' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'if ls /root/custom-install/*.ipk >/dev/null 2>&1; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "构建时安装IPK文件..."' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    for ipk in /root/custom-install/*.ipk; do' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        echo "安装: $(basename $ipk)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        # 使用opkg本地安装，不依赖网络' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        opkg install "$ipk" --force-depends || echo "安装失败: $(basename $ipk)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    done' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'else' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "未找到IPK文件"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '# 执行构建时脚本' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'if ls /root/custom-install/*.sh >/dev/null 2>&1; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "执行构建时脚本..."' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    for script in /root/custom-install/*.sh; do' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        if [ "$(basename $script)" != "build-time-install.sh" ]; then' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '            echo "执行: $(basename $script)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '            sh "$script" || echo "执行失败: $(basename $script)"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '        fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    done' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'else' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '    echo "未找到脚本文件"' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'fi' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo '# 清理安装文件' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'rm -rf /root/custom-install' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        echo 'echo "=== 构建时自定义安装完成 ==="' >> $BUILD_DIR/files/root/custom-install/build-time-install.sh
        
        chmod +x $BUILD_DIR/files/root/custom-install/build-time-install.sh
        
        # 创建开机执行脚本，在系统启动时运行构建时安装
        mkdir -p $BUILD_DIR/files/etc/rc.local.d
        echo '#!/bin/sh' > $BUILD_DIR/files/etc/rc.local
        echo '' >> $BUILD_DIR/files/etc/rc.local
        echo '# 在后台执行构建时自定义安装' >> $BUILD_DIR/files/etc/rc.local
        echo '[ -f /root/custom-install/build-time-install.sh ] && {' >> $BUILD_DIR/files/etc/rc.local
        echo '    /root/custom-install/build-time-install.sh >/tmp/build-time-install.log 2>&1 &' >> $BUILD_DIR/files/etc/rc.local
        echo '}' >> $BUILD_DIR/files/etc/rc.local
        echo '' >> $BUILD_DIR/files/etc/rc.local
        echo 'exit 0' >> $BUILD_DIR/files/etc/rc.local
        
        chmod +x $BUILD_DIR/files/etc/rc.local
        echo "✅ 构建时自定义安装配置完成"

    # 步骤13: 加强下载验证
    - name: 加强下载验证
      run: |
        cd $BUILD_DIR
        echo "=== 加强下载验证 ==="
        
        # 设置下载环境变量
        export GIT_SSL_NO_VERIFY=1
        export PYTHONHTTPSVERIFY=0
        mkdir -p dl
        
        # 下载重试机制
        MAX_RETRIES=5
        for i in $(seq 1 $MAX_RETRIES); do
          echo "下载尝试 $i/$MAX_RETRIES"
          make -j1 download V=s && break || sleep 15
          [ $i -eq $MAX_RETRIES ] && make -j1 download V=s
        done
        
        # 清理空文件并重新下载
        find dl -size 0 -delete 2>/dev/null || true
        [ $(find dl -type f -size 0 2>/dev/null | wc -l) -gt 0 ] && make -j1 download V=s

    # 步骤14: 验证软件包配置
    - name: 验证软件包配置
      run: |
        cd $BUILD_DIR
        echo "=== 验证软件包配置 ==="
        echo "关键软件包状态:"
        
        # 验证基础软件包
        for pkg in luci luci-base luci-theme-bootstrap luci-i18n-base-zh-cn luci-i18n-firewall-zh-cn; do
          grep -q "CONFIG_PACKAGE_${pkg}=y" .config && echo "✅ $pkg: 已启用" || echo "❌ $pkg: 未启用"
        done
        
        # 验证正常模式插件
        if [ "${{ github.event.inputs.config_type }}" = "normal" ] || [ "${{ github.event.inputs.config_type }}" = "custom" ]; then
          for pkg in luci-app-turboacc luci-app-sqm luci-app-upnp; do
            grep -q "CONFIG_PACKAGE_${pkg}=y" .config && echo "✅ $pkg: 已启用" || echo "❌ $pkg: 未启用"
          done
        fi

    # 步骤15: 编译固件
    - name: 编译固件
      run: |
        cd $BUILD_DIR
        echo "::group::编译日志"
        
        # 设置编译环境
        export FORCE_UNSAFE_CONFIGURE=1
        
        # 根据CPU核心数设置并行任务数
        AVAILABLE_CORES=$(nproc)
        if [ $AVAILABLE_CORES -ge 4 ]; then
            BUILD_JOBS=2
        else
            BUILD_JOBS=1
        fi
        echo "使用 $BUILD_JOBS 个并行任务"
        
        # 开始编译并计时
        START_TIME=$(date +%s)
        set +e
        time make -j$BUILD_JOBS V=s 2>&1 | tee build_detailed.log
        COMPILE_EXIT_CODE=$?
        set -e
        END_TIME=$(date +%s)
        COMPILE_TIME=$((END_TIME - START_TIME))
        echo "编译时间: $((COMPILE_TIME / 60))分钟$((COMPILE_TIME % 60))秒"
        
        # 检查编译结果
        if [ -d "bin/targets" ]; then
          echo "::endgroup::"
          echo "::notice::编译成功"
          find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" \) | sort
        else
          echo "::endgroup::"
          echo "::notice::编译失败"
          exit 1
        fi

    # 步骤16: 错误分析
    - name: 错误分析
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 错误分析 ==="
        
        if [ -f "error_analysis.sh" ] && [ -f "build_detailed.log" ]; then
          chmod +x error_analysis.sh
          ./error_analysis.sh "$BUILD_DIR"
          [ -f "error_analysis.log" ] && grep -E "❌|⚠️|✅" error_analysis.log | head -10
        else
          ERROR_COUNT=$(grep -c "error:" build_detailed.log 2>/dev/null || echo "0")
          echo "错误数量: $ERROR_COUNT"
          [ $ERROR_COUNT -gt 0 ] && grep "error:" build_detailed.log | head -5
        fi

    # 步骤17: 生成构建报告
    - name: 生成构建报告
      if: always()
      run: |
        cd $BUILD_DIR
        echo "=== 生成构建报告 ==="
        
        echo "# OpenWrt 固件构建报告" > "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 构建信息" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **设备**: ${{ env.DEVICE_FULL_NAME }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **平台**: ${{ env.PLATFORM }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **版本**: ${{ env.SELECTED_REPO }} (${{ env.SELECTED_BRANCH }})" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **配置类型**: ${{ github.event.inputs.config_type }}" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **构建时间**: $(date)" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "- **编译时长**: $((COMPILE_TIME / 60))分钟$((COMPILE_TIME % 60))秒" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
        echo "## 构建状态" >> "$GITHUB_WORKSPACE/构建报告.md"
        
        if [ -d "bin/targets" ]; then
            echo "✅ **构建状态**: 成功" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "" >> "$GITHUB_WORKSPACE/构建报告.md"
            echo "## 生成的固件" >> "$GITHUB_WORKSPACE/构建报告.md"
            find bin/targets -name "*.bin" -o -name "*.img" | while read firmware; do
                FIRMWARE_NAME=$(basename "$firmware")
                FIRMWARE_SIZE=$(du -h "$firmware" | cut -f1)
                echo "- **$FIRMWARE_NAME** ($FIRMWARE_SIZE)" >> "$GITHUB_WORKSPACE/构建报告.md"
            done
        else
            echo "❌ **构建状态**: 失败" >> "$GITHUB_WORKSPACE/构建报告.md"
        fi

    # 步骤18: 保存配置文件
    - name: 保存配置文件
      if: success() && github.event.inputs.save_config == 'true'
      run: |
        echo "=== 保存配置文件 ==="
        CONFIG_FILENAME="${{ github.event.inputs.device_name }}-${{ github.event.inputs.config_type }}.config"
        mkdir -p $GITHUB_WORKSPACE/firmware-config/configs
        cp $BUILD_DIR/.config $GITHUB_WORKSPACE/firmware-config/configs/$CONFIG_FILENAME

    # 步骤19: 提交配置更改
    - name: 提交配置更改
      if: success() && github.event.inputs.save_config == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        echo "=== 提交配置更改 ==="
        cd $GITHUB_WORKSPACE
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git
        git add firmware-config/configs/ "构建报告.md" 2>/dev/null || true
        git diff --staged --quiet || (git commit -m "自动保存配置: ${{ github.event.inputs.device_name }}-${{ github.event.inputs.config_type }} [skip ci]" && git pull --rebase && git push)

    # 步骤20: 上传固件产物
    - name: 上传固件产物
      if: success()
      uses: actions/upload-artifact@v4
      with:
        name: firmware-${{ github.event.inputs.device_name }}-${{ github.event.inputs.config_type }}
        path: ${{ env.BUILD_DIR }}/bin/targets/
        retention-days: 7

    # 步骤21: 上传日志和配置
    - name: 上传日志和配置
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: logs-${{ github.event.inputs.device_name }}
        path: |
          ${{ env.BUILD_DIR }}/.config
          ${{ env.BUILD_DIR }}/build_detailed.log
          ${{ env.BUILD_DIR }}/error_analysis.log
          $GITHUB_WORKSPACE/构建报告.md
        retention-days: 7

    # 步骤22: 清理构建目录
    - name: 清理构建目录
      if: always()
      run: |
        echo "=== 清理构建目录 ==="
        sudo rm -rf $BUILD_DIR

name: Universal Firmware Builder - Optimized Version

on:
  workflow_dispatch:
    inputs:
      source_preset:
        description: 选择源码库
        required: true
        type: choice
        options:
          - immortalwrt
          - openwrt
          - lede
        default: immortalwrt
      source_branch:
        description: 源码分支
        required: true
        default: auto
        type: string
      config_profile:
        description: 设备配置文件路径
        required: true
        type: string
        default: .config_rt-ac42u_immortalwrt
      build_optimization:
        description: 编译优化策略
        required: true
        type: choice
        options:
          - balanced
          - speed
          - stability
        default: balanced
      toolchain_strategy:
        description: 工具链策略
        required: true
        type: choice
        options:
          - prebuilt
          - local
          - auto
        default: auto
      enable_custom_features:
        description: 启用自定义功能
        required: false
        default: true
        type: boolean
      fix_common_issues:
        description: 自动修复常见问题
        required: false
        default: true
        type: boolean
      enable_pre_download:
        description: 启用预下载验证
        required: false
        default: true
        type: boolean
      enable_post_verify:
        description: 启用编译后验证
        required: false
        default: true
        type: boolean

env:
  TZ: Asia/Shanghai
  SOURCE_DIR: /mnt/source
  ARTIFACTS_DIR: /mnt/artifacts
  CCACHE_DIR: /mnt/ccache
  BUILD_LOG_DIR: /mnt/build-logs
  DOWNLOAD_DIR: /mnt/downloads
  TOOLCHAIN_LOG_DIR: /mnt/toolchain-logs

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    steps:
      - name: 📥 检出配置仓库
        uses: actions/checkout@v4
        with:
          path: .
          fetch-depth: 0

      - name: 💾 智能系统资源分析
        timeout-minutes: 1
        run: |
          echo "=== 智能系统资源分析 ==="
          echo "📊 磁盘空间:"
          df -h
          echo ""
          echo "💻 CPU 信息:"
          echo "核心数: $(nproc)"
          echo "架构: $(uname -m)"
          echo ""
          echo "🧠 内存信息:"
          free -h
          ROOT_AVAILABLE=$(df / | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "根分区可用空间: ${ROOT_AVAILABLE}GB"
          if [ "$ROOT_AVAILABLE" -lt 5 ]; then
            echo "🚨 警告: 根分区空间不足5GB，可能影响系统稳定性"
          fi
          echo "✅ 资源分析完成"

      - name: 💾 增强内存管理与环境设置
        run: |
          echo "=== 增强内存管理与环境设置 ==="
          MNT_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}' 2>/dev/null || echo 0)
          echo "/mnt 分区可用空间: ${MNT_AVAILABLE}GB"
          if [ "$MNT_AVAILABLE" -lt 15 ]; then
            echo "🚨 严重错误: /mnt 分区空间不足15GB，无法编译"
            exit 1
          fi
          echo "🔄 创建8GB交换文件..."
          if [ -f /mnt/swapfile ]; then
            sudo swapoff /mnt/swapfile 2>/dev/null || true
            sudo rm -f /mnt/swapfile 2>/dev/null || true
          fi
          sudo dd if=/dev/zero of=/mnt/swapfile bs=1M count=8192 status=progress || sudo fallocate -l 8G /mnt/swapfile
          sudo chmod 600 /mnt/swapfile
          sudo mkswap /mnt/swapfile
          sudo swapon /mnt/swapfile
          echo "📊 当前内存状态:"
          free -h
          echo "🔧 创建工作目录..."
          sudo mkdir -p ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }} ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          sudo chown -R $USER:$USER ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }} ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          sudo chmod -R 755 ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }}
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=xterm-256color

      - name: 🛠️ 快速编译依赖安装
        run: |
          echo "安装快速编译依赖包..."
          sudo apt-get update
          sudo apt-get install -y build-essential clang flex bison g++ gawk gcc-multilib g++-multilib
          sudo apt-get install -y gettext git libncurses5-dev libssl-dev python3 python3-pip
          sudo apt-get install -y rsync unzip zlib1g-dev file wget jq ccache
          sudo apt-get install -y libtool-bin automake autoconf pkg-config subversion curl cmake ninja-build
          sudo apt-get install -y libelf-dev libssl-dev zlib1g-dev libxml2-dev liblzma-dev liblzo2-dev
          echo "✅ 依赖安装完成"

      - name: ⚡ 高级缓存与性能优化
        run: |
          echo "设置高级缓存与性能优化..."
          mkdir -p ${{ env.CCACHE_DIR }}
          ccache -M 8G
          ccache -o compression=true
          ccache -o compression_level=6
          echo "CCACHE_DIR=${{ env.CCACHE_DIR }}" >> $GITHUB_ENV
          echo "CCACHE_COMPRESS=1" >> $GITHUB_ENV
          echo "CCACHE_MAXSIZE=8G" >> $GITHUB_ENV
          echo "📊 初始CCache统计:"
          ccache -s

      - name: 🔍 智能文件发现与配置分析
        id: file-discovery
        run: |
          echo "=== 智能文件发现与配置分析 ==="
          echo "📋 查找 repositories.json 文件..."
          REPO_JSON_FOUND=$(find . -maxdepth 3 -name "repositories.json" -type f 2>/dev/null | head -1)
          if [ -n "$REPO_JSON_FOUND" ]; then
            echo "✅ 找到 repositories.json: $REPO_JSON_FOUND"
            echo "REPO_JSON_PATH=$REPO_JSON_FOUND" >> $GITHUB_ENV
          else
            echo "❌ 未找到 repositories.json 文件"
            exit 1
          fi
          echo "✅ 智能文件发现完成"

      - name: 🔧 智能源码配置解析
        id: source-config
        run: |
          echo "正在智能解析源码配置..."
          PRESET="${{ github.event.inputs.source_preset }}"
          REPO_JSON_PATH="${{ env.REPO_JSON_PATH }}"
          
          if ! jq -e ".repositories.$PRESET" "$REPO_JSON_PATH" >/dev/null 2>&1; then
            echo "❌ 错误: 预设 '$PRESET' 不存在"
            exit 1
          fi
          
          SOURCE_URL=$(jq -r ".repositories.$PRESET.url" "$REPO_JSON_PATH")
          DESCRIPTION=$(jq -r ".repositories.$PRESET.description // \"未知\"" "$REPO_JSON_PATH")
          RECOMMENDED_BRANCH=$(jq -r ".repositories.$PRESET.recommended_branch" "$REPO_JSON_PATH")
          
          BRANCH="${{ github.event.inputs.source_branch }}"
          if [ "$BRANCH" = "auto" ]; then
            BRANCH="$RECOMMENDED_BRANCH"
            echo "🤖 自动选择推荐分支: $BRANCH"
          fi
          
          echo "SOURCE_URL=$SOURCE_URL" >> $GITHUB_ENV
          echo "SOURCE_BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "SOURCE_PRESET=$PRESET" >> $GITHUB_ENV
          
          echo "✅ 源码配置解析完成"

      - name: 📥 智能源码获取（多镜像）
        id: clone-source
        run: |
          echo "开始智能源码获取..."
          cd ${{ env.SOURCE_DIR }}
          REQUESTED_BRANCH="${{ env.SOURCE_BRANCH }}"
          SOURCE_URL="${{ env.SOURCE_URL }}"
          echo "🎯 请求分支: $REQUESTED_BRANCH"
          
          # 定义备用镜像（根据预设选择）
          case "${{ env.SOURCE_PRESET }}" in
            "immortalwrt")
              BACKUP_MIRRORS=("https://github.com/immortalwrt/immortalwrt.git" "https://gitee.com/immortalwrt/immortalwrt.git")
              ;;
            "openwrt")
              BACKUP_MIRRORS=("https://github.com/openwrt/openwrt.git" "https://git.openwrt.org/openwrt/openwrt.git")
              ;;
            "lede")
              BACKUP_MIRRORS=("https://github.com/coolsnowwolf/lede.git" "https://gitee.com/coolsnowwolf/lede.git")
              ;;
            *)
              BACKUP_MIRRORS=("https://github.com/immortalwrt/immortalwrt.git" "https://gitee.com/immortalwrt/immortalwrt.git")
              ;;
          esac
          
          rm -rf .[!.]* * 2>/dev/null || true
          
          CLONE_SUCCESS=false
          # 首先尝试主镜像
          for strategy in "指定分支" "main" "master" "默认分支"; do
            echo "🔄 尝试主镜像策略: $strategy"
            rm -rf .[!.]* * 2>/dev/null || true
            
            case $strategy in
              "指定分支")
                git clone --depth 1 --branch "$REQUESTED_BRANCH" "$SOURCE_URL" . && CLONE_SUCCESS=true || continue
                ;;
              "main")
                git clone --depth 1 --branch main "$SOURCE_URL" . && CLONE_SUCCESS=true || continue
                ;;
              "master")  
                git clone --depth 1 --branch master "$SOURCE_URL" . && CLONE_SUCCESS=true || continue
                ;;
              "默认分支")
                git clone --depth 1 "$SOURCE_URL" . && CLONE_SUCCESS=true || continue
                ;;
            esac
            
            if [ "$CLONE_SUCCESS" = "true" ] && [ -d ".git" ] && [ -f "scripts/feeds" ]; then
              ACTUAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
              COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
              echo "✅ 主镜像克隆成功: $strategy"
              break
            fi
          done
          
          # 如果主镜像失败，尝试备用镜像
          if [ "$CLONE_SUCCESS" = "false" ]; then
            echo "🔄 主镜像失败，尝试备用镜像..."
            for mirror in "${BACKUP_MIRRORS[@]}"; do
              echo "🔄 尝试备用镜像: $mirror"
              rm -rf .[!.]* * 2>/dev/null || true
              
              # 对每个镜像尝试不同的分支策略
              for branch_strategy in "$REQUESTED_BRANCH" "main" "master" "default"; do
                echo "  🔄 尝试分支: $branch_strategy"
                rm -rf .[!.]* * 2>/dev/null || true
                
                if git clone --depth 1 --branch "$branch_strategy" "$mirror" . 2>/dev/null; then
                  if [ -d ".git" ] && [ -f "scripts/feeds" ]; then
                    ACTUAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown") 
                    COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
                    echo "✅ 备用镜像克隆成功: $mirror (分支: $branch_strategy)"
                    CLONE_SUCCESS=true
                    break 2
                  fi
                fi
              done
            done
          fi
          
          if [ "$CLONE_SUCCESS" = "false" ]; then
            echo "❌ 所有克隆策略和镜像都失败"
            echo "🔧 尝试最后的解决方案：浅克隆+完整拉取"
            rm -rf .[!.]* * 2>/dev/null || true
            git clone --depth 1 "$SOURCE_URL" . || git clone --filter=blob:none "$SOURCE_URL" .
            if [ -d ".git" ] && [ -f "scripts/feeds" ]; then
              ACTUAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
              COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
              echo "✅ 最终方案克隆成功"
              CLONE_SUCCESS=true
            else
              echo "❌ 所有源码获取方法都失败"
              exit 1
            fi
          fi
          
          echo "ACTUAL_BRANCH=$ACTUAL_BRANCH" >> $GITHUB_ENV
          echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
          echo "✅ 源码获取完成"

      - name: 🔄 智能源码初始化与镜像切换
        timeout-minutes: 15
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "开始智能源码初始化..."
          
          if [ ! -f "scripts/feeds" ]; then
            echo "❌ 错误: scripts/feeds 文件不存在"
            exit 1
          fi
          
          # 定义多个镜像源
          PACKAGES_MIRRORS=("https://git.openwrt.org/feed/packages.git" "https://github.com/openwrt/packages.git" "https://gitee.com/openwrt-mirror/packages.git")
          LUCI_MIRRORS=("https://git.openwrt.org/feed/luci.git" "https://github.com/openwrt/luci.git" "https://gitee.com/openwrt-mirror/luci.git")
          
          # 智能feeds配置
          if [ ! -f "feeds.conf" ]; then
            echo "创建智能 feeds.conf"
            # 使用第一个镜像作为默认
            echo "src-git packages ${PACKAGES_MIRRORS[0]}" > feeds.conf
            echo "src-git luci ${LUCI_MIRRORS[0]}" >> feeds.conf
            echo "src-git routing https://git.openwrt.org/feed/routing.git" >> feeds.conf
            echo "src-git telephony https://git.openwrt.org/feed/telephony.git" >> feeds.conf
          fi
          
          echo "🔄 开始智能更新Feeds..."
          
          # 更新feeds的函数，支持重试和镜像切换
          update_feeds_with_retry() {
            local max_retries=3
            local retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              echo "🔄 尝试更新Feeds (第 $((retry_count + 1)) 次)..."
              
              if ./scripts/feeds update -a; then
                echo "✅ Feeds更新成功"
                return 0
              else
                retry_count=$((retry_count + 1))
                echo "⚠️ 第 $retry_count 次更新失败"
                
                if [ $retry_count -eq 1 ]; then
                  # 第一次失败后切换到GitHub镜像
                  echo "🔄 切换到GitHub镜像..."
                  echo "src-git packages ${PACKAGES_MIRRORS[1]}" > feeds.conf
                  echo "src-git luci ${LUCI_MIRRORS[1]}" >> feeds.conf
                  echo "src-git routing https://github.com/openwrt/routing.git" >> feeds.conf
                  echo "src-git telephony https://github.com/openwrt/telephony.git" >> feeds.conf
                elif [ $retry_count -eq 2 ]; then
                  # 第二次失败后切换到Gitee镜像
                  echo "🔄 切换到Gitee镜像..."
                  echo "src-git packages ${PACKAGES_MIRRORS[2]}" > feeds.conf
                  echo "src-git luci ${LUCI_MIRRORS[2]}" >> feeds.conf
                  echo "src-git routing https://gitee.com/openwrt-mirror/routing.git" >> feeds.conf
                  echo "src-git telephony https://gitee.com/openwrt-mirror/telephony.git" >> feeds.conf
                fi
                
                if [ $retry_count -lt $max_retries ]; then
                  echo "⏳ 等待 3 秒后重试..."
                  sleep 3
                fi
              fi
            done
            
            echo "❌ 所有更新尝试都失败"
            return 1
          }
          
          # 执行更新
          if update_feeds_with_retry; then
            echo "📦 开始安装Feeds..."
            if ./scripts/feeds install -a; then
              echo "✅ 所有Feeds安装成功"
            else
              echo "⚠️ 部分Feeds安装失败，尝试逐个安装..."
              ./scripts/feeds update -a
              for feed in packages luci routing telephony; do
                echo "📦 安装 $feed..."
                ./scripts/feeds install $feed || echo "⚠️ $feed 安装失败，继续..."
              done
            fi
            echo "✅ 源码初始化完成"
          else
            echo "❌ Feeds更新失败，尝试最小化安装继续..."
            
            # 尝试只更新和安装packages（必需）
            echo "🔄 尝试仅更新packages..."
            ./scripts/feeds update packages
            ./scripts/feeds install -a
            
            if [ $? -eq 0 ]; then
              echo "⚠️ 已使用最小化feeds配置，继续编译流程"
            else
              echo "❌ 关键feeds安装失败"
              exit 1
            fi
          fi

      - name: 🎯 快速配置文件查找与应用
        timeout-minutes: 1
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "快速配置文件查找与应用..."
          CONFIG_PROFILE="${{ github.event.inputs.config_profile }}"
          
          CONFIG_FOUND=""
          # 直接路径查找
          if [ -f "$CONFIG_PROFILE" ]; then
            CONFIG_FOUND="$CONFIG_PROFILE"
          elif [ -f "../$CONFIG_PROFILE" ]; then
            CONFIG_FOUND="../$CONFIG_PROFILE"
          elif [ -f "$GITHUB_WORKSPACE/$CONFIG_PROFILE" ]; then
            CONFIG_FOUND="$GITHUB_WORKSPACE/$CONFIG_PROFILE"
          else
            # 快速搜索
            CONFIG_FOUND=$(find . -maxdepth 3 -name "$CONFIG_PROFILE" -type f 2>/dev/null | head -1)
          fi
          
          if [ -n "$CONFIG_FOUND" ] && [ -f "$CONFIG_FOUND" ]; then
            echo "📋 复制配置文件: $CONFIG_FOUND -> .config"
            cp "$CONFIG_FOUND" .config
            echo "✅ 配置应用完成"
          else
            echo "❌ 错误: 无法找到配置文件 '$CONFIG_PROFILE'"
            exit 1
          fi

      - name: 🔧 EXT4文件系统空间紧急修复
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== EXT4文件系统空间紧急修复 ==="
          
          echo "🔧 设置分区大小: 内核=20MB, 根文件系统=96MB"
          sed -i 's/CONFIG_TARGET_KERNEL_PARTSIZE=.*/CONFIG_TARGET_KERNEL_PARTSIZE=20/' .config 2>/dev/null || true
          sed -i 's/CONFIG_TARGET_ROOTFS_PARTSIZE=.*/CONFIG_TARGET_ROOTFS_PARTSIZE=96/' .config 2>/dev/null || true
          
          # 确保配置存在
          echo "CONFIG_TARGET_KERNEL_PARTSIZE=20" >> .config
          echo "CONFIG_TARGET_ROOTFS_PARTSIZE=96" >> .config
          
          # 启用必要的文件系统
          echo "CONFIG_TARGET_ROOTFS_EXT4FS=y" >> .config
          echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
          
          echo "✅ 分区大小修复完成"

      - name: 🔧 设备镜像配置修复
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 设备镜像配置修复 ==="
          
          # 确保设备配置正确
          if grep -q "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u" .config; then
            sed -i 's/# CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u is not set/CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y/' .config
          else
            echo "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y" >> .config
          fi
          
          # 启用镜像生成
          echo "CONFIG_TARGET_IMAGES_INCLUDE_FACTORY=y" >> .config
          echo "CONFIG_TARGET_IMAGES_INCLUDE_SYSUPGRADE=y" >> .config
          
          echo "🔄 运行配置..."
          make defconfig >/dev/null 2>&1
          echo "✅ 设备镜像配置修复完成"

      - name: 🔧 快速Samba验证
        if: github.event.inputs.enable_custom_features == 'true'
        timeout-minutes: 2
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 快速Samba验证 ==="
          
          echo "🔍 检查Samba配置状态..."
          if grep -q "CONFIG_PACKAGE_samba4-server=y" .config; then
            echo "✅ Samba4已在配置中启用"
          else
            echo "🔧 启用Samba4配置..."
            echo "CONFIG_PACKAGE_samba4-server=y" >> .config
            echo "CONFIG_PACKAGE_samba4-libs=y" >> .config
            echo "CONFIG_PACKAGE_luci-app-samba4=y" >> .config
          fi
          
          echo "✅ Samba验证完成"

      - name: 📥 快速预下载
        if: github.event.inputs.enable_pre_download == 'true'
        timeout-minutes: 20
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 快速预下载 ==="
          
          echo "📥 开始快速预下载..."
          make download -j$(nproc) 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/download.log || echo "⚠️ 下载有警告但继续"
          
          echo "📊 下载结果:"
          find dl/ -type f 2>/dev/null | wc -l
          echo "✅ 预下载完成"

      - name: 🛠️ 快速工具链编译
        timeout-minutes: 45
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "开始快速工具链编译..."
          
          echo "🔧 编译工具链..."
          make toolchain/compile -j$(($(nproc) - 1)) V=sc 2>&1 | tee ${{ env.TOOLCHAIN_LOG_DIR }}/toolchain.log || {
            echo "⚠️ 工具链编译有警告，继续..."
          }
          
          echo "✅ 工具链编译完成"

      - name: 📦 快速自定义功能处理
        if: github.event.inputs.enable_custom_features == 'true'
        timeout-minutes: 5
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 快速自定义功能处理 ==="
          
          CONFIG_REPO_DIR="$GITHUB_WORKSPACE"
          CUSTOM_FEATURES_DIR="$CONFIG_REPO_DIR/firmware-config/custom-features"
          
          if [ -d "$CUSTOM_FEATURES_DIR" ]; then
            echo "🔍 处理自定义功能..."
            
            # 快速处理IPK包
            if [ -d "$CUSTOM_FEATURES_DIR/prebuilt-ipks" ]; then
              mkdir -p package/base-files/files/usr/lib/opkg/custom
              find "$CUSTOM_FEATURES_DIR/prebuilt-ipks" -name "*.ipk" -exec cp {} package/base-files/files/usr/lib/opkg/custom/ \; 2>/dev/null || true
              echo "✅ IPK包已复制"
            fi
            
            # 快速处理脚本
            if [ -d "$CUSTOM_FEATURES_DIR/scripts" ]; then
              find "$CUSTOM_FEATURES_DIR/scripts" -name "*.sh" -exec chmod +x {} \; -exec bash {} \; 2>/dev/null || true
              echo "✅ 脚本已执行"
            fi
          else
            echo "ℹ️ 无自定义功能目录，跳过"
          fi
          echo "✅ 自定义功能处理完成"

      - name: 🏗️ 高效编译固件
        timeout-minutes: 120
        id: compile-firmware
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "开始高效编译固件..."
          export FORCE_UNSAFE_CONFIGURE=1
          
          START_TIME=$(date +%s)
          LOG_FILE="${{ env.BUILD_LOG_DIR }}/compile.log"
          
          echo "🔧 开始并行编译..."
          if make -j$(($(nproc) - 1)) V=sc 2>&1 | tee "$LOG_FILE"; then
            BUILD_STATUS="success"
            echo "🎉 并行编译成功!"
          else
            echo "⚠️ 并行编译失败，尝试单线程编译..."
            if make -j1 V=s 2>&1 | tee "$LOG_FILE"; then
              BUILD_STATUS="success"
              echo "🎉 单线程编译成功!"
            else
              BUILD_STATUS="failed"
              echo "❌ 编译失败"
              exit 1
            fi
          fi
          
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "BUILD_DURATION=$DURATION" >> $GITHUB_ENV
          echo "BUILD_STATUS=$BUILD_STATUS" >> $GITHUB_ENV
          echo "⏱️ 编译耗时: ${DURATION}秒 ($(($DURATION/60))分钟)"

      - name: 🔍 编译产物验证
        if: env.BUILD_STATUS == 'success'
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 编译产物验证 ==="
          
          mkdir -p ${{ env.ARTIFACTS_DIR }}/firmware
          
          echo "🔍 搜索固件文件..."
          if [ -d "bin/targets" ]; then
            cp -r bin/targets ${{ env.ARTIFACTS_DIR }}/firmware/
            FIRMWARE_COUNT=$(find bin/targets -name "*.bin" -o -name "*.img" -o -name "*.trx" 2>/dev/null | wc -l)
            echo "📊 找到 $FIRMWARE_COUNT 个固件文件"
            
            # 检查ASUS特定镜像
            ASUS_IMAGES=$(find bin/targets -name "*asus_rt-ac42u*" -type f 2>/dev/null)
            if [ -n "$ASUS_IMAGES" ]; then
              echo "✅ ASUS RT-AC42U 镜像已生成:"
              for img in $ASUS_IMAGES; do
                echo "  - $(basename "$img")"
              done
            else
              echo "⚠️ 未找到ASUS RT-AC42U特定镜像"
            fi
          else
            echo "❌ 未找到固件输出目录"
            exit 1
          fi
          
          echo "FIRMWARE_COUNT=$FIRMWARE_COUNT" >> $GITHUB_ENV
          echo "✅ 产物验证完成"

      - name: 📋 快速日志收集
        if: always()
        run: |
          echo "开始快速日志收集..."
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs
          
          if [ -d "${{ env.BUILD_LOG_DIR }}" ]; then
            cp ${{ env.BUILD_LOG_DIR }}/*.log ${{ env.ARTIFACTS_DIR }}/logs/ 2>/dev/null || true
          fi
          
          if [ -d "${{ env.SOURCE_DIR }}" ]; then
            cd ${{ env.SOURCE_DIR }}
            cp .config ${{ env.ARTIFACTS_DIR }}/logs/final-config.txt 2>/dev/null || true
          fi
          
          echo "✅ 日志收集完成"

      - name: 💾 上传构建产物
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: Firmware-${{ github.run_number }}-${{ env.SOURCE_PRESET }}-${{ env.ACTUAL_BRANCH }}-${{ env.BUILD_STATUS || 'unknown' }}
          path: ${{ env.ARTIFACTS_DIR }}
          retention-days: 30

      - name: 🧹 快速清理
        if: always()
        run: |
          echo "开始快速清理..."
          sudo swapoff /mnt/swapfile 2>/dev/null || true
          sudo rm -f /mnt/swapfile 2>/dev/null || true
          echo "✅ 清理完成"

      - name: 📊 最终报告
        if: always()
        run: |
          echo "=== 最终报告 ==="
          echo "📦 源码信息:"
          echo "  - 预设: ${{ env.SOURCE_PRESET }}"
          echo "  - 分支: ${{ env.ACTUAL_BRANCH }}"
          echo "  - 提交: ${{ env.COMMIT_HASH || 'unknown' }}"
          echo ""
          echo "📈 构建结果:"
          echo "  - 状态: ${{ env.BUILD_STATUS || 'unknown' }}"
          echo "  - 时长: ${{ env.BUILD_DURATION || 'N/A' }}秒"
          echo "  - 固件数量: ${{ env.FIRMWARE_COUNT || 0 }}"
          echo ""
          if [ "${{ env.BUILD_STATUS }}" = "success" ]; then
            echo "🎉 构建成功！固件已上传到 Artifacts"
            echo "📦 下载 Artifacts 获取编译产物"
          else
            echo "❌ 构建失败"
            echo "🔍 请查看详细日志分析错误原因"
          fi

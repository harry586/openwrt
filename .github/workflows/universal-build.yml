name: "Universal Firmware Builder - Enhanced Validation Version"

on:
  workflow_dispatch:
    inputs:
      source_preset:
        description: "选择源码库"
        required: true
        type: choice
        options: ["immortalwrt", "openwrt", "lede"]
        default: "immortalwrt"
      source_branch:
        description: "源码分支"
        required: true
        default: "auto"
        type: string
      config_profile:
        description: "设备配置文件路径"
        required: true
        type: string
        default: ".config_rt-ac42u_immortalwrt"
      build_optimization:
        description: "编译优化策略"
        required: true
        type: choice
        options: ["balanced", "speed", "stability"]
        default: "balanced"
      toolchain_strategy:
        description: "工具链策略"
        required: true
        type: choice
        options: ["prebuilt", "local", "auto"]
        default: "auto"
      enable_custom_features:
        description: "启用自定义功能"
        required: false
        default: true
        type: boolean
      fix_common_issues:
        description: "自动修复常见问题"
        required: false
        default: true
        type: boolean
      enable_pre_download:
        description: "启用预下载验证"
        required: false
        default: true
        type: boolean
      enable_post_verify:
        description: "启用编译后验证"
        required: false
        default: true
        type: boolean
      debug_mode:
        description: "启用调试模式"
        required: false
        default: false
        type: boolean

env:
  TZ: "Asia/Shanghai"
  SOURCE_DIR: "/mnt/source"
  ARTIFACTS_DIR: "/mnt/artifacts"
  CCACHE_DIR: "/mnt/ccache"
  BUILD_LOG_DIR: "/mnt/build-logs"
  DOWNLOAD_DIR: "/mnt/downloads"
  TOOLCHAIN_LOG_DIR: "/mnt/toolchain-logs"
  DEBUG_MODE: "${{ github.event.inputs.debug_mode }}"

jobs:
  build:
    runs-on: "ubuntu-22.04"
    timeout-minutes: 240
    
    steps:
      - name: "📥 检出配置仓库"
        uses: "actions/checkout@v4"
        with:
          path: "."
          fetch-depth: 0

      - name: "🔍 智能文件发现与配置解析"
        id: "config-parser"
        run: |
          echo "=== 🔍 智能文件发现与配置解析 ==="
          echo "📋 查找 repositories.json 文件..."
          REPO_JSON_FOUND=""
          SEARCH_PATHS=(".", "..", "$GITHUB_WORKSPACE", "configs", "../configs")
          
          for path in "${SEARCH_PATHS[@]}"; do
            if [ -f "$path/repositories.json" ]; then
              REPO_JSON_FOUND="$path/repositories.json"
              FILE_SIZE=$(du -h "$REPO_JSON_FOUND" | cut -f1)
              echo "✅ 在路径 '$path' 找到 repositories.json ($FILE_SIZE)"
              break
            fi
          done
          
          if [ -z "$REPO_JSON_FOUND" ]; then
            echo "🔍 精确查找失败，尝试模糊搜索..."
            REPO_JSON_FOUND=$(find . -maxdepth 3 -name "*repositories*.json" -type f 2>/dev/null | head -1)
            if [ -n "$REPO_JSON_FOUND" ]; then
              FILE_SIZE=$(du -h "$REPO_JSON_FOUND" | cut -f1)
              echo "✅ 模糊搜索找到: $REPO_JSON_FOUND ($FILE_SIZE)"
            fi
          fi
          
          if [ -z "$REPO_JSON_FOUND" ]; then
            echo "🔍 尝试全目录深度搜索..."
            REPO_JSON_FOUND=$(find . -name "*repositories*.json" -type f 2>/dev/null | head -1)
            if [ -n "$REPO_JSON_FOUND" ]; then
              FILE_SIZE=$(du -h "$REPO_JSON_FOUND" | cut -f1)
              echo "✅ 深度搜索找到: $REPO_JSON_FOUND ($FILE_SIZE)"
            else
              echo "❌ 所有搜索尝试都失败，请确保 repositories.json 文件存在"
              find . -maxdepth 2 -type d -exec ls -la {} \; 2>/dev/null | head -20
              exit 1
            fi
          fi
          
          echo "REPO_JSON_PATH=$REPO_JSON_FOUND" >> $GITHUB_ENV
          DEFAULT_REPO=$(jq -r '.defaults.repository' "$REPO_JSON_FOUND" 2>/dev/null || echo "immortalwrt")
          CUSTOM_FEATURES_DIR=$(jq -r '.custom_features_support.features_directory' "$REPO_JSON_FOUND" 2>/dev/null || echo "firmware-config/custom-features")
          echo "DEFAULT_REPO=$DEFAULT_REPO" >> $GITHUB_ENV
          echo "CUSTOM_FEATURES_DIR=$CUSTOM_FEATURES_DIR" >> $GITHUB_ENV
          echo "✅ 配置文件解析完成"

      - name: "💾 智能系统资源分析"
        timeout-minutes: 2
        run: |
          echo "=== 💾 智能系统资源分析 ==="
          echo "📊 系统信息:"
          echo "🏷️ 系统版本: $(lsb_release -d | cut -f2)"
          echo "🐧 内核版本: $(uname -r)"
          echo "💻 CPU 架构: $(uname -m)"
          echo "📊 磁盘空间分析:"
          df -h | grep -E '(/|/mnt)' | while read line; do echo "  $line"; done
          echo "💻 CPU 资源:"
          echo "  - 核心数: $(nproc)"
          echo "  - CPU型号: $(grep -m1 'model name' /proc/cpuinfo | cut -d: -f2 | xargs)"
          echo "🧠 内存信息:"
          free -h
          ROOT_AVAILABLE=$(df / | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          MEM_AVAILABLE=$(free -g | awk 'NR==2 {print int($7)}')
          echo "📈 资源状态:"
          echo "  - 根分区可用: ${ROOT_AVAILABLE}GB"
          echo "  - 可用内存: ${MEM_AVAILABLE}GB"
          if [ "$ROOT_AVAILABLE" -lt 5 ]; then
            echo "🚨 警告: 根分区空间不足5GB，可能影响系统稳定性"
          fi
          if [ "$MEM_AVAILABLE" -lt 2 ]; then
            echo "🚨 警告: 可用内存不足2GB，编译可能失败"
          fi
          echo "✅ 资源分析完成"

      - name: "💾 增强内存管理与环境设置"
        timeout-minutes: 5
        run: |
          echo "=== 💾 增强内存管理与环境设置 ==="
          MNT_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}' 2>/dev/null || echo 0)
          echo "/mnt 分区可用空间: ${MNT_AVAILABLE}GB"
          if [ "$MNT_AVAILABLE" -lt 20 ]; then
            echo "🚨 严重错误: /mnt 分区空间不足20GB，无法编译"
            exit 1
          fi
          echo "🔄 创建智能交换文件..."
          SWAP_SIZE="8G"
          if [ "$MNT_AVAILABLE" -gt 50 ]; then
            SWAP_SIZE="12G"
            echo "💡 检测到充足空间，使用 ${SWAP_SIZE} 交换文件"
          fi
          if [ -f /mnt/swapfile ]; then
            echo "🔄 清理现有交换文件..."
            sudo swapoff /mnt/swapfile 2>/dev/null || true
            sudo rm -f /mnt/swapfile 2>/dev/null || true
          fi
          echo "📦 创建 ${SWAP_SIZE} 交换文件..."
          sudo dd if=/dev/zero of=/mnt/swapfile bs=1M count=$(( ${SWAP_SIZE%G} * 1024 )) status=progress || sudo fallocate -l $SWAP_SIZE /mnt/swapfile
          sudo chmod 600 /mnt/swapfile
          sudo mkswap /mnt/swapfile
          sudo swapon /mnt/swapfile
          echo "📊 当前内存状态:"
          free -h
          echo "🔧 创建工作目录结构..."
          sudo mkdir -p ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }} ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          sudo chown -R $USER:$USER ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }} ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          sudo chmod -R 755 ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }}
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=xterm-256color
          echo "✅ 环境设置完成"

      - name: "🛠️ 智能编译依赖安装"
        timeout-minutes: 10
        run: |
          echo "=== 🛠️ 智能编译依赖安装 ==="
          echo "📦 更新软件包列表..."
          sudo apt-get update
          echo "🔧 安装核心编译工具..."
          sudo apt-get install -y build-essential clang flex bison g++ gawk gcc-multilib g++-multilib
          echo "📚 安装开发库..."
          sudo apt-get install -y gettext git libncurses5-dev libssl-dev python3 python3-pip
          sudo apt-get install -y rsync unzip zlib1g-dev file wget jq ccache
          sudo apt-get install -y libtool-bin automake autoconf pkg-config subversion curl cmake ninja-build
          sudo apt-get install -y libelf-dev libssl-dev zlib1g-dev libxml2-dev liblzma-dev liblzo2-dev
          echo "🌐 安装网络工具..."
          sudo apt-get install -y axel curl wget net-tools
          CURRENT_GIT_VERSION=$(git --version | cut -d' ' -f3)
          echo "🔍 当前 Git 版本: $CURRENT_GIT_VERSION"
          echo "🔍 验证关键工具安装..."
          REQUIRED_TOOLS=("gcc" "g++" "make" "git" "curl" "wget" "python3" "cmake" "ninja")
          for tool in "${REQUIRED_TOOLS[@]}"; do
            if command -v $tool >/dev/null 2>&1; then
              version=$($tool --version 2>/dev/null | head -1 || echo "unknown")
              echo "✅ $tool: $version"
            else
              echo "❌ $tool: 未安装"
              exit 1
            fi
          done
          echo "✅ 依赖安装完成"

      - name: "⚡ 高级缓存与性能优化"
        timeout-minutes: 3
        run: |
          echo "=== ⚡ 高级缓存与性能优化 ==="
          OPTIMIZATION_STRATEGY="${{ github.event.inputs.build_optimization }}"
          echo "🎯 编译优化策略: $OPTIMIZATION_STRATEGY"
          case "$OPTIMIZATION_STRATEGY" in
            "speed")
              CCACHE_SIZE="12G"
              PARALLEL_JOBS=$(nproc)
              echo "🚀 速度优先模式: CCache=${CCACHE_SIZE}, 并行作业=${PARALLEL_JOBS}"
              ;;
            "stability")
              CCACHE_SIZE="4G"
              PARALLEL_JOBS=$(( $(nproc) - 2 ))
              echo "🛡️ 稳定性优先模式: CCache=${CCACHE_SIZE}, 并行作业=${PARALLEL_JOBS}"
              ;;
            *)
              CCACHE_SIZE="8G"
              PARALLEL_JOBS=$(( $(nproc) - 1 ))
              echo "⚖️ 平衡模式: CCache=${CCACHE_SIZE}, 并行作业=${PARALLEL_JOBS}"
              ;;
          esac
          mkdir -p ${{ env.CCACHE_DIR }}
          ccache -M $CCACHE_SIZE
          ccache -o compression=true
          ccache -o compression_level=6
          ccache -o max_files=100000
          echo "CCACHE_DIR=${{ env.CCACHE_DIR }}" >> $GITHUB_ENV
          echo "CCACHE_COMPRESS=1" >> $GITHUB_ENV
          echo "CCACHE_MAXSIZE=$CCACHE_SIZE" >> $GITHUB_ENV
          echo "PARALLEL_JOBS=$PARALLEL_JOBS" >> $GITHUB_ENV
          echo "📊 初始CCache统计:"
          ccache -s
          echo "🔧 系统性能调优..."
          echo "vm.swappiness=10" | sudo tee -a /etc/sysctl.conf
          echo "vm.vfs_cache_pressure=50" | sudo tee -a /etc/sysctl.conf
          echo "✅ 性能优化完成"

      - name: "🔧 智能源码配置解析"
        id: "source-config"
        run: |
          echo "=== 🔧 智能源码配置解析 ==="
          PRESET="${{ github.event.inputs.source_preset }}"
          REPO_JSON_PATH="${{ env.REPO_JSON_PATH }}"
          echo "🎯 正在解析预设: $PRESET"
          if ! jq -e ".repositories.$PRESET" "$REPO_JSON_PATH" >/dev/null 2>&1; then
            echo "❌ 错误: 预设 '$PRESET' 在 repositories.json 中不存在"
            jq -r '.repositories | keys_unsorted[]' "$REPO_JSON_PATH"
            exit 1
          fi
          SOURCE_URL=$(jq -r ".repositories.$PRESET.url" "$REPO_JSON_PATH")
          DESCRIPTION=$(jq -r ".repositories.$PRESET.description // \"未知\"" "$REPO_JSON_PATH")
          RECOMMENDED_BRANCH=$(jq -r ".repositories.$PRESET.recommended_branch" "$REPO_JSON_PATH")
          STABLE_BRANCHES=$(jq -r ".repositories.$PRESET.stable_branches[]" "$REPO_JSON_PATH" 2>/dev/null | tr '\n' ' ' || echo "")
          FEATURES=$(jq -r ".repositories.$PRESET.features | to_entries | map(\"\(.key)=\(.value)\") | join(\", \")" "$REPO_JSON_PATH" 2>/dev/null || echo "未知")
          NOTES=$(jq -r ".repositories.$PRESET.notes // \"无\"" "$REPO_JSON_PATH")
          BUILD_TIPS=$(jq -r ".repositories.$PRESET.build_tips // \"无\"" "$REPO_JSON_PATH")
          FEEDS_CONFIG=$(jq -r ".repositories.$PRESET.feeds_config | to_entries | map(\"\(.key)=\(.value)\") | join(\";\")" "$REPO_JSON_PATH" 2>/dev/null || echo "")
          BRANCH_FEEDS_MAPPING=$(jq -r ".repositories.$PRESET.branch_feeds_mapping | to_entries | map(\"\(.key)=\(.value)\") | join(\";\")" "$REPO_JSON_PATH" 2>/dev/null || echo "")
          BRANCH="${{ github.event.inputs.source_branch }}"
          if [ "$BRANCH" = "auto" ]; then
            BRANCH="$RECOMMENDED_BRANCH"
            echo "🤖 自动选择推荐分支: $BRANCH"
          else
            if [ -n "$STABLE_BRANCHES" ] && ! echo "$STABLE_BRANCHES" | grep -q "$BRANCH"; then
              echo "⚠️ 警告: 指定分支 '$BRANCH' 不在已知稳定分支列表中"
              echo "📋 推荐的稳定分支: $STABLE_BRANCHES"
            fi
          fi
          echo "SOURCE_URL=$SOURCE_URL" >> $GITHUB_ENV
          echo "SOURCE_BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "SOURCE_PRESET=$PRESET" >> $GITHUB_ENV
          echo "SOURCE_DESCRIPTION=$DESCRIPTION" >> $GITHUB_ENV
          echo "SOURCE_FEATURES=$FEATURES" >> $GITHUB_ENV
          echo "SOURCE_NOTES=$NOTES" >> $GITHUB_ENV
          echo "SOURCE_BUILD_TIPS=$BUILD_TIPS" >> $GITHUB_ENV
          echo "SOURCE_FEEDS_CONFIG=$FEEDS_CONFIG" >> $GITHUB_ENV
          echo "SOURCE_BRANCH_FEEDS_MAPPING=$BRANCH_FEEDS_MAPPING" >> $GITHUB_ENV
          echo "✅ 源码配置解析完成"
          echo "📦 仓库详细信息:"
          echo "  - URL: $SOURCE_URL"
          echo "  - 描述: $DESCRIPTION"
          echo "  - 使用分支: $BRANCH"
          echo "  - 推荐分支: $RECOMMENDED_BRANCH"
          echo "  - 稳定分支: $STABLE_BRANCHES"
          echo "  - 特性: $FEATURES"
          echo "  - 备注: $NOTES"
          echo "  - 编译提示: $BUILD_TIPS"

      - name: "📥 严格源码获取与验证"
        id: "clone-source"
        timeout-minutes: 20
        run: |
          echo "=== 📥 严格源码获取与验证 ==="
          cd ${{ env.SOURCE_DIR }}
          REQUESTED_BRANCH="${{ env.SOURCE_BRANCH }}"
          SOURCE_URL="${{ env.SOURCE_URL }}"
          PRESET="${{ env.SOURCE_PRESET }}"
          echo "🎯 目标仓库: $SOURCE_URL"
          echo "🎯 请求分支: $REQUESTED_BRANCH"
          echo "🎯 预设类型: $PRESET"
          echo "🧹 清理工作目录..."
          rm -rf .[!.]* * 2>/dev/null || true
          
          case "$PRESET" in
            "immortalwrt") BRANCH_STRATEGIES=("$REQUESTED_BRANCH" "openwrt-21.02" "openwrt-23.05" "master" "main") ;;
            "openwrt") BRANCH_STRATEGIES=("$REQUESTED_BRANCH" "main" "master" "v23.05.x" "v22.03.x") ;;
            "lede") BRANCH_STRATEGIES=("$REQUESTED_BRANCH" "master" "main") ;;
            *) BRANCH_STRATEGIES=("$REQUESTED_BRANCH" "master" "main") ;;
          esac
          
          BRANCH_STRATEGIES=($(printf "%s\n" "${BRANCH_STRATEGIES[@]}" | sort -u))
          echo "🔄 将尝试的分支策略: ${BRANCH_STRATEGIES[*]}"
          
          CLONE_SUCCESS=false
          for branch in "${BRANCH_STRATEGIES[@]}"; do
            echo "🔄 尝试分支: $branch"
            rm -rf .[!.]* * 2>/dev/null || true
            
            MAX_CLONE_RETRIES=2
            for ((retry=1; retry<=MAX_CLONE_RETRIES; retry++)); do
              echo "📥 克隆尝试 $retry/$MAX_CLONE_RETRIES..."
              if git clone --depth 1 --branch "$branch" "$SOURCE_URL" . 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/clone-$branch-attempt$retry.log; then
                break
              else
                echo "❌ 克隆尝试 $retry 失败"
                if [ $retry -eq $MAX_CLONE_RETRIES ]; then
                  continue 2
                fi
                sleep 3
              fi
            done
            
            if [ -d ".git" ] && [ -f "scripts/feeds" ]; then
              ACTUAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
              COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
              COMMIT_DATE=$(git log -1 --format=%ci 2>/dev/null || echo "unknown")
              COMMIT_MESSAGE=$(git log -1 --format=%s 2>/dev/null || echo "unknown")
              echo "✅ 克隆成功!"
              echo "📊 克隆详情:"
              echo "  - 实际分支: $ACTUAL_BRANCH"
              echo "  - 提交哈希: $COMMIT_HASH"
              echo "  - 提交时间: $COMMIT_DATE"
              echo "  - 提交信息: $COMMIT_MESSAGE"
              
              REQUIRED_FILES=("scripts/feeds" "rules.mk" "Config.in" "Makefile" "include/image.mk" "target/linux/Makefile")
              MISSING_FILES=0
              for file in "${REQUIRED_FILES[@]}"; do
                if [ ! -f "$file" ]; then
                  echo "❌ 必需文件 '$file' 不存在"
                  MISSING_FILES=$((MISSING_FILES+1))
                else
                  echo "✅ 文件 '$file' 存在"
                fi
              done
              
              if [ $MISSING_FILES -eq 0 ]; then
                CLONE_SUCCESS=true
                break
              else
                echo "❌ 缺失 $MISSING_FILES 个必需文件，尝试下一个分支"
                continue
              fi
            else
              echo "❌ 仓库结构不完整，尝试下一个分支"
              continue
            fi
          done
          
          if [ "$CLONE_SUCCESS" = "false" ]; then
            echo "❌ 所有分支策略都失败，尝试默认分支..."
            rm -rf .[!.]* * 2>/dev/null || true
            if git clone --depth 1 "$SOURCE_URL" . 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/clone-default.log; then
              if [ -d ".git" ] && [ -f "scripts/feeds" ]; then
                ACTUAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
                COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
                COMMIT_DATE=$(git log -1 --format=%ci 2>/dev/null || echo "unknown")
                COMMIT_MESSAGE=$(git log -1 --format=%s 2>/dev/null || echo "unknown")
                echo "✅ 默认分支克隆成功"
                CLONE_SUCCESS=true
              fi
            fi
          fi
          
          if [ "$CLONE_SUCCESS" = "false" ]; then
            echo "❌ 所有克隆策略都失败"
            echo "🔍 最后错误日志:"
            tail -50 ${{ env.BUILD_LOG_DIR }}/clone-*.log 2>/dev/null || echo "无日志文件"
            exit 1
          fi
          
          echo "ACTUAL_BRANCH=$ACTUAL_BRANCH" >> $GITHUB_ENV
          echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
          echo "COMMIT_DATE=$COMMIT_DATE" >> $GITHUB_ENV
          echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_ENV
          echo "✅ 源码获取与验证完成"

      - name: "🔄 严格源码初始化与Feeds修复"
        timeout-minutes: 30
        run: |
          echo "=== 🔄 严格源码初始化与Feeds修复 ==="
          cd ${{ env.SOURCE_DIR }}
          if [ ! -f "scripts/feeds" ]; then
            echo "❌ 错误: scripts/feeds 文件不存在"
            exit 1
          fi
          
          SOURCE_PRESET="${{ env.SOURCE_PRESET }}"
          ACTUAL_BRANCH="${{ env.ACTUAL_BRANCH }}"
          FEEDS_CONFIG="${{ env.SOURCE_FEEDS_CONFIG }}"
          BRANCH_FEEDS_MAPPING="${{ env.SOURCE_BRANCH_FEEDS_MAPPING }}"
          echo "📦 源码类型: $SOURCE_PRESET, 实际分支: $ACTUAL_BRANCH"
          
          echo "🎯 生成智能Feeds配置..."
          FEEDS_BRANCH=""
          if [ -n "$BRANCH_FEEDS_MAPPING" ]; then
            IFS=';' read -ra MAPPINGS <<< "$BRANCH_FEEDS_MAPPING"
            for mapping in "${MAPPINGS[@]}"; do
              IFS='=' read -r branch_name feeds_branch <<< "$mapping"
              if [ "$branch_name" = "$ACTUAL_BRANCH" ]; then
                FEEDS_BRANCH="$feeds_branch"
                echo "🔧 检测到分支映射: $ACTUAL_BRANCH -> $FEEDS_BRANCH"
                break
              fi
            done
          fi
          
          if [ -n "$FEEDS_CONFIG" ]; then
            echo "📋 使用预设Feeds配置..."
            rm -f feeds.conf
            IFS=';' read -ra FEED_ITEMS <<< "$FEEDS_CONFIG"
            for item in "${FEED_ITEMS[@]}"; do
              IFS='=' read -r feed_name feed_url <<< "$item"
              if [ -n "$FEEDS_BRANCH" ] && [[ "$feed_url" == *"github.com"* ]] && [[ "$feed_url" != *";"* ]]; then
                echo "src-git $feed_name $feed_url;$FEEDS_BRANCH" >> feeds.conf
              else
                echo "src-git $feed_name $feed_url" >> feeds.conf
              fi
            done
          else
            echo "📋 使用默认Feeds配置..."
            case "$SOURCE_PRESET" in
              "immortalwrt")
                BRANCH_SUFFIX=""
                if [ -n "$FEEDS_BRANCH" ]; then
                  BRANCH_SUFFIX=";$FEEDS_BRANCH"
                elif [[ "$ACTUAL_BRANCH" == *"21.02"* ]]; then
                  BRANCH_SUFFIX=";openwrt-21.02"
                elif [[ "$ACTUAL_BRANCH" == *"23.05"* ]]; then
                  BRANCH_SUFFIX=";openwrt-23.05"
                fi
                echo "src-git packages https://github.com/immortalwrt/packages.git$BRANCH_SUFFIX" > feeds.conf
                echo "src-git luci https://github.com/immortalwrt/luci.git$BRANCH_SUFFIX" >> feeds.conf
                echo "src-git routing https://github.com/immortalwrt/routing.git$BRANCH_SUFFIX" >> feeds.conf
                echo "src-git telephony https://github.com/immortalwrt/telephony.git$BRANCH_SUFFIX" >> feeds.conf
                ;;
              "openwrt")
                echo "src-git packages https://git.openwrt.org/feed/packages.git" > feeds.conf
                echo "src-git luci https://git.openwrt.org/project/luci.git" >> feeds.conf
                echo "src-git routing https://git.openwrt.org/feed/routing.git" >> feeds.conf
                echo "src-git telephony https://git.openwrt.org/feed/telephony.git" >> feeds.conf
                ;;
              "lede")
                echo "src-git packages https://github.com/coolsnowwolf/packages.git" > feeds.conf
                echo "src-git luci https://github.com/coolsnowwolf/luci.git" >> feeds.conf
                echo "src-git routing https://github.com/coolsnowwolf/routing.git" >> feeds.conf
                echo "src-git telephony https://github.com/coolsnowwolf/telephony.git" >> feeds.conf
                ;;
            esac
          fi
          
          echo "📋 Feeds配置内容:"
          cat feeds.conf
          
          echo "🔄 开始严格Feeds更新..."
          MAX_RETRIES=3
          RETRY_COUNT=0
          FEEDS_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "🔄 尝试更新Feeds (第 $((RETRY_COUNT+1)) 次)..."
            FEEDS_UPDATE_LOG="${{ env.BUILD_LOG_DIR }}/feeds-update-$RETRY_COUNT.log"
            
            if ./scripts/feeds update -a 2>&1 | tee "$FEEDS_UPDATE_LOG"; then
              if grep -q "Updated" "$FEEDS_UPDATE_LOG" || grep -q "Create index" "$FEEDS_UPDATE_LOG"; then
                echo "✅ Feeds更新成功!"
                FEEDS_SUCCESS=true
                break
              else
                echo "⚠️ Feeds更新无输出，可能失败"
              fi
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              echo "⚠️ Feeds更新失败，准备重试 ($RETRY_COUNT/$MAX_RETRIES)..."
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                sleep 5
                if [ $RETRY_COUNT -eq 1 ]; then
                  echo "🔄 尝试使用GitHub镜像源..."
                  sed -i 's|git.openwrt.org|github.com/openwrt|g' feeds.conf
                  sed -i 's|https://git.openwrt.org/|https://github.com/openwrt/|g' feeds.conf
                  echo "📋 更新后的Feeds配置:"
                  cat feeds.conf
                fi
              fi
            fi
          done
          
          if [ "$FEEDS_SUCCESS" = "false" ]; then
            echo "❌ Feeds更新失败，尝试最小化feeds配置..."
            echo "src-git packages https://github.com/openwrt/packages.git" > feeds.conf
            echo "src-git luci https://github.com/openwrt/luci.git" >> feeds.conf
            if ! ./scripts/feeds update -a 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/feeds-update-minimal.log; then
              echo "❌ 最小化feeds配置也失败"
              if [ -f "${{ env.BUILD_LOG_DIR }}/feeds-update-0.log" ]; then
                echo "🔍 详细错误:"
                grep -n -i -A3 -B3 "error\|failed\|not found" ${{ env.BUILD_LOG_DIR }}/feeds-update-0.log | head -20
              fi
              exit 1
            fi
          fi
          
          echo "📦 安装Feeds..."
          if ! ./scripts/feeds install -a 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/feeds-install.log; then
            echo "⚠️ Feeds安装有警告，但继续执行..."
          fi
          
          echo "🔍 验证Feeds安装..."
          if [ -d "feeds/packages" ] && [ -d "feeds/luci" ]; then
            echo "✅ Feeds安装验证通过"
            PACKAGE_COUNT=$(find feeds/packages -name "Makefile" 2>/dev/null | wc -l)
            LUCI_COUNT=$(find feeds/luci -name "Makefile" 2>/dev/null | wc -l)
            echo "📊 Feeds统计:"
            echo "  - 包数量: $PACKAGE_COUNT"
            echo "  - LuCI应用数量: $LUCI_COUNT"
          else
            echo "❌ Feeds安装验证失败"
            exit 1
          fi
          
          echo "🔧 修复常见的包配置问题..."
          COMMON_PACKAGES=("zstd" "zsh" "openssl" "libubox" "libjson-c" "libuv")
          for pkg in "${COMMON_PACKAGES[@]}"; do
            if [ -f "feeds/packages/utils/$pkg/Makefile" ]; then
              echo "🛠️ 检查 $pkg 配置..."
              sed -i 's/PKG_HASH:=.*/PKG_HASH:=skip/' feeds/packages/utils/$pkg/Makefile 2>/dev/null || true
              sed -i 's/PKG_VERSION:=.*/PKG_VERSION:=latest/' feeds/packages/utils/$pkg/Makefile 2>/dev/null || true
            fi
          done
          
          echo "✅ 源码初始化完成"

      - name: "💾 空间检测 - 编译前检查"
        timeout-minutes: 2
        run: |
          echo "=== 💾 空间检测 - 编译前检查 ==="
          echo "🔍 检查编译前磁盘空间..."
          df -h | grep -E '(/|/mnt)' | while read line; do echo "  $line"; done
          AVAILABLE_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "📊 可用空间: ${AVAILABLE_SPACE}GB"
          if [ "$AVAILABLE_SPACE" -lt 15 ]; then
            echo "🚨 警告: 可用空间不足15GB，编译可能失败"
          else
            echo "✅ 磁盘空间充足"
          fi
          echo "🧠 内存状态:"
          free -h

      - name: "🎯 严格配置文件搜索与应用"
        timeout-minutes: 5
        run: |
          echo "=== 🎯 严格配置文件搜索与应用 ==="
          cd ${{ env.SOURCE_DIR }}
          CONFIG_PROFILE="${{ github.event.inputs.config_profile }}"
          echo "🔍 严格查找配置文件: $CONFIG_PROFILE"
          
          CONFIG_FOUND=""
          SEARCH_PATHS=(".configs" "configs" "$GITHUB_WORKSPACE" "$GITHUB_WORKSPACE/configs" "../configs" "../.configs")
          
          for path in "${SEARCH_PATHS[@]}"; do
            if [ -f "$path/$CONFIG_PROFILE" ]; then
              CONFIG_FOUND="$path/$CONFIG_PROFILE"
              FILE_SIZE=$(du -h "$CONFIG_FOUND" | cut -f1)
              echo "✅ 在路径 '$path' 找到配置文件 ($FILE_SIZE)"
              break
            fi
          done
          
          if [ -z "$CONFIG_FOUND" ]; then
            echo "🔍 在配置仓库中深度搜索..."
            CONFIG_FOUND=$(find "$GITHUB_WORKSPACE" -maxdepth 4 -name "$CONFIG_PROFILE" -type f 2>/dev/null | head -1)
            if [ -n "$CONFIG_FOUND" ]; then
              FILE_SIZE=$(du -h "$CONFIG_FOUND" | cut -f1)
              echo "✅ 在配置仓库中找到: $CONFIG_FOUND ($FILE_SIZE)"
            fi
          fi
          
          if [ -z "$CONFIG_FOUND" ]; then
            echo "🔍 搜索配置文件变体..."
            CONFIG_VARIANTS=("$CONFIG_PROFILE" ".config_$CONFIG_PROFILE" "${CONFIG_PROFILE}.config" "config_$CONFIG_PROFILE")
            for variant in "${CONFIG_VARIANTS[@]}"; do
              FOUND=$(find "$GITHUB_WORKSPACE" -maxdepth 3 -name "$variant" -type f 2>/dev/null | head -1)
              if [ -n "$FOUND" ]; then
                CONFIG_FOUND="$FOUND"
                FILE_SIZE=$(du -h "$CONFIG_FOUND" | cut -f1)
                echo "✅ 找到配置文件变体: $CONFIG_FOUND ($FILE_SIZE)"
                break
              fi
            done
          fi
          
          if [ -z "$CONFIG_FOUND" ]; then
            echo "🔍 搜索任何.config文件..."
            CONFIG_FOUND=$(find "$GITHUB_WORKSPACE" -maxdepth 3 -name "*.config*" -type f 2>/dev/null | grep -v "node_modules\|feeds" | head -1)
            if [ -n "$CONFIG_FOUND" ]; then
              FILE_SIZE=$(du -h "$CONFIG_FOUND" | cut -f1)
              echo "⚠️ 使用找到的默认配置文件: $CONFIG_FOUND ($FILE_SIZE)"
            fi
          fi
          
          if [ -n "$CONFIG_FOUND" ] && [ -f "$CONFIG_FOUND" ]; then
            if grep -q "CONFIG_" "$CONFIG_FOUND" && (grep -q "CONFIG_TARGET" "$CONFIG_FOUND" || grep -q "CONFIG_PACKAGE" "$CONFIG_FOUND"); then
              echo "📋 复制配置文件: $CONFIG_FOUND -> .config"
              cp "$CONFIG_FOUND" .config
              CONFIG_LINES=$(wc -l < .config)
              TARGET_CONFIGS=$(grep -c "CONFIG_TARGET" .config || true)
              PACKAGE_CONFIGS=$(grep -c "CONFIG_PACKAGE" .config || true)
              echo "✅ 配置文件应用完成"
              echo "📊 配置文件信息:"
              echo "  - 总行数: $CONFIG_LINES"
              echo "  - 目标配置: $TARGET_CONFIGS"
              echo "  - 包配置: $PACKAGE_CONFIGS"
            else
              echo "❌ 错误: 找到的文件不是有效的配置文件"
              head -10 "$CONFIG_FOUND"
              exit 1
            fi
          else
            echo "❌ 错误: 无法找到有效的配置文件 '$CONFIG_PROFILE'"
            exit 1
          fi

      - name: "🔧 EXT4文件系统空间严格修复"
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔧 EXT4文件系统空间严格修复 ==="
          echo "🔧 设置严格分区大小限制..."
          cp .config .config.backup
          sed -i 's/CONFIG_TARGET_KERNEL_PARTSIZE=.*/CONFIG_TARGET_KERNEL_PARTSIZE=20/' .config 2>/dev/null || true
          sed -i 's/CONFIG_TARGET_ROOTFS_PARTSIZE=.*/CONFIG_TARGET_ROOTFS_PARTSIZE=96/' .config 2>/dev/null || true
          grep -q "CONFIG_TARGET_KERNEL_PARTSIZE" .config || echo "CONFIG_TARGET_KERNEL_PARTSIZE=20" >> .config
          grep -q "CONFIG_TARGET_ROOTFS_PARTSIZE" .config || echo "CONFIG_TARGET_ROOTFS_PARTSIZE=96" >> .config
          echo "CONFIG_TARGET_ROOTFS_EXT4FS=y" >> .config
          echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
          echo "# CONFIG_DEBUG_INFO is not set" >> .config
          echo "# CONFIG_DEBUG_KERNEL is not set" >> .config
          echo "# CONFIG_KERNEL_DEBUG_INFO is not set" >> .config
          echo "✅ 分区大小严格修复完成"

      - name: "🔧 严格设备镜像配置修复"
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔧 严格设备镜像配置修复 ==="
          echo "🔍 验证当前设备配置..."
          if grep -q "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u" .config; then
            echo "✅ 找到 ASUS RT-AC42U 设备配置"
            sed -i 's/# CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u is not set/CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y/' .config
          else
            echo "🔧 添加 ASUS RT-AC42U 设备配置"
            echo "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y" >> .config
          fi
          
          REQUIRED_CONFIGS=("CONFIG_TARGET_IMAGES_INCLUDE_FACTORY=y" "CONFIG_TARGET_IMAGES_INCLUDE_SYSUPGRADE=y" "CONFIG_TARGET_IMAGES_GZIP=y" "CONFIG_TARGET_ipq40xx=y" "CONFIG_TARGET_ipq40xx_generic=y")
          
          for config in "${REQUIRED_CONFIGS[@]}"; do
            config_name=$(echo "$config" | cut -d'=' -f1)
            if ! grep -q "$config_name" .config; then
              echo "🔧 添加缺失配置: $config"
              echo "$config" >> .config
            fi
          done
          
          echo "🔄 运行严格defconfig..."
          if ! make defconfig 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/defconfig.log; then
            echo "⚠️ defconfig 有警告，检查配置..."
          fi
          
          if grep -q "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y" .config; then
            echo "✅ ASUS RT-AC42U 设备配置验证通过"
          else
            echo "❌ ASUS RT-AC42U 设备配置验证失败"
            exit 1
          fi
          echo "✅ 设备镜像配置严格修复完成"

      - name: "🔧 快速Samba验证"
        if: github.event.inputs.enable_custom_features == 'true'
        timeout-minutes: 2
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔧 快速Samba验证 ==="
          echo "🔍 检查Samba配置状态..."
          if grep -q "CONFIG_PACKAGE_samba4-server=y" .config; then
            echo "✅ Samba4已在配置中启用"
          else
            echo "🔧 启用Samba4配置..."
            echo "CONFIG_PACKAGE_samba4-server=y" >> .config
            echo "CONFIG_PACKAGE_samba4-libs=y" >> .config
            echo "CONFIG_PACKAGE_samba4-client=y" >> .config
            echo "CONFIG_PACKAGE_luci-app-samba4=y" >> .config
            echo "✅ Samba4配置已添加"
          fi
          echo "✅ Samba验证完成"

      - name: "📦 增强自定义功能处理"
        if: github.event.inputs.enable_custom_features == 'true'
        timeout-minutes: 15
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 📦 增强自定义功能处理 ==="
          CONFIG_REPO_DIR="$GITHUB_WORKSPACE"
          CUSTOM_FEATURES_DIR="$CONFIG_REPO_DIR/${{ env.CUSTOM_FEATURES_DIR }}"
          
          echo "🔍 搜索自定义功能目录..."
          if [ -d "$CUSTOM_FEATURES_DIR" ]; then
            CUSTOM_DIR_SIZE=$(du -sh "$CUSTOM_FEATURES_DIR" | cut -f1)
            echo "✅ 找到自定义功能目录 ($CUSTOM_DIR_SIZE)"
            
            if [ -d "$CUSTOM_FEATURES_DIR/prebuilt-ipks" ]; then
              echo "📦 处理预构建IPK包..."
              IPK_FILES=$(find "$CUSTOM_FEATURES_DIR/prebuilt-ipks" -name "*.ipk" 2>/dev/null)
              IPK_COUNT=$(echo "$IPK_FILES" | wc -l)
              echo "📊 找到 $IPK_COUNT 个IPK文件"
              
              if [ "$IPK_COUNT" -gt 0 ]; then
                mkdir -p package/base-files/files/usr/lib/opkg/custom
                echo "$IPK_FILES" | while read ipk; do
                  ipk_size=$(du -h "$ipk" | cut -f1)
                  echo "复制: $(basename "$ipk") ($ipk_size)"
                  cp "$ipk" package/base-files/files/usr/lib/opkg/custom/
                done
                
                COPIED_COUNT=$(find package/base-files/files/usr/lib/opkg/custom -name "*.ipk" 2>/dev/null | wc -l)
                echo "✅ 成功复制 $COPIED_COUNT 个IPK包"
                
                mkdir -p package/base-files/files/etc/uci-defaults
                echo '#!/bin/sh' > package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo '[ -d "/usr/lib/opkg/custom" ] && {' >> package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo '    for ipk in /usr/lib/opkg/custom/*.ipk; do' >> package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo '        [ -f "$ipk" ] && opkg install "$ipk"' >> package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo '    done' >> package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo '}' >> package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo 'exit 0' >> package/base-files/files/etc/uci-defaults/99-custom-ipks
                chmod +x package/base-files/files/etc/uci-defaults/99-custom-ipks
                echo "✅ 创建IPK自动安装脚本"
              else
                echo "ℹ️ prebuilt-ipks 目录为空"
              fi
            else
              echo "ℹ️ 未找到 prebuilt-ipks 目录"
            fi
            
            if [ -d "$CUSTOM_FEATURES_DIR/scripts" ]; then
              echo "🔧 处理自定义脚本..."
              SCRIPT_FILES=$(find "$CUSTOM_FEATURES_DIR/scripts" -name "*.sh" 2>/dev/null)
              SCRIPT_COUNT=$(echo "$SCRIPT_FILES" | wc -l)
              echo "📊 找到 $SCRIPT_COUNT 个脚本文件"
              
              if [ "$SCRIPT_COUNT" -gt 0 ]; then
                echo "🔄 设置脚本执行权限并执行..."
                echo "$SCRIPT_FILES" | while read script; do
                  chmod +x "$script"
                  script_size=$(du -h "$script" | cut -f1)
                  echo "设置权限: $(basename "$script") ($script_size)"
                done
                
                echo "$SCRIPT_FILES" | sort | while read script; do
                  echo "执行脚本: $(basename "$script")"
                  if bash "$script" 2>&1; then
                    echo "✅ 脚本执行成功: $(basename "$script")"
                  else
                    echo "❌ 脚本执行失败: $(basename "$script")"
                  fi
                done
              else
                echo "ℹ️ scripts 目录为空"
              fi
            else
              echo "ℹ️ 未找到 scripts 目录"
            fi
            
            if [ -d "$CUSTOM_FEATURES_DIR/patches" ]; then
              echo "🩹 处理自定义补丁..."
              PATCH_FILES=$(find "$CUSTOM_FEATURES_DIR/patches" -name "*.patch" 2>/dev/null)
              PATCH_COUNT=$(echo "$PATCH_FILES" | wc -l)
              echo "📊 找到 $PATCH_COUNT 个补丁文件"
              
              if [ "$PATCH_COUNT" -gt 0 ]; then
                echo "$PATCH_FILES" | sort | while read patch; do
                  patch_size=$(du -h "$patch" | cut -f1)
                  echo "应用补丁: $(basename "$patch") ($patch_size)"
                  if patch -p1 --forward -r - < "$patch" 2>&1; then
                    echo "✅ 补丁应用成功: $(basename "$patch")"
                  else
                    echo "⚠️ 补丁应用可能有问题: $(basename "$patch")"
                  fi
                done
              else
                echo "ℹ️ patches 目录为空"
              fi
            else
              echo "ℹ️ 未找到 patches 目录"
            fi
            
            if [ -d "$CUSTOM_FEATURES_DIR/configs" ]; then
              echo "⚙️ 处理自定义配置..."
              CONFIG_FILES=$(find "$CUSTOM_FEATURES_DIR/configs" -type f 2>/dev/null)
              CONFIG_COUNT=$(echo "$CONFIG_FILES" | wc -l)
              echo "📊 找到 $CONFIG_COUNT 个配置文件"
              
              if [ "$CONFIG_COUNT" -gt 0 ]; then
                echo "$CONFIG_FILES" | while read config; do
                  rel_path=$(realpath --relative-to="$CUSTOM_FEATURES_DIR/configs" "$config")
                  target_dir="package/base-files/files/$(dirname "$rel_path")"
                  mkdir -p "$target_dir"
                  config_size=$(du -h "$config" | cut -f1)
                  cp "$config" "$target_dir/"
                  echo "✅ 复制配置: $rel_path ($config_size)"
                done
              else
                echo "ℹ️ configs 目录为空"
              fi
            else
              echo "ℹ️ 未找到 configs 目录"
            fi
            
            echo "🎉 自定义功能处理完成"
          else
            echo "ℹ️ 无自定义功能目录，跳过详细处理"
          fi
          echo "✅ 自定义功能处理完成"

      - name: "🔧 下载源优化与修复"
        timeout-minutes: 5
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔧 下载源优化与修复 ==="
          echo "🔧 设置备用下载镜像..."
          cp scripts/download.pl scripts/download.pl.backup
          sed -i 's|https://downloads.openwrt.org|https://mirror2.openwrt.org/sources|g' scripts/download.pl
          sed -i 's|https://github.com|https://ghproxy.com/https://github.com|g' scripts/download.pl
          sed -i 's|https://git.kernel.org|https://mirror.gitkernel.org|g' scripts/download.pl
          
          echo '#!/bin/sh' > scripts/download-with-retry
          echo 'MAX_RETRIES=3' >> scripts/download-with-retry
          echo 'RETRY_COUNT=0' >> scripts/download-with-retry
          echo 'DOWNLOAD_SCRIPT="/mnt/source/scripts/download.pl"' >> scripts/download-with-retry
          echo 'while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do' >> scripts/download-with-retry
          echo '    if $DOWNLOAD_SCRIPT "$@"; then' >> scripts/download-with-retry
          echo '        echo "✅ 下载成功"' >> scripts/download-with-retry
          echo '        exit 0' >> scripts/download-with-retry
          echo '    fi' >> scripts/download-with-retry
          echo '    RETRY_COUNT=$((RETRY_COUNT+1))' >> scripts/download-with-retry
          echo '    echo "❌ 下载失败，第 $RETRY_COUNT 次重试..."' >> scripts/download-with-retry
          echo '    sleep 5' >> scripts/download-with-retry
          echo 'done' >> scripts/download-with-retry
          echo 'echo "❌ 下载失败，已达到最大重试次数"' >> scripts/download-with-retry
          echo 'exit 1' >> scripts/download-with-retry
          chmod +x scripts/download-with-retry
          echo "✅ 下载源优化完成"

      - name: "💾 空间检测 - 预下载前检查"
        timeout-minutes: 2
        run: |
          echo "=== 💾 空间检测 - 预下载前检查 ==="
          echo "🔍 检查预下载前磁盘空间..."
          df -h | grep -E '(/|/mnt)' | while read line; do echo "  $line"; done
          AVAILABLE_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "📊 可用空间: ${AVAILABLE_SPACE}GB"
          if [ "$AVAILABLE_SPACE" -lt 10 ]; then
            echo "🚨 警告: 可用空间不足10GB，下载可能失败"
          else
            echo "✅ 磁盘空间充足"
          fi

      - name: "📥 严格预下载验证"
        if: github.event.inputs.enable_pre_download == 'true'
        timeout-minutes: 45
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 📥 严格预下载验证 ==="
          echo "🔧 设置下载目录..."
          mkdir -p ${{ env.DOWNLOAD_DIR }}
          [ -d "dl" ] && rm -rf dl
          ln -sf ${{ env.DOWNLOAD_DIR }} dl
          
          DOWNLOAD_LOG="${{ env.BUILD_LOG_DIR }}/download.log"
          MAX_DOWNLOAD_RETRIES=2
          DOWNLOAD_SUCCESS=false
          
          echo "📥 开始严格预下载验证..."
          echo "🔧 使用并行下载: ${{ env.PARALLEL_JOBS }} 个任务"
          
          for ((retry=1; retry<=MAX_DOWNLOAD_RETRIES; retry++)); do
            echo "🔄 下载尝试 $retry/$MAX_DOWNLOAD_RETRIES..."
            
            if make download -j${{ env.PARALLEL_JOBS }} V=sc 2>&1 | tee "$DOWNLOAD_LOG"; then
              if grep -q "Downloaded\|File already downloaded" "$DOWNLOAD_LOG"; then
                echo "✅ 下载成功完成"
                DOWNLOAD_SUCCESS=true
                break
              else
                echo "⚠️ 下载无输出，可能失败"
              fi
            else
              echo "❌ 下载尝试 $retry 失败"
              if [ $retry -lt $MAX_DOWNLOAD_RETRIES ]; then
                sleep 10
              fi
            fi
          done
          
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "⚠️ 并行下载失败，尝试单线程下载..."
            if make download -j1 V=s 2>&1 | tee -a "$DOWNLOAD_LOG"; then
              echo "✅ 单线程下载成功"
              DOWNLOAD_SUCCESS=true
            else
              echo "❌ 所有下载尝试都失败"
              grep -i "error\|failed\|not found\|hash mismatch" "$DOWNLOAD_LOG" | head -20
              exit 1
            fi
          fi
          
          echo "🔍 严格验证下载文件..."
          DOWNLOAD_COUNT=$(find dl/ -type f 2>/dev/null | wc -l)
          DOWNLOAD_SIZE=$(du -sh dl/ 2>/dev/null | cut -f1 || echo "未知")
          echo "📊 下载结果统计:"
          echo "  - 文件数量: $DOWNLOAD_COUNT"
          echo "  - 总大小: $DOWNLOAD_SIZE"
          
          if [ "$DOWNLOAD_COUNT" -lt 10 ]; then
            echo "⚠️ 警告: 下载的文件数量较少，可能有问题"
          else
            echo "✅ 下载文件数量正常"
          fi
          
          KEY_FILES=("linux-*.tar.xz" "toolchain-*.tar.xz" "*.tar.gz" "*.tar.bz2")
          for pattern in "${KEY_FILES[@]}"; do
            files=$(find dl/ -name "$pattern" 2>/dev/null | head -5)
            if [ -n "$files" ]; then
              echo "✅ 找到文件模式: $pattern"
            else
              echo "⚠️ 未找到文件模式: $pattern"
            fi
          done
          
          echo "✅ 严格预下载验证完成"

      - name: "💾 空间检测 - 工具链编译前检查"
        timeout-minutes: 2
        run: |
          echo "=== 💾 空间检测 - 工具链编译前检查 ==="
          echo "🔍 检查工具链编译前磁盘空间..."
          df -h | grep -E '(/|/mnt)' | while read line; do echo "  $line"; done
          AVAILABLE_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "📊 可用空间: ${AVAILABLE_SPACE}GB"
          if [ "$AVAILABLE_SPACE" -lt 8 ]; then
            echo "🚨 警告: 可用空间不足8GB，工具链编译可能失败"
          else
            echo "✅ 磁盘空间充足"
          fi

      - name: "🛠️ 严格工具链编译验证 - 增强版"
        timeout-minutes: 120
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🛠️ 严格工具链编译验证 - 增强版 ==="
          
          # 定义最大重试次数
          MAX_TOOLCHAIN_RETRIES=3
          RETRY_COUNT=0
          TOOLCHAIN_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_TOOLCHAIN_RETRIES ] && [ "$TOOLCHAIN_SUCCESS" = "false" ]; do
            echo "🔄 工具链编译尝试 $((RETRY_COUNT+1))/$MAX_TOOLCHAIN_RETRIES"
            
            # 清理之前的工具链编译
            if [ $RETRY_COUNT -gt 0 ]; then
              echo "🧹 清理工具链编译目录..."
              make toolchain/clean 2>/dev/null || true
              rm -rf build_dir/toolchain-* 2>/dev/null || true
              rm -rf staging_dir/toolchain-* 2>/dev/null || true
              
              # 如果是第二次重试，重新下载工具链源码
              if [ $RETRY_COUNT -eq 2 ]; then
                echo "📥 重新下载工具链源码..."
                rm -rf dl/{gcc*,binutils*,linux*,glibc*,musl*} 2>/dev/null || true
                make toolchain/download -j1 V=s 2>&1 | tee ${{ env.TOOLCHAIN_LOG_DIR }}/toolchain-download-retry.log || true
              fi
            fi
            
            echo "🔧 第一步: 编译基础工具..."
            TOOLS_LOG="${{ env.TOOLCHAIN_LOG_DIR }}/tools-compile-attempt-$RETRY_COUNT.log"
            if ! make tools/install -j${{ env.PARALLEL_JOBS }} V=s 2>&1 | tee "$TOOLS_LOG"; then
              echo "⚠️ 基础工具编译有警告，继续执行..."
            fi
            
            echo "🔧 第二步: 工具链编译..."
            TOOLCHAIN_LOG="${{ env.TOOLCHAIN_LOG_DIR }}/toolchain-attempt-$RETRY_COUNT.log"
            START_TIME=$(date +%s)
            
            if make toolchain/compile -j${{ env.PARALLEL_JOBS }} V=s 2>&1 | tee "$TOOLCHAIN_LOG"; then
              END_TIME=$(date +%s)
              DURATION=$((END_TIME - START_TIME))
              echo "✅ 工具链编译成功!"
              echo "⏱️ 耗时: ${DURATION}秒"
              
              # 验证工具链完整性
              if ls staging_dir/toolchain-*/bin/*-gcc >/dev/null 2>&1 && ls staging_dir/toolchain-*/bin/*-g++ >/dev/null 2>&1; then
                TOOLCHAIN_SUCCESS=true
                echo "🎉 工具链验证通过!"
              else
                echo "❌ 工具链文件不完整，准备重试..."
                TOOLCHAIN_SUCCESS=false
              fi
            else
              RETRY_COUNT=$((RETRY_COUNT+1))
              END_TIME=$(date +%s)
              DURATION=$((END_TIME - START_TIME))
              echo "❌ 工具链编译失败 (耗时: ${DURATION}秒)"
              
              # 分析失败原因
              if grep -q "No such file\|not found" "$TOOLCHAIN_LOG"; then
                echo "🔍 失败原因: 文件缺失，可能需要重新下载"
              elif grep -q "error:" "$TOOLCHAIN_LOG"; then
                echo "🔍 失败原因: 编译错误"
              elif grep -q "undefined reference" "$TOOLCHAIN_LOG"; then
                echo "🔍 失败原因: 链接错误"
              fi
              
              if [ $RETRY_COUNT -lt $MAX_TOOLCHAIN_RETRIES ]; then
                echo "🔄 等待10秒后重试..."
                sleep 10
              fi
            fi
          done
          
          # 最终单线程尝试
          if [ "$TOOLCHAIN_SUCCESS" = "false" ]; then
            echo "🔄 最终尝试: 单线程工具链编译..."
            make toolchain/clean 2>/dev/null || true
            TOOLCHAIN_SINGLE_LOG="${{ env.TOOLCHAIN_LOG_DIR }}/toolchain-final-single.log"
            
            if make toolchain/compile -j1 V=s 2>&1 | tee "$TOOLCHAIN_SINGLE_LOG"; then
              echo "✅ 单线程工具链编译成功!"
              TOOLCHAIN_SUCCESS=true
            else
              echo "❌ 所有工具链编译尝试都失败"
              echo "🔍 分析错误日志..."
              grep -i "error:\|failed\|No such file\|undefined reference" "$TOOLCHAIN_SINGLE_LOG" | head -20
              exit 1
            fi
          fi
          
          echo "✅ 工具链编译验证完成"

      - name: "🔍 智能文件级验证与重试机制"
        timeout-minutes: 10
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔍 智能文件级验证与重试机制 ==="
          
          # 创建验证状态文件
          VALIDATION_STATUS_FILE="${{ env.BUILD_LOG_DIR }}/validation-status.json"
          if [ ! -f "$VALIDATION_STATUS_FILE" ]; then
            echo '{"verified_files": {}, "failed_files": {}, "retry_attempts": {}}' > "$VALIDATION_STATUS_FILE"
          fi

          echo "🔍 开始文件级验证..."
          
          # 定义验证项目和对应的修复命令
          declare -A VALIDATION_ITEMS=(
            # 工具链关键文件
            ["toolchain_gcc"]="staging_dir/toolchain-*/bin/*-gcc|CRITICAL|make toolchain/gcc/{clean,compile}"
            ["toolchain_g++"]="staging_dir/toolchain-*/bin/*-g++|CRITICAL|make toolchain/gcc/{clean,compile}"
            ["toolchain_ld"]="staging_dir/toolchain-*/bin/*-ld|CRITICAL|make toolchain/binutils/{clean,compile}"
            ["toolchain_ar"]="staging_dir/toolchain-*/bin/*-ar|CRITICAL|make toolchain/binutils/{clean,compile}"
            
            # 基础工具
            ["host_mkhash"]="staging_dir/host/bin/mkhash|CRITICAL|make tools/mkhash/{clean,compile}"
            ["host_cmake"]="staging_dir/host/bin/cmake|IMPORTANT|make tools/cmake/{clean,compile}"
            ["host_ninja"]="staging_dir/host/bin/ninja|IMPORTANT|make tools/ninja/{clean,compile}"
            
            # 核心配置文件
            ["main_config"]=".config|CRITICAL|cp $GITHUB_WORKSPACE/${{ github.event.inputs.config_profile }} .config"
            ["feeds_config"]="feeds.conf|IMPORTANT|./scripts/feeds update -a"
            
            # 下载文件验证（抽样检查）
            ["download_kernel"]="dl/linux-*.tar.xz|IMPORTANT|make target/linux/download"
            ["download_gcc"]="dl/gcc-*.tar.xz|IMPORTANT|make toolchain/gcc/download"
            ["download_binutils"]="dl/binutils-*.tar.xz|IMPORTANT|make toolchain/binutils/download"
          )
          
          # 执行验证
          FAILED_ITEMS=()
          NEEDS_RETRY=()
          
          for item_key in "${!VALIDATION_ITEMS[@]}"; do
            IFS='|' read -r pattern level repair_cmd <<< "${VALIDATION_ITEMS[$item_key]}"
            
            echo "🔍 验证: $item_key ($level)"
            
            # 检查文件是否存在
            if ls $pattern >/dev/null 2>&1; then
              # 文件存在，检查是否可执行（如果是二进制文件）
              first_file=$(ls $pattern 2>/dev/null | head -1)
              if [[ "$first_file" == *"/bin/"* ]]; then
                if [ -x "$first_file" ]; then
                  echo "✅ $item_key: 存在且可执行"
                  # 更新验证状态
                  jq --arg key "$item_key" --arg file "$first_file" '.verified_files[$key] = $file' "$VALIDATION_STATUS_FILE" > tmp.json && mv tmp.json "$VALIDATION_STATUS_FILE"
                else
                  echo "❌ $item_key: 存在但不可执行"
                  FAILED_ITEMS+=("$item_key")
                  NEEDS_RETRY+=("$item_key|$repair_cmd")
                fi
              else
                echo "✅ $item_key: 存在"
                jq --arg key "$item_key" --arg file "$first_file" '.verified_files[$key] = $file' "$VALIDATION_STATUS_FILE" > tmp.json && mv tmp.json "$VALIDATION_STATUS_FILE"
              fi
            else
              echo "❌ $item_key: 不存在"
              FAILED_ITEMS+=("$item_key")
              NEEDS_RETRY+=("$item_key|$repair_cmd")
            fi
          done
          
          # 处理验证结果
          if [ ${#FAILED_ITEMS[@]} -eq 0 ]; then
            echo "🎉 所有文件验证通过!"
            echo "VALIDATION_PASSED=true" >> $GITHUB_ENV
          else
            echo "⚠️ 发现 ${#FAILED_ITEMS[@]} 个验证失败项"
            echo "📋 失败项目: ${FAILED_ITEMS[*]}"
            
            # 检查是否有CRITICAL级别失败
            CRITICAL_FAILED=0
            for failed_item in "${FAILED_ITEMS[@]}"; do
              IFS='|' read -r pattern level repair_cmd <<< "${VALIDATION_ITEMS[$failed_item]}"
              if [ "$level" = "CRITICAL" ]; then
                echo "🚨 CRITICAL级别失败: $failed_item"
                CRITICAL_FAILED=1
              fi
            done
            
            if [ $CRITICAL_FAILED -eq 1 ]; then
              echo "❌ 有关键文件验证失败，无法继续编译"
              exit 1
            else
              echo "🔄 将尝试修复非关键失败项..."
              echo "NEEDS_RETRY_ITEMS=${NEEDS_RETRY[*]}" >> $GITHUB_ENV
              echo "VALIDATION_PASSED=with_retry" >> $GITHUB_ENV
            fi
          fi

      - name: "🔧 智能文件级修复与重编译"
        if: env.NEEDS_RETRY_ITEMS
        timeout-minutes: 30
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔧 智能文件级修复与重编译 ==="
          
          RETRY_ITEMS=(${NEEDS_RETRY_ITEMS// / })
          echo "🔄 需要重试的项目: ${#RETRY_ITEMS[@]}个"
          
          SUCCESSFUL_RETRIES=0
          FAILED_RETRIES=0
          
          for retry_item in "${RETRY_ITEMS[@]}"; do
            IFS='|' read -r item_key repair_cmd <<< "$retry_item"
            
            echo "🔧 修复: $item_key"
            echo "📝 执行: $repair_cmd"
            
            # 执行修复命令
            if eval "$repair_cmd" 2>&1 | tee "${{ env.BUILD_LOG_DIR }}/retry-$item_key.log"; then
              echo "✅ $item_key 修复成功"
              SUCCESSFUL_RETRIES=$((SUCCESSFUL_RETRIES+1))
              
              # 验证修复结果
              IFS='|' read -r pattern level original_cmd <<< "${VALIDATION_ITEMS[$item_key]}"
              if ls $pattern >/dev/null 2>&1; then
                echo "✅ $item_key 验证通过"
              else
                echo "⚠️ $item_key 修复但验证未通过"
              fi
            else
              echo "❌ $item_key 修复失败"
              FAILED_RETRIES=$((FAILED_RETRIES+1))
            fi
          done
          
          echo "📊 修复结果:"
          echo "  - 成功: $SUCCESSFUL_RETRIES"
          echo "  - 失败: $FAILED_RETRIES"
          
          if [ $FAILED_RETRIES -eq 0 ]; then
            echo "🎉 所有修复成功!"
            echo "RETRY_SUCCESS=true" >> $GITHUB_ENV
          else
            echo "⚠️ 有 $FAILED_RETRIES 个项目修复失败"
            echo "RETRY_SUCCESS=partial" >> $GITHUB_ENV
          fi

      - name: "📦 包级别编译状态监控与重试"
        timeout-minutes: 15
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 📦 包级别编译状态监控与重试 ==="
          
          # 创建包状态跟踪文件
          PACKAGE_STATUS_FILE="${{ env.BUILD_LOG_DIR }}/package-status.json"
          if [ ! -f "$PACKAGE_STATUS_FILE" ]; then
            echo '{"compiled_packages": {}, "failed_packages": {}, "retry_history": {}}' > "$PACKAGE_STATUS_FILE"
          fi
          
          # 关键包列表和它们的验证文件
          declare -A CRITICAL_PACKAGES=(
            ["toolchain"]="staging_dir/toolchain-*/bin/*-gcc"
            ["kernel"]="build_dir/target-*/linux-*/linux-*/vmlinux"
            ["base-files"]="build_dir/target-*/base-files-*/.built"
            ["busybox"]="build_dir/target-*/busybox-*/.built"
            ["libc"]="staging_dir/target-*/usr/lib/libc.so"
          )
          
          echo "🔍 检查关键包编译状态..."
          
          FAILED_PACKAGES=()
          for pkg in "${!CRITICAL_PACKAGES[@]}"; do
            pattern="${CRITICAL_PACKAGES[$pkg]}"
            
            if ls $pattern >/dev/null 2>&1; then
              echo "✅ $pkg: 编译成功"
              jq --arg pkg "$pkg" --arg status "success" '.compiled_packages[$pkg] = $status' "$PACKAGE_STATUS_FILE" > tmp.json && mv tmp.json "$PACKAGE_STATUS_FILE"
            else
              echo "❌ $pkg: 编译失败或未编译"
              FAILED_PACKAGES+=("$pkg")
              jq --arg pkg "$pkg" --arg status "failed" '.failed_packages[$pkg] = $status' "$PACKAGE_STATUS_FILE" > tmp.json && mv tmp.json "$PACKAGE_STATUS_FILE"
            fi
          done
          
          if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
            echo "🔄 需要重编译的包: ${FAILED_PACKAGES[*]}"
            echo "FAILED_PACKAGES=${FAILED_PACKAGES[*]}" >> $GITHUB_ENV
          else
            echo "🎉 所有关键包编译正常"
            echo "PACKAGES_VALID=true" >> $GITHUB_ENV
          fi

      - name: "🔧 智能包重编译系统"
        if: env.FAILED_PACKAGES
        timeout-minutes: 45
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔧 智能包重编译系统 ==="
          
          FAILED_PACKAGES=(${FAILED_PACKAGES// / })
          echo "🔄 开始重编译 ${#FAILED_PACKAGES[@]} 个包"
          
          # 包重编译策略
          declare -A PACKAGE_RECOMPILE_STRATEGY=(
            ["toolchain"]="make toolchain/{clean,compile} -j1 V=s"
            ["kernel"]="make target/linux/{clean,compile} -j1 V=s"
            ["base-files"]="make package/base-files/{clean,compile} -j${{ env.PARALLEL_JOBS }} V=s"
            ["busybox"]="make package/busybox/{clean,compile} -j${{ env.PARALLEL_JOBS }} V=s"
            ["libc"]="make toolchain/{clean,compile} -j1 V=s"
          )
          
          SUCCESSFUL_RECOMPILES=()
          FAILED_RECOMPILES=()
          
          for pkg in "${FAILED_PACKAGES[@]}"; do
            if [ -n "${PACKAGE_RECOMPILE_STRATEGY[$pkg]}" ]; then
              echo "🔧 重编译: $pkg"
              echo "📝 策略: ${PACKAGE_RECOMPILE_STRATEGY[$pkg]}"
              
              RECOMPILE_LOG="${{ env.BUILD_LOG_DIR }}/recompile-$pkg.log"
              START_TIME=$(date +%s)
              
              if eval "${PACKAGE_RECOMPILE_STRATEGY[$pkg]}" 2>&1 | tee "$RECOMPILE_LOG"; then
                END_TIME=$(date +%s)
                DURATION=$((END_TIME - START_TIME))
                
                # 验证重编译结果
                pattern="${CRITICAL_PACKAGES[$pkg]}"
                if ls $pattern >/dev/null 2>&1; then
                  echo "✅ $pkg 重编译成功 (耗时: ${DURATION}秒)"
                  SUCCESSFUL_RECOMPILES+=("$pkg")
                else
                  echo "⚠️ $pkg 重编译完成但验证失败"
                  FAILED_RECOMPILES+=("$pkg")
                fi
              else
                echo "❌ $pkg 重编译失败"
                FAILED_RECOMPILES+=("$pkg")
              fi
            else
              echo "⚠️ 没有为 $pkg 定义重编译策略"
              FAILED_RECOMPILES+=("$pkg")
            fi
          done
          
          echo "📊 重编译结果:"
          echo "  - 成功: ${#SUCCESSFUL_RECOMPILES[@]} (${SUCCESSFUL_RECOMPILES[*]})"
          echo "  - 失败: ${#FAILED_RECOMPILES[@]} (${FAILED_RECOMPILES[*]})"
          
          if [ ${#FAILED_RECOMPILES[@]} -eq 0 ]; then
            echo "🎉 所有包重编译成功!"
            echo "RECOMPILE_SUCCESS=true" >> $GITHUB_ENV
          else
            echo "⚠️ 有 ${#FAILED_RECOMPILES[@]} 个包重编译失败"
            echo "RECOMPILE_SUCCESS=partial" >> $GITHUB_ENV
          fi

      - name: "🔍 智能编译前最终验证"
        timeout-minutes: 5
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔍 智能编译前最终验证 ==="
          
          echo "🔍 分级验证所有必要组件..."
          
          # 级别1: 关键组件验证（失败则退出）
          CRITICAL_FAILED=0
          if [ ! -d "dl" ] || [ "$(find dl/ -type f 2>/dev/null | wc -l)" -lt 5 ]; then
            echo "❌ 关键错误: 下载文件不足"
            CRITICAL_FAILED=1
          else
            echo "✅ 下载文件验证通过"
          fi
          
          if [ ! -f ".config" ] || ! grep -q "CONFIG_TARGET" .config; then
            echo "❌ 关键错误: 配置文件无效"
            CRITICAL_FAILED=1
          else
            echo "✅ 配置验证通过"
          fi
          
          if [ $CRITICAL_FAILED -eq 1 ]; then
            echo "🚨 关键验证失败，无法继续编译"
            exit 1
          fi
          
          # 级别2: 重要组件验证（失败则修复）
          IMPORTANT_FAILED=0
          if [ ! -d "staging_dir/toolchain-" ] || [ -z "$(find staging_dir/toolchain-*/bin -name '*-gcc' 2>/dev/null | head -1)" ]; then
            echo "⚠️ 重要警告: 工具链不完整，但可以尝试修复"
            IMPORTANT_FAILED=1
            echo "TOOLCHAIN_REPAIR_NEEDED=true" >> $GITHUB_ENV
          else
            echo "✅ 工具链验证通过"
          fi
          
          if [ ! -d "feeds/packages" ] || [ ! -d "feeds/luci" ]; then
            echo "⚠️ 重要警告: Feeds不完整"
            IMPORTANT_FAILED=1
          else
            echo "✅ Feeds验证通过"
          fi
          
          # 级别3: 资源验证（警告但不停止）
          AVAILABLE_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          if [ "$AVAILABLE_SPACE" -lt 10 ]; then
            echo "⚠️ 资源警告: 磁盘空间紧张 (${AVAILABLE_SPACE}GB)"
          else
            echo "✅ 磁盘空间充足: ${AVAILABLE_SPACE}GB"
          fi
          
          SWAP_SIZE=$(free -g | awk 'NR==3 {print $2}')
          if [ "$SWAP_SIZE" -lt 4 ]; then
            echo "⚠️ 资源警告: 交换空间较小 (${SWAP_SIZE}GB)"
          else
            echo "✅ 交换空间充足: ${SWAP_SIZE}GB"
          fi
          
          if [ $IMPORTANT_FAILED -eq 0 ]; then
            echo "🎉 所有验证通过，开始编译..."
            echo "READY_FOR_COMPILE=true" >> $GITHUB_ENV
          else
            echo "🔄 需要修复后继续编译..."
            echo "READY_FOR_COMPILE=with_warnings" >> $GITHUB_ENV
          fi

      - name: "👁️ 编译过程实时监控"
        if: env.READY_FOR_COMPILE
        timeout-minutes: 180
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 👁️ 编译过程实时监控 ==="
          
          # 创建监控状态文件
          MONITOR_FILE="${{ env.BUILD_LOG_DIR }}/compile-monitor.json"
          echo '{"start_time": "'$(date +%s)'", "last_check": "", "interventions": []}' > "$MONITOR_FILE"
          
          # 编译监控函数
          monitor_compile() {
            local log_file="$1"
            local timeout_minutes="$2"
            local start_time=$(date +%s)
            local timeout_seconds=$((timeout_minutes * 60))
            
            echo "🔍 开始监控编译过程，超时: ${timeout_minutes}分钟"
            
            # 使用tee同时输出到文件和控制台，同时进行监控
            {
              make -j${{ env.PARALLEL_JOBS }} V=s 2>&1 | \
              while IFS= read -r line; do
                echo "$line"
                
                # 实时分析编译输出
                current_time=$(date +%s)
                elapsed=$((current_time - start_time))
                
                # 检测常见错误模式
                if echo "$line" | grep -q "Error [0-9]"; then
                  echo "🚨 检测到编译错误: $line"
                  jq --arg time "$elapsed" --arg error "$line" '.interventions += [{"type": "error", "time": $time, "message": $error}]' "$MONITOR_FILE" > tmp.json && mv tmp.json "$MONITOR_FILE"
                fi
                
                if echo "$line" | grep -q "No rule to make target"; then
                  missing_target=$(echo "$line" | grep -o "target '[^']*'" | head -1)
                  echo "🔧 检测到缺失目标: $missing_target"
                  jq --arg time "$elapsed" --arg target "$missing_target" '.interventions += [{"type": "missing_target", "time": $time, "target": $target}]' "$MONITOR_FILE" > tmp.json && mv tmp.json "$MONITOR_FILE"
                fi
                
                # 检测长时间卡住
                if [ $elapsed -gt 1200 ] && echo "$line" | grep -q "Configuring"; then
                  package=$(echo "$line" | grep -o "Configuring [^ ]*" | cut -d' ' -f2)
                  echo "⏰ 检测到配置卡住: $package"
                  jq --arg time "$elapsed" --arg package "$package" '.interventions += [{"type": "stuck_config", "time": $time, "package": $package}]' "$MONITOR_FILE" > tmp.json && mv tmp.json "$MONITOR_FILE"
                fi
                
                # 更新最后检查时间
                jq --arg time "$elapsed" '.last_check = $time' "$MONITOR_FILE" > tmp.json && mv tmp.json "$MONITOR_FILE"
              done
            } | tee "$log_file"
            
            return ${PIPESTATUS[0]}
          }
          
          # 执行监控编译
          COMPILE_LOG="${{ env.BUILD_LOG_DIR }}/monitored-compile.log"
          if monitor_compile "$COMPILE_LOG" 120; then
            echo "🎉 监控编译完成"
            echo "MONITORED_COMPILE_SUCCESS=true" >> $GITHUB_ENV
            echo "BUILD_STATUS=success" >> $GITHUB_ENV
          else
            echo "❌ 监控编译失败"
            echo "分析干预记录..."
            jq '.interventions[]' "$MONITOR_FILE" 2>/dev/null || echo "无干预记录"
            echo "BUILD_STATUS=failed" >> $GITHUB_ENV
            exit 1
          fi

      - name: "🔄 基于监控的智能修复"
        if: failure() && env.BUILD_STATUS == 'failed'
        timeout-minutes: 30
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔄 基于监控的智能修复 ==="
          
          MONITOR_FILE="${{ env.BUILD_LOG_DIR }}/compile-monitor.json"
          if [ -f "$MONITOR_FILE" ]; then
            echo "🔍 分析监控数据..."
            
            # 提取常见的失败模式
            STUCK_PACKAGES=$(jq -r '.interventions[] | select(.type == "stuck_config") | .package' "$MONITOR_FILE" 2>/dev/null | head -3)
            MISSING_TARGETS=$(jq -r '.interventions[] | select(.type == "missing_target") | .target' "$MONITOR_FILE" 2>/dev/null | head -3)
            
            if [ -n "$STUCK_PACKAGES" ]; then
              echo "🔧 处理卡住的包: $STUCK_PACKAGES"
              for pkg in $STUCK_PACKAGES; do
                echo "🔄 重新配置: $pkg"
                make "package/$pkg/{clean,configure}" -j1 V=s 2>&1 | tee "${{ env.BUILD_LOG_DIR }}/fix-$pkg.log" || true
              done
            fi
            
            if [ -n "$MISSING_TARGETS" ]; then
              echo "🔧 处理缺失目标..."
              for target in $MISSING_TARGETS; do
                clean_target=$(echo "$target" | sed "s/'//g")
                echo "🔄 清理目标: $clean_target"
                make "$clean_target/clean" 2>&1 | tee "${{ env.BUILD_LOG_DIR }}/clean-$clean_target.log" || true
              done
            fi
            
            echo "🔄 尝试继续编译..."
            if make -j${{ env.PARALLEL_JOBS }} V=s 2>&1 | tee "${{ env.BUILD_LOG_DIR }}/resume-compile.log"; then
              echo "🎉 修复后编译成功!"
              echo "BUILD_STATUS=success" >> $GITHUB_ENV
            else
              echo "❌ 修复后编译仍然失败"
              exit 1
            fi
          else
            echo "❌ 无监控数据，无法智能修复"
            exit 1
          fi

      - name: "🎯 严格工厂镜像保障"
        if: env.BUILD_STATUS == 'success'
        timeout-minutes: 25
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🎯 严格工厂镜像保障 ==="
          echo "🔍 严格检查工厂镜像生成状态..."
          ASUS_FACTORY=$(find bin/targets -name "*asus*rt-ac42u*" -o -name "*rt-ac42u*" | grep -i factory || true)
          
          if [ -n "$ASUS_FACTORY" ]; then
            echo "✅ 工厂镜像已存在:"
            for img in $ASUS_FACTORY; do
              size=$(du -h "$img" | cut -f1)
              echo "  - $img ($size)"
            done
            echo "FACTORY_EXISTS=true" >> $GITHUB_ENV
          else
            echo "❌ 未找到工厂镜像，开始严格修复流程..."
            echo "FACTORY_EXISTS=false" >> $GITHUB_ENV
            
            echo "🔧 第一步: 重新配置目标..."
            make target/linux/{clean,prepare} V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/factory-repair-step1.log || true
            
            echo "🔧 第二步: 重新编译内核..."
            make target/linux/compile -j1 V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/factory-repair-step2.log || true
            
            echo "🔧 第三步: 专门编译目标设备镜像..."
            make target/linux/ipq40xx/image/install -j1 V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/factory-repair-step3.log || true
            
            echo "🔧 第四步: 最后尝试完整目标编译..."
            make target/install -j1 V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/factory-repair-step4.log || true
            
            ASUS_FACTORY_RETRY=$(find bin/targets -name "*asus*rt-ac42u*" -o -name "*rt-ac42u*" | grep -i factory || true)
            if [ -n "$ASUS_FACTORY_RETRY" ]; then
              echo "✅ 工厂镜像修复成功!"
              for img in $ASUS_FACTORY_RETRY; do
                size=$(du -h "$img" | cut -f1)
                echo "  - $img ($size)"
              done
              echo "FACTORY_EXISTS=true" >> $GITHUB_ENV
            else
              echo "❌ 工厂镜像生成失败"
            fi
          fi

      - name: "🔍 严格编译产物验证"
        if: env.BUILD_STATUS == 'success'
        timeout-minutes: 10
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 🔍 严格编译产物验证 ==="
          mkdir -p ${{ env.ARTIFACTS_DIR }}/firmware
          
          echo "🔍 严格搜索固件文件..."
          if [ -d "bin/targets" ]; then
            echo "✅ 找到固件输出目录"
            find bin/targets -type f \( -name "*.bin" -o -name "*.img" -o -name "*.trx" -o -name "*.gz" \) > ${{ env.ARTIFACTS_DIR }}/firmware-list.txt
            FIRMWARE_COUNT=$(wc -l < ${{ env.ARTIFACTS_DIR }}/firmware-list.txt)
            
            echo "📦 复制 $FIRMWARE_COUNT 个固件文件..."
            COPIED_COUNT=0
            while IFS= read -r firmware; do
              if [ -f "$firmware" ]; then
                cp "$firmware" ${{ env.ARTIFACTS_DIR }}/firmware/ 2>/dev/null && COPIED_COUNT=$((COPIED_COUNT+1)) || true
              fi
            done < ${{ env.ARTIFACTS_DIR }}/firmware-list.txt
            
            echo "✅ 成功复制 $COPIED_COUNT 个固件文件"
            
            ASUS_FACTORY=$(find bin/targets -name "*asus*rt-ac42u*" -o -name "*rt-ac42u*" | grep -i factory || true)
            ASUS_SYSUPGRADE=$(find bin/targets -name "*asus*rt-ac42u*" -o -name "*rt-ac42u*" | grep -v factory || true)
            
            if [ -n "$ASUS_FACTORY" ]; then
              echo "✅ 工厂镜像:"
              for img in $ASUS_FACTORY; do
                size=$(du -h "$img" | cut -f1)
                echo "  - $(basename "$img") ($size)"
                cp "$img" ${{ env.ARTIFACTS_DIR }}/firmware/ 2>/dev/null || true
              done
            else
              echo "❌ 未找到工厂镜像!"
            fi
            
            if [ -n "$ASUS_SYSUPGRADE" ]; then
              echo "✅ 升级镜像:"
              for img in $ASUS_SYSUPGRADE; do
                size=$(du -h "$img" | cut -f1)
                echo "  - $(basename "$img") ($size)"
              done
            else
              echo "❌ 未找到升级镜像!"
            fi
            
            ARTIFACT_SIZE=$(du -sh ${{ env.ARTIFACTS_DIR }}/firmware/ 2>/dev/null | cut -f1 || echo "未知")
            echo "📦 产物总大小: $ARTIFACT_SIZE"
          else
            echo "❌ 未找到固件输出目录"
          fi
          
          FINAL_COUNT=$(find ${{ env.ARTIFACTS_DIR }}/firmware -type f 2>/dev/null | wc -l || echo 0)
          echo "FIRMWARE_COUNT=$FINAL_COUNT" >> $GITHUB_ENV
          echo "📊 最终固件数量: $FINAL_COUNT"
          
          if [ "$FINAL_COUNT" -eq 0 ]; then
            echo "❌ 错误: 没有生成任何固件文件"
            exit 1
          else
            echo "✅ 固件生成验证通过"
          fi

      - name: "📋 严格日志收集与分析"
        if: always()
        timeout-minutes: 8
        run: |
          echo "=== 📋 严格日志收集与分析 ==="
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs
          
          KEY_LOGS=("${{ env.BUILD_LOG_DIR }}/critical-errors.log" "${{ env.BUILD_LOG_DIR }}/compile.log" "${{ env.BUILD_LOG_DIR }}/download.log" "${{ env.BUILD_LOG_DIR }}/toolchain.log" "${{ env.BUILD_LOG_DIR }}/feeds-update-0.log" "${{ env.BUILD_LOG_DIR }}/feeds-install.log" "${{ env.BUILD_LOG_DIR }}/kernel-compile.log" "${{ env.BUILD_LOG_DIR }}/factory-repair.log")
          
          for log in "${KEY_LOGS[@]}"; do
            if [ -f "$log" ]; then
              base_name=$(basename "$log")
              cp "$log" "${{ env.ARTIFACTS_DIR }}/logs/${base_name}" 2>/dev/null || true
            fi
          done
          
          if [ -d "${{ env.SOURCE_DIR }}" ]; then
            cd ${{ env.SOURCE_DIR }}
            cp .config ${{ env.ARTIFACTS_DIR }}/logs/final-config.txt 2>/dev/null || true
            ccache -s > ${{ env.ARTIFACTS_DIR }}/logs/ccache-stats.txt 2>/dev/null || true
          fi
          
          if [ -f "${{ env.ARTIFACTS_DIR }}/firmware-list.txt" ]; then
            cp ${{ env.ARTIFACTS_DIR }}/firmware-list.txt ${{ env.ARTIFACTS_DIR }}/logs/ 2>/dev/null || true
          fi
          
          echo "✅ 严格日志收集完成"

      - name: "💾 上传构建产物"
        if: always()
        uses: "actions/upload-artifact@v4"
        with:
          name: "Firmware-${{ github.run_number }}-${{ env.SOURCE_PRESET }}-${{ env.ACTUAL_BRANCH }}-${{ env.BUILD_STATUS || 'unknown' }}"
          path: "${{ env.ARTIFACTS_DIR }}"
          retention-days: 30
          compression-level: 9

      - name: "🧹 智能清理"
        if: always()
        timeout-minutes: 5
        run: |
          echo "=== 🧹 智能清理 ==="
          sudo swapoff /mnt/swapfile 2>/dev/null || true
          sudo rm -f /mnt/swapfile 2>/dev/null || true
          ccache -s
          echo "✅ 智能清理完成"

      - name: "📊 最终详细报告"
        if: always()
        timeout-minutes: 5
        run: |
          echo "=== 📊 最终详细报告 ==="
          echo ""
          echo "🎯 构建详细摘要"
          echo "=========================================="
          echo "📦 源码信息:"
          echo "  - 预设: ${{ env.SOURCE_PRESET }}"
          echo "  - 分支: ${{ env.ACTUAL_BRANCH }}"
          echo "  - 提交: ${{ env.COMMIT_HASH || 'unknown' }}"
          echo ""
          echo "📈 构建结果:"
          echo "  - 状态: ${{ env.BUILD_STATUS || 'unknown' }}"
          echo "  - 时长: ${{ env.BUILD_DURATION || 'N/A' }}秒 ($((${{ env.BUILD_DURATION || 0 }}/60))分钟)"
          echo "  - 固件数量: ${{ env.FIRMWARE_COUNT || 0 }}"
          echo "  - 工厂镜像: ${{ env.FACTORY_EXISTS || 'unknown' }}"
          echo "  - 优化策略: ${{ github.event.inputs.build_optimization }}"
          echo ""
          echo "🔧 功能状态:"
          echo "  - 自定义功能: ${{ github.event.inputs.enable_custom_features }}"
          echo "  - 预下载: ${{ github.event.inputs.enable_pre_download }}"
          echo "  - 问题修复: ${{ github.event.inputs.fix_common_issues }}"
          echo "  - 调试模式: ${{ github.event.inputs.debug_mode }}"
          echo ""
          
          if [ "${{ env.BUILD_STATUS }}" = "success" ]; then
            if [ "${{ env.FACTORY_EXISTS }}" = "true" ]; then
              echo "🎉 构建成功！工厂镜像已生成"
              echo ""
              echo "🚨 救砖重要提示:"
              echo "   1. 下载 Artifacts 中的固件文件"
              echo "   2. 查找名称包含 'factory' 的镜像文件"
              echo "   3. 使用 ASUS 官方恢复工具刷入工厂镜像"
              echo "   4. 等待路由器自动重启完成"
              echo "   5. 不要使用 sysupgrade 镜像救砖！"
            else
              echo "⚠️ 构建成功但未生成工厂镜像"
            fi
          else
            echo "❌ 构建失败"
            echo ""
            echo "🔍 故障排除建议:"
            echo "   - 查看 critical-errors.log"
            echo "   - 验证配置文件是否正确"
            echo "   - 检查网络连接和仓库状态"
          fi
          echo ""
          echo "⏰ 完成时间: $(date)"
          echo "=========================================="

name: Universal Firmware Builder - Enhanced Pre-download & Verification

on:
  workflow_dispatch:
    inputs:
      source_preset:
        description: 选择源码库
        required: true
        type: choice
        options:
          - immortalwrt
          - openwrt
          - lede
        default: immortalwrt
      source_branch:
        description: 源码分支
        required: true
        default: auto
        type: string
      config_profile:
        description: 设备配置文件路径
        required: true
        type: string
        default: .config_rt-ac42u_immortalwrt
      build_optimization:
        description: 编译优化策略
        required: true
        type: choice
        options:
          - balanced
          - speed
          - stability
        default: balanced
      toolchain_strategy:
        description: 工具链策略
        required: true
        type: choice
        options:
          - prebuilt
          - local
          - auto
        default: auto
      enable_custom_features:
        description: 启用自定义功能
        required: false
        default: true
        type: boolean
      fix_common_issues:
        description: 自动修复常见问题
        required: false
        default: true
        type: boolean
      enable_pre_download:
        description: 启用预下载验证
        required: false
        default: true
        type: boolean
      enable_post_verify:
        description: 启用编译后验证
        required: false
        default: true
        type: boolean

env:
  TZ: Asia/Shanghai
  SOURCE_DIR: /mnt/source
  ARTIFACTS_DIR: /mnt/artifacts
  CCACHE_DIR: /mnt/ccache
  BUILD_LOG_DIR: /mnt/build-logs
  DOWNLOAD_DIR: /mnt/downloads
  TOOLCHAIN_LOG_DIR: /mnt/toolchain-logs

jobs:
  build:
    runs-on: ubuntu-22.04
    timeout-minutes: 360
    steps:
      - name: 📥 检出配置仓库
        uses: actions/checkout@v4
        with:
          path: .
          fetch-depth: 0

      - name: 💾 智能系统资源分析
        timeout-minutes: 2
        run: |
          echo "=== 智能系统资源分析 ==="
          echo "📊 磁盘空间:"
          df -h
          echo ""
          echo "💻 CPU 信息:"
          echo "核心数: $(nproc)"
          echo "架构: $(uname -m)"
          echo "CPU 型号: $(grep 'model name' /proc/cpuinfo | head -1 | cut -d: -f2 | sed 's/^ *//')"
          echo ""
          echo "🧠 内存信息:"
          free -h
          echo ""
          echo "🔄 交换空间: $(swapon --show | wc -l 2>/dev/null || echo 0) 个交换文件"
          echo ""
          
          # 空间检查
          echo "🔍 关键分区空间检查:"
          ROOT_AVAILABLE=$(df / | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "根分区可用空间: ${ROOT_AVAILABLE}GB"
          if [ "$ROOT_AVAILABLE" -lt 5 ]; then
            echo "🚨 警告: 根分区空间不足5GB，可能影响系统稳定性"
          fi
          
          echo "✅ 资源分析完成 - 系统就绪"

      - name: 💾 增强内存管理与环境设置
        run: |
          echo "=== 增强内存管理与环境设置 ==="
          
          # 空间检查
          echo "🔍 编译分区空间检查..."
          MNT_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}' 2>/dev/null || echo 0)
          echo "/mnt 分区可用空间: ${MNT_AVAILABLE}GB"
          if [ "$MNT_AVAILABLE" -lt 15 ]; then
            echo "🚨 严重错误: /mnt 分区空间不足15GB，无法编译"
            exit 1
          elif [ "$MNT_AVAILABLE" -lt 25 ]; then
            echo "⚠️ 警告: /mnt 分区空间紧张 (${MNT_AVAILABLE}GB)"
          else
            echo "✅ /mnt 分区空间充足"
          fi
          
          echo "🔄 创建16GB交换文件..."
          if [ -f /mnt/swapfile ]; then
            sudo swapoff /mnt/swapfile 2>/dev/null || true
            sudo rm -f /mnt/swapfile 2>/dev/null || true
          fi
          
          sudo dd if=/dev/zero of=/mnt/swapfile bs=1M count=16384 status=progress || 
            sudo fallocate -l 16G /mnt/swapfile || 
            sudo truncate -s 16G /mnt/swapfile
          sudo chmod 600 /mnt/swapfile
          sudo mkswap /mnt/swapfile
          sudo swapon /mnt/swapfile
          
          echo "📊 当前内存状态:"
          free -h
          echo "交换空间:"
          swapon --show
          
          echo "⚡ 优化内存参数..."
          sudo sysctl -w vm.swappiness=80 2>/dev/null || echo "⚠️ 无法设置swappiness"
          sudo sysctl -w vm.vfs_cache_pressure=50 2>/dev/null || echo "⚠️ 无法设置vfs_cache_pressure"
          
          echo "🔧 创建工作目录..."
          sudo mkdir -p ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }} ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          sudo chown -R $USER:$USER ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }} ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          sudo chmod -R 755 ${{ env.SOURCE_DIR }} ${{ env.ARTIFACTS_DIR }}
          sudo chmod -R 777 ${{ env.CCACHE_DIR }} ${{ env.BUILD_LOG_DIR }} ${{ env.DOWNLOAD_DIR }} ${{ env.TOOLCHAIN_LOG_DIR }}
          
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=xterm-256color
          
          echo "📊 设置后磁盘空间状态:"
          df -h

      - name: 🛠️ 全面编译依赖安装与验证
        run: |
          echo "安装全面编译依赖包..."
          sudo apt-get update
          echo "📦 安装基础编译工具..."
          sudo apt-get install -y build-essential clang flex bison g++ gawk gcc-multilib g++-multilib
          echo "📦 安装开发库..."
          sudo apt-get install -y gettext git libncurses5-dev libssl-dev python3 python3-pip python3-setuptools
          echo "📦 安装工具链依赖..."
          sudo apt-get install -y rsync unzip zlib1g-dev file wget jq ccache m4 help2man texinfo texi2html
          echo "📦 安装构建工具..."
          sudo apt-get install -y libtool-bin automake autoconf pkg-config subversion mercurial curl cmake ninja-build
          echo "📦 安装系统库..."
          sudo apt-get install -y libelf-dev libssl-dev zlib1g-dev libc6-dev libxml2-dev liblzma-dev liblzo2-dev
          echo "🔍 依赖安装验证..."
          echo "=== 关键工具验证 ==="
          for tool in gcc g++ make flex bison git curl wget ninja; do
            if command -v $tool >/dev/null 2>&1; then
              version=$($tool --version 2>/dev/null | head -1 | cut -d' ' -f1-4 | tr -d '\n' || echo "可用")
              echo "✅ $tool: $version"
            else
              echo "❌ $tool: 未安装"
              exit 1
            fi
          done
          echo "✅ 所有依赖安装和验证完成"

      - name: ⚡ 高级缓存与性能优化
        run: |
          echo "设置高级缓存与性能优化..."
          mkdir -p ${{ env.CCACHE_DIR }}
          ccache -M 16G
          ccache -o compression=true
          ccache -o compression_level=6
          ccache -o max_files=200000
          ccache -o sloppiness=file_macro,include_file_mtime,include_file_ctime,time_macros
          echo "CCACHE_DIR=${{ env.CCACHE_DIR }}" >> $GITHUB_ENV
          echo "CCACHE_COMPRESS=1" >> $GITHUB_ENV
          echo "CCACHE_MAXSIZE=16G" >> $GITHUB_ENV
          echo "CCACHE_SLOPPINESS=file_macro,include_file_mtime,include_file_ctime,time_macros" >> $GITHUB_ENV
          echo "📊 初始CCache统计:"
          ccache -s
          echo "✅ 缓存与性能优化完成"

      - name: 🔍 智能文件发现与配置分析
        id: file-discovery
        run: |
          echo "=== 智能文件发现与配置分析 ==="
          set +o pipefail
          
          echo "📋 查找 repositories.json 文件..."
          REPO_JSON_FOUND=$(find . -maxdepth 3 -name "repositories.json" -type f 2>/dev/null | head -1)
          if [ -n "$REPO_JSON_FOUND" ]; then
            echo "✅ 找到 repositories.json: $REPO_JSON_FOUND"
            echo "REPO_JSON_PATH=$REPO_JSON_FOUND" >> $GITHUB_ENV
            echo "📊 repositories.json 内容分析:"
            jq -r '.repositories | keys[] as $k | "  - \($k): \(.[$k].description // "无描述")"' "$REPO_JSON_FOUND" 2>/dev/null || echo "无法解析JSON内容"
          else
            echo "❌ 未找到 repositories.json 文件"
            exit 1
          fi
          
          echo "📋 智能查找所有配置文件..."
          CONFIG_PATTERNS=(".config_*" "config_*" "*.config")
          ALL_CONFIG_FILES=""
          for pattern in "${CONFIG_PATTERNS[@]}"; do
            echo "搜索模式: $pattern"
            found_files=$(find . -maxdepth 3 -name "$pattern" -type f 2>/dev/null | head -10)
            if [ -n "$found_files" ]; then
              ALL_CONFIG_FILES="$ALL_CONFIG_FILES"$'\n'"$found_files"
              echo "找到文件:"
              echo "$found_files"
            fi
          done
          
          if [ -n "$ALL_CONFIG_FILES" ]; then
            CONFIG_COUNT=$(echo "$ALL_CONFIG_FILES" | grep -v '^$' | wc -l)
            echo "✅ 总共找到 $CONFIG_COUNT 个配置文件"
            echo "CONFIG_FILES_FOUND=true" >> $GITHUB_ENV
            echo "$ALL_CONFIG_FILES" > ${{ env.BUILD_LOG_DIR }}/all_config_files.txt
          else
            echo "⚠️ 未找到任何配置文件"
            echo "CONFIG_FILES_FOUND=false" >> $GITHUB_ENV
          fi
          
          set -o pipefail
          echo "✅ 智能文件发现完成"

      - name: 🔧 智能源码配置解析
        id: source-config
        run: |
          echo "正在智能解析源码配置..."
          PRESET="${{ github.event.inputs.source_preset }}"
          echo "使用的预设: $PRESET"
          REPO_JSON_PATH="${{ env.REPO_JSON_PATH }}"
          
          if ! jq -e ".repositories.$PRESET" "$REPO_JSON_PATH" >/dev/null 2>&1; then
            echo "❌ 错误: 预设 '$PRESET' 不存在"
            echo "可用的预设:"
            jq -r '.repositories | keys[]' "$REPO_JSON_PATH"
            exit 1
          fi
          
          SOURCE_URL=$(jq -r ".repositories.$PRESET.url" "$REPO_JSON_PATH")
          DESCRIPTION=$(jq -r ".repositories.$PRESET.description // \"未知\"" "$REPO_JSON_PATH")
          RECOMMENDED_BRANCH=$(jq -r ".repositories.$PRESET.recommended_branch" "$REPO_JSON_PATH")
          echo "✅ 成功获取配置信息"
          
          BRANCH="${{ github.event.inputs.source_branch }}"
          if [ "$BRANCH" = "auto" ]; then
            BRANCH="$RECOMMENDED_BRANCH"
            echo "🤖 自动选择推荐分支: $BRANCH"
          else
            echo "📋 使用指定分支: $BRANCH"
          fi
          
          echo "SOURCE_URL=$SOURCE_URL" >> $GITHUB_ENV
          echo "SOURCE_BRANCH=$BRANCH" >> $GITHUB_ENV
          echo "SOURCE_PRESET=$PRESET" >> $GITHUB_ENV
          echo "RECOMMENDED_BRANCH=$RECOMMENDED_BRANCH" >> $GITHUB_ENV
          
          echo ""
          echo "✅ 源码配置解析完成"
          echo "📊 配置详情:"
          echo "  - 预设: $PRESET"
          echo "  - 描述: $DESCRIPTION"
          echo "  - 仓库: $SOURCE_URL"
          echo "  - 分支: $BRANCH"
          echo "  - 推荐分支: $RECOMMENDED_BRANCH"

      - name: 📥 智能源码获取与分支处理
        id: clone-source
        run: |
          echo "开始智能源码获取与分支处理..."
          cd ${{ env.SOURCE_DIR }}
          REQUESTED_BRANCH="${{ env.SOURCE_BRANCH }}"
          SOURCE_URL="${{ env.SOURCE_URL }}"
          echo "🎯 请求分支: $REQUESTED_BRANCH"
          echo "🎯 源码仓库: $SOURCE_URL"
          
          # 清理目录
          echo "🧹 清理源码目录..."
          rm -rf .[!.]* * 2>/dev/null || true
          
          # 尝试不同的克隆策略
          CLONE_STRATEGIES=()
          
          # 首先尝试指定分支
          if [ "$REQUESTED_BRANCH" != "auto" ] && [ "$REQUESTED_BRANCH" != "main" ] && [ "$REQUESTED_BRANCH" != "master" ]; then
            CLONE_STRATEGIES+=("指定分支深度克隆: git clone --depth 1 --branch $REQUESTED_BRANCH $SOURCE_URL .")
          fi
          
          # 添加其他策略
          CLONE_STRATEGIES+=("main分支深度克隆: git clone --depth 1 --branch main $SOURCE_URL .")
          CLONE_STRATEGIES+=("master分支深度克隆: git clone --depth 1 --branch master $SOURCE_URL .")
          CLONE_STRATEGIES+=("默认分支深度克隆: git clone --depth 1 $SOURCE_URL .")
          
          # 如果推荐分支存在，优先尝试
          if [ "$REQUESTED_BRANCH" = "auto" ]; then
            RECOMMENDED_BRANCH="${{ env.RECOMMENDED_BRANCH }}"
            if [ -n "$RECOMMENDED_BRANCH" ] && [ "$RECOMMENDED_BRANCH" != "null" ]; then
              CLONE_STRATEGIES=("推荐分支深度克隆: git clone --depth 1 --branch $RECOMMENDED_BRANCH $SOURCE_URL ." "${CLONE_STRATEGIES[@]}")
            fi
          fi
          
          # 添加完整克隆作为备选
          CLONE_STRATEGIES+=("完整克隆: git clone $SOURCE_URL .")
          
          CLONE_SUCCESS=false
          CLONE_ERROR=""
          ACTUAL_BRANCH=""
          
          for strategy in "${CLONE_STRATEGIES[@]}"; do
            strategy_name=$(echo "$strategy" | cut -d: -f1)
            clone_cmd=$(echo "$strategy" | cut -d: -f2-)
            echo ""
            echo "🔄 尝试策略: $strategy_name"
            echo "命令: $clone_cmd"
            
            # 清理目录
            rm -rf .[!.]* * 2>/dev/null || true
            
            if eval $clone_cmd 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/clone.log; then
              if [ -d ".git" ]; then
                ACTUAL_BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
                COMMIT_HASH=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
                echo "✅ 克隆成功: $strategy_name"
                echo "📋 实际分支: $ACTUAL_BRANCH"
                echo "🔗 提交哈希: $COMMIT_HASH"
                
                # 验证关键文件是否存在
                if [ -f "scripts/feeds" ]; then
                  echo "✅ 关键文件 'scripts/feeds' 存在"
                  CLONE_SUCCESS=true
                  break
                else
                  echo "❌ 关键文件 'scripts/feeds' 不存在，继续尝试其他策略..."
                  CLONE_ERROR="关键文件缺失"
                  # 显示目录结构以便调试
                  echo "📁 当前目录结构:"
                  ls -la | head -10
                fi
              else
                CLONE_ERROR="Git目录未创建"
                echo "⚠️ Git目录未创建，继续尝试其他策略..."
              fi
            else
              CLONE_ERROR="克隆命令执行失败"
              echo "❌ 策略失败: $strategy_name"
              if [ -f "${{ env.BUILD_LOG_DIR }}/clone.log" ]; then
                echo "克隆错误详情:"
                tail -20 ${{ env.BUILD_LOG_DIR }}/clone.log
              fi
            fi
          done
          
          if [ "$CLONE_SUCCESS" = "false" ]; then
            echo "❌ 所有克隆策略都失败"
            echo "🔍 最后尝试的克隆日志:"
            cat ${{ env.BUILD_LOG_DIR }}/clone.log 2>/dev/null || echo "无克隆日志"
            echo "错误: $CLONE_ERROR"
            exit 1
          fi
          
          echo "ACTUAL_BRANCH=$ACTUAL_BRANCH" >> $GITHUB_ENV
          echo "COMMIT_HASH=$COMMIT_HASH" >> $GITHUB_ENV
          
          echo ""
          echo "🔍 源码仓库深度验证..."
          echo "📁 源码目录结构:"
          ls -la | head -10
          echo ""
          echo "🔧 验证关键文件:"
          for file in scripts/feeds include/toplevel.mk package/Makefile; do
            if [ -f "$file" ]; then
              echo "✅ $file: 存在"
            else
              echo "❌ $file: 缺失"
            fi
          done
          
          echo "✅ 源码获取与验证完成"

      - name: 💾 源码获取后空间监测
        run: |
          echo "=== 源码获取后空间监测 ==="
          echo "📊 当前磁盘使用情况:"
          df -h
          ROOT_AVAILABLE=$(df / | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          MNT_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "根分区可用空间: ${ROOT_AVAILABLE}GB"
          echo "/mnt 分区可用空间: ${MNT_AVAILABLE}GB"
          if [ "$ROOT_AVAILABLE" -lt 2 ]; then
            echo "🚨 严重警告: 根分区空间不足2GB，可能影响系统稳定性"
          fi
          if [ "$MNT_AVAILABLE" -lt 10 ]; then
            echo "🚨 严重错误: /mnt 分区空间不足10GB，无法编译"
            exit 1
          elif [ "$MNT_AVAILABLE" -lt 20 ]; then
            echo "⚠️ 警告: /mnt 分区空间紧张 (${MNT_AVAILABLE}GB)"
          else
            echo "✅ /mnt 分区空间充足"
          fi

      - name: 🔄 智能源码初始化
        timeout-minutes: 30
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "开始智能源码初始化..."
          START_TIME=$(date +%s)
          
          echo "🔍 验证源码完整性..."
          if [ ! -f "scripts/feeds" ]; then
            echo "❌ 错误: scripts/feeds 文件不存在，源码可能不完整"
            echo "📁 当前目录内容:"
            ls -la
            exit 1
          fi
          
          echo "🔧 Feeds配置检测..."
          FEEDS_CONF_FOUND=""
          for feeds_file in feeds.conf feeds.conf.default .feeds.conf .feeds.conf.default; do
            if [ -f "$feeds_file" ]; then
              FEEDS_CONF_FOUND="$feeds_file"
              echo "📋 使用现有 $feeds_file"
              if [ "$feeds_file" != "feeds.conf" ]; then
                cp "$feeds_file" feeds.conf
              fi
              break
            fi
          done
          
          if [ -z "$FEEDS_CONF_FOUND" ]; then
            echo "⚠️ 未找到feeds配置，创建通用配置"
            cat > feeds.conf << 'EOF'
src-git packages https://git.openwrt.org/feed/packages.git
src-git luci https://git.openwrt.org/feed/luci.git
src-git routing https://git.openwrt.org/feed/routing.git
src-git telephony https://git.openwrt.org/feed/telephony.git
EOF
            echo "✅ 已创建通用 feeds.conf"
          fi
          
          echo "🔄 更新Feeds..."
          for i in 1 2 3; do
            echo "尝试 $i/3"
            if ./scripts/feeds update -a; then
              echo "✅ Feeds更新成功"
              break
            else
              echo "❌ Feeds更新失败，尝试修复..."
              if [ $i -eq 3 ]; then
                echo "❌ Feeds更新彻底失败"
                exit 1
              fi
              sleep 5
            fi
          done
          
          echo "📦 安装基础Feeds..."
          for feed in packages luci routing telephony; do
            if ./scripts/feeds install -a -p $feed; then
              echo "✅ $feed 安装成功"
            else
              echo "⚠️ $feed 安装失败"
            fi
          done
          
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "⏱️ Feeds初始化耗时: ${DURATION}秒"
          echo "✅ 源码初始化完成"

      - name: 🎯 快速配置文件查找与应用
        timeout-minutes: 1
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "快速配置文件查找与应用..."
          CONFIG_PROFILE="${{ github.event.inputs.config_profile }}"
          echo "输入配置模式: $CONFIG_PROFILE"
          
          echo "🔍 快速配置文件搜索..."
          
          # 使用与"智能文件发现"相同的快速搜索策略
          CONFIG_FOUND=""
          
          # 方法1: 直接路径查找（最快）- 在源码目录和配置仓库目录都查找
          echo "🎯 直接路径查找..."
          if [ -f "$CONFIG_PROFILE" ]; then
            CONFIG_FOUND="$CONFIG_PROFILE"
            echo "✅ 在当前目录找到配置文件: $CONFIG_FOUND"
          elif [ -f "../$CONFIG_PROFILE" ]; then
            CONFIG_FOUND="../$CONFIG_PROFILE"
            echo "✅ 在上级目录找到配置文件: $CONFIG_FOUND"
          elif [ -f "$GITHUB_WORKSPACE/$CONFIG_PROFILE" ]; then
            CONFIG_FOUND="$GITHUB_WORKSPACE/$CONFIG_PROFILE"
            echo "✅ 在工作区找到配置文件: $CONFIG_FOUND"
          fi
          
          # 方法2: 受限深度搜索 - 在源码目录和配置仓库目录都搜索
          if [ -z "$CONFIG_FOUND" ]; then
            echo "🔍 受限深度搜索..."
            # 先在源码目录搜索
            CONFIG_FOUND=$(find . -maxdepth 3 -name "$CONFIG_PROFILE" -type f 2>/dev/null | head -1)
            if [ -z "$CONFIG_FOUND" ]; then
              # 在配置仓库目录搜索
              CONFIG_FOUND=$(find $GITHUB_WORKSPACE -maxdepth 3 -name "$CONFIG_PROFILE" -type f 2>/dev/null | head -1)
            fi
            if [ -n "$CONFIG_FOUND" ]; then
              echo "✅ 通过受限搜索找到配置文件: $CONFIG_FOUND"
            fi
          fi
          
          # 方法3: 使用文件发现步骤的结果（如果可用）- 修正路径
          if [ -z "$CONFIG_FOUND" ] && [ -f "${{ env.BUILD_LOG_DIR }}/all_config_files.txt" ]; then
            echo "🔍 使用文件发现缓存..."
            # 从缓存文件中读取路径，并确保路径正确
            CACHED_PATH=$(grep "$CONFIG_PROFILE" "${{ env.BUILD_LOG_DIR }}/all_config_files.txt" | head -1)
            if [ -n "$CACHED_PATH" ]; then
              # 检查路径是否以 ./ 开头，如果是则转换为绝对路径
              if [[ "$CACHED_PATH" == ./* ]]; then
                CONFIG_FOUND="$GITHUB_WORKSPACE/${CACHED_PATH#./}"
              else
                CONFIG_FOUND="$CACHED_PATH"
              fi
              # 验证文件是否存在
              if [ -f "$CONFIG_FOUND" ]; then
                echo "✅ 通过缓存找到配置文件: $CONFIG_FOUND"
              else
                echo "⚠️ 缓存中的文件不存在: $CONFIG_FOUND"
                CONFIG_FOUND=""
              fi
            fi
          fi
          
          # 方法4: 快速模式匹配
          if [ -z "$CONFIG_FOUND" ] && [[ "$CONFIG_PROFILE" == *"*"* ]]; then
            echo "🔍 快速模式匹配..."
            CONFIG_FOUND=$(find . -maxdepth 3 -name "$CONFIG_PROFILE" -type f 2>/dev/null | head -1)
            if [ -z "$CONFIG_FOUND" ]; then
              CONFIG_FOUND=$(find $GITHUB_WORKSPACE -maxdepth 3 -name "$CONFIG_PROFILE" -type f 2>/dev/null | head -1)
            fi
            if [ -n "$CONFIG_FOUND" ]; then
              echo "✅ 通过模式匹配找到配置文件: $CONFIG_FOUND"
            fi
          fi
          
          # 方法5: 显示可用配置并选择第一个
          if [ -z "$CONFIG_FOUND" ]; then
            echo "🔍 显示可用配置文件..."
            AVAILABLE_CONFIGS=$(find . -maxdepth 3 -name "*.config" -o -name ".config_*" -o -name "config_*" 2>/dev/null | head -5)
            if [ -z "$AVAILABLE_CONFIGS" ]; then
              AVAILABLE_CONFIGS=$(find $GITHUB_WORKSPACE -maxdepth 3 -name "*.config" -o -name ".config_*" -o -name "config_*" 2>/dev/null | head -5)
            fi
            if [ -n "$AVAILABLE_CONFIGS" ]; then
              CONFIG_FOUND=$(echo "$AVAILABLE_CONFIGS" | head -1)
              echo "⚠️ 使用第一个找到的配置文件: $CONFIG_FOUND"
              echo "可用配置文件:"
              echo "$AVAILABLE_CONFIGS"
            fi
          fi
          
          if [ -n "$CONFIG_FOUND" ]; then
            echo "📋 复制配置文件: $CONFIG_FOUND -> .config"
            # 确保文件存在
            if [ -f "$CONFIG_FOUND" ]; then
              cp "$CONFIG_FOUND" .config
              echo "🔍 配置文件基本信息:"
              CONFIG_SIZE=$(stat -c%s .config 2>/dev/null || echo "未知")
              echo "  - 文件: $(basename $CONFIG_FOUND)"
              echo "  - 大小: ${CONFIG_SIZE} 字节"
              echo "  - 来源: $CONFIG_FOUND"
              
              # 快速分析配置
              TARGET_ARCH=$(grep "CONFIG_TARGET_ARCH_PACKAGES" .config 2>/dev/null | cut -d= -f2 | tr -d '"' | head -1 || echo "未知")
              echo "  - 架构: $TARGET_ARCH"
              echo "✅ 配置应用完成"
            else
              echo "❌ 错误: 配置文件不存在: $CONFIG_FOUND"
              echo "🔍 验证文件存在性..."
              ls -la "$(dirname "$CONFIG_FOUND")" 2>/dev/null || echo "目录不存在"
              exit 1
            fi
          else
            echo "❌ 错误: 无法找到配置文件 '$CONFIG_PROFILE'"
            echo ""
            echo "🔍 调试信息:"
            echo "当前目录: $(pwd)"
            echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
            echo "快速配置文件列表:"
            find . -maxdepth 2 -name "*.config" -o -name ".config_*" 2>/dev/null | head -10 || echo "当前目录无配置文件"
            find $GITHUB_WORKSPACE -maxdepth 2 -name "*.config" -o -name ".config_*" 2>/dev/null | head -10 || echo "工作区无配置文件"
            exit 1
          fi

      - name: 🔧 设备镜像配置修复
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 设备镜像配置修复 ==="
          
          echo "🔍 检查当前目标设备配置..."
          if [ -f ".config" ]; then
            echo "📋 当前设备相关配置:"
            grep -E "CONFIG_TARGET.*asus_rt-ac42u|CONFIG_TARGET_DEVICE|CONFIG_TARGET_.*_DEVICE.*asus" .config | head -20
          fi
          
          echo "🔧 确保工厂镜像生成启用..."
          # 启用工厂镜像生成
          sed -i 's/# CONFIG_TARGET_IMAGES_PACKAGES is not set/CONFIG_TARGET_IMAGES_PACKAGES=y/' .config 2>/dev/null || true
          
          # 确保设备特定的工厂镜像配置
          if grep -q "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u" .config; then
            echo "🎯 启用 asus_rt-ac42u 设备配置..."
            sed -i 's/# CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u is not set/CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y/' .config
          else
            echo "🔧 添加 asus_rt-ac42u 设备配置..."
            echo "CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y" >> .config
          fi
          
          # 确保工厂镜像格式启用
          echo "🔧 启用工厂镜像格式..."
          sed -i 's/# CONFIG_IMAGEOPT is not set/CONFIG_IMAGEOPT=y/' .config 2>/dev/null || true
          sed -i 's/# CONFIG_COMBINED_IMAGES is not set/CONFIG_COMBINED_IMAGES=y/' .config 2>/dev/null || true
          
          # 添加必要的镜像配置
          echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
          echo "CONFIG_TARGET_ROOTFS_EXT4FS=y" >> .config
          echo "CONFIG_TARGET_KERNEL_PARTSIZE=32" >> .config
          echo "CONFIG_TARGET_ROOTFS_PARTSIZE=512" >> .config
          
          echo "🔄 重新运行配置..."
          make defconfig >/dev/null 2>&1 || echo "配置更新完成"
          
          echo "✅ 设备镜像配置修复完成"

      - name: 🔧 高级性能优化配置
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "应用高级性能优化配置..."
          echo "⚡ 应用基础优化..."
          sed -i 's/CONFIG_DEBUG=y/# CONFIG_DEBUG is not set/' .config 2>/dev/null || true
          sed -i 's/CONFIG_DEVEL=y/# CONFIG_DEVEL is not set/' .config 2>/dev/null || true
          echo "CONFIG_CCACHE=y" >> .config
          
          case "${{ github.event.inputs.build_optimization }}" in
            "speed")
              echo "🚀 应用极速优化配置..."
              echo "CONFIG_DEBUG_INFO=n" >> .config
              ;;
            "stability")
              echo "🛡️ 应用稳定优化配置..."
              echo "CONFIG_SMALL_FLASH=y" >> .config
              ;;
            *)
              echo "⚖️ 应用平衡优化配置..."
              ;;
          esac
          
          echo "🔄 运行配置处理..."
          # 修复Broken pipe错误
          echo "n" | make oldconfig >/dev/null 2>&1 || make defconfig >/dev/null 2>&1 || echo "配置处理完成"
          echo "✅ 性能优化配置完成"

      - name: 📥 全面预下载与依赖验证
        if: github.event.inputs.enable_pre_download == 'true'
        timeout-minutes: 45
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 全面预下载与依赖验证 ==="
          mkdir -p ${{ env.DOWNLOAD_DIR }}
          
          echo "🔍 空间检查 - 预下载前..."
          DOWNLOAD_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "下载前可用空间: ${DOWNLOAD_AVAILABLE}GB"
          if [ "$DOWNLOAD_AVAILABLE" -lt 8 ]; then
            echo "🚨 空间不足: 预下载需要至少8GB空间"
            exit 1
          fi
          
          echo "🔍 分析需要下载的包..."
          echo "📋 生成下载清单..."
          make target/linux/prepare 2>/dev/null || true
          
          echo "📥 开始全面预下载..."
          DOWNLOAD_LOG="${{ env.BUILD_LOG_DIR }}/pre-download.log"
          {
            echo "阶段1: 下载内核源码..."
            make target/linux/download 2>&1
            
            echo "阶段2: 下载工具链..."
            make toolchain/download 2>&1
            
            echo "阶段3: 下载所有包..."
            make package/download 2>&1
            
            echo "阶段4: 验证下载完整性..."
            make target/linux/check 2>&1 || true
            make package/check 2>&1 || true
            
          } 2>&1 | tee "$DOWNLOAD_LOG"
          
          echo "🔍 下载结果验证..."
          echo "📊 下载目录内容:"
          ls -la dl/ 2>/dev/null | head -20
          
          echo "🔎 检查下载错误..."
          if grep -i "error\|failed\|not found" "$DOWNLOAD_LOG"; then
            echo "⚠️ 发现下载错误，但继续编译过程..."
            echo "DOWNLOAD_STATUS=with_errors" >> $GITHUB_ENV
          else
            echo "✅ 所有下载成功完成"
            echo "DOWNLOAD_STATUS=success" >> $GITHUB_ENV
          fi
          
          echo "📦 下载文件统计:"
          find dl/ -type f 2>/dev/null | wc -l
          du -sh dl/ 2>/dev/null || echo "下载目录为空"
          
          echo "🔍 空间检查 - 预下载后..."
          POST_DOWNLOAD_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "下载后可用空间: ${POST_DOWNLOAD_AVAILABLE}GB"
          SPACE_USED=$((DOWNLOAD_AVAILABLE - POST_DOWNLOAD_AVAILABLE))
          echo "下载占用空间: ${SPACE_USED}GB"

      - name: 🔍 预编译环境验证
        if: github.event.inputs.enable_pre_download == 'true'
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 预编译环境验证 ==="
          
          echo "🔧 验证工具链..."
          echo "📋 检查关键工具:"
          for tool in gcc g++ make flex bison ninja; do
            if command -v $tool >/dev/null 2>&1; then
              echo "✅ $tool: 可用"
            else
              echo "❌ $tool: 缺失"
            fi
          done
          
          echo "📦 验证源码完整性..."
          if [ -d "dl" ] && [ "$(ls -A dl/ 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "✅ 源码包已下载"
            echo "📊 下载包数量: $(find dl/ -type f 2>/dev/null | wc -l)"
            echo "📊 下载目录大小: $(du -sh dl/ 2>/dev/null || echo "未知")"
          else
            echo "⚠️ 源码包目录为空或不存在"
          fi
          
          echo "🔗 验证依赖关系..."
          make defconfig >/dev/null 2>&1
          if make -p -q >/dev/null 2>&1; then
            echo "✅ 依赖关系验证通过"
          else
            echo "⚠️ 依赖关系可能有冲突"
          fi
          
          echo "💾 最终空间检查..."
          FINAL_AVAILABLE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "编译前可用空间: ${FINAL_AVAILABLE}GB"
          if [ "$FINAL_AVAILABLE" -lt 5 ]; then
            echo "🚨 严重警告: 编译前可用空间不足5GB"
            echo "💡 建议清理或增加空间"
          elif [ "$FINAL_AVAILABLE" -lt 10 ]; then
            echo "⚠️ 警告: 编译前可用空间紧张"
          else
            echo "✅ 编译前空间充足"
          fi

      - name: 🛠️ Samba专用修复与编译
        if: github.event.inputs.enable_custom_features == 'true'
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== Samba专用修复与编译 ==="
          
          echo "🔧 智能检测Samba依赖库路径..."
          # 检测实际的依赖库路径
          echo "🔍 搜索talloc相关目录..."
          find . -name "*talloc*" -type d 2>/dev/null | grep -E "(package|feeds)" | head -10
          
          echo "🔍 搜索tdb相关目录..."
          find . -name "*tdb*" -type d 2>/dev/null | grep -E "(package|feeds)" | head -10
          
          echo "🔍 搜索tevent相关目录..."
          find . -name "*tevent*" -type d 2>/dev/null | grep -E "(package|feeds)" | head -10
          
          echo "🔍 搜索ldb相关目录..."
          find . -name "*ldb*" -type d 2>/dev/null | grep -E "(package|feeds)" | head -10
          
          echo "🔄 更新并安装Samba相关feeds..."
          ./scripts/feeds update packages 2>/dev/null || true
          ./scripts/feeds install libtalloc 2>/dev/null || echo "⚠️ libtalloc安装失败"
          ./scripts/feeds install libtdb 2>/dev/null || echo "⚠️ libtdb安装失败" 
          ./scripts/feeds install libtevent 2>/dev/null || echo "⚠️ libtevent安装失败"
          ./scripts/feeds install libldb 2>/dev/null || echo "⚠️ libldb安装失败"
          
          echo "📦 使用稳健的Samba依赖库编译方法..."
          # 先尝试编译基础包，确保环境正常
          echo "🔧 先编译一些基础包测试环境..."
          make package/libs/toolchain/compile -j1 V=s 2>/dev/null || echo "⚠️ 工具链编译测试失败"
          
          # 使用更智能的依赖库编译方法
          SAMBA_DEPS=("talloc" "tdb" "tevent" "ldb")
          SAMBA_SUCCESS=true
          
          for dep in "${SAMBA_DEPS[@]}"; do
            echo "编译 $dep..."
            
            # 方法1: 尝试标准路径
            if make package/$dep/compile -j1 V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/samba-$dep.log; then
              echo "✅ $dep 编译成功 (标准路径)"
              continue
            fi
            
            # 方法2: 尝试feeds路径
            if make package/feeds/packages/$dep/compile -j1 V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/samba-$dep-feeds.log; then
              echo "✅ $dep 编译成功 (feeds路径)"
              continue
            fi
            
            # 方法3: 尝试libs路径
            if make package/libs/$dep/compile -j1 V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/samba-$dep-libs.log; then
              echo "✅ $dep 编译成功 (libs路径)"
              continue
            fi
            
            # 方法4: 最后尝试，不退出编译
            echo "❌ $dep 所有编译尝试都失败，但继续流程..."
            SAMBA_SUCCESS=false
          done
          
          if [ "$SAMBA_SUCCESS" = "false" ]; then
            echo "⚠️ 部分Samba依赖库编译失败，考虑禁用Samba"
            echo "💡 建议: 如果Samba非必需，可以在配置中禁用"
            # 不自动禁用，让用户决定
          else
            echo "✅ 所有Samba依赖库编译完成"
          fi
          
          echo "🔧 优化编译环境..."
          export CFLAGS="$CFLAGS -Os -pipe -fno-caller-saves"
          export CXXFLAGS="$CXXFLAGS -Os -pipe -fno-caller-saves"
          
          echo "✅ Samba修复完成"

      - name: 🔧 综合问题修复
        if: github.event.inputs.fix_common_issues == 'true'
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 执行综合问题修复 ==="
          
          echo "🔧 深度目录修复与权限设置..."
          echo "创建目标根文件系统必要目录..."
          
          # 方法1: 使用find创建所有目标根目录
          find build_dir -name "root.orig-*" -type d 2>/dev/null | while read root_dir; do
            echo "修复目录: $root_dir"
            mkdir -p "$root_dir/tmp"
            mkdir -p "$root_dir/var/lock"
            mkdir -p "$root_dir/var/run"
            mkdir -p "$root_dir/usr/lib/opkg"
            mkdir -p "$root_dir/var/lib/opkg"
            chmod 755 "$root_dir/tmp"
            chmod 755 "$root_dir/var"
            echo "✅ 已修复: $root_dir"
          done
          
          # 方法2: 修复已知的特定目标目录
          echo "🔧 修复已知目标目录结构..."
          KNOWN_ROOTS=(
            "build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/root.orig-ipq40xx"
            "staging_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/root.orig-ipq40xx"
            "build_dir/target-arm_cortex-a7+neon-vfpv4_musl_eabi/root-ipq40xx"
          )
          
          for known_root in "${KNOWN_ROOTS[@]}"; do
            if [ -d "$known_root" ]; then
              echo "🔧 修复已知目录: $known_root"
              mkdir -p "$known_root/tmp"
              mkdir -p "$known_root/var/lock"
              mkdir -p "$known_root/var/run"
              mkdir -p "$known_root/usr/lib/opkg"
              mkdir -p "$known_root/var/lib/opkg"
              chmod 755 "$known_root/tmp"
              echo "✅ 已修复: $known_root"
            else
              echo "ℹ️ 目录不存在，创建: $known_root"
              mkdir -p "$known_root/tmp" 2>/dev/null || true
            fi
          done
          
          # 方法3: 创建通用目标目录结构
          echo "🔧 创建通用目标目录结构..."
          TARGET_PATTERN="target-*"
          for target_dir in $TARGET_PATTERN; do
            if [ -d "$target_dir" ]; then
              find "$target_dir" -name "root*" -type d 2>/dev/null | while read root_dir; do
                mkdir -p "$root_dir/tmp"
                mkdir -p "$root_dir/var/lock" 
                mkdir -p "$root_dir/var/run"
                chmod 755 "$root_dir/tmp"
              done
            fi
          done
          
          echo "🔧 修复工厂镜像配置..."
          if [ -f ".config" ]; then
            # 确保工厂镜像相关配置启用
            echo "🎯 启用工厂镜像生成配置..."
            sed -i 's/# CONFIG_TARGET_IMAGES_PACKAGES is not set/CONFIG_TARGET_IMAGES_PACKAGES=y/' .config 2>/dev/null || true
            sed -i 's/# CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u is not set/CONFIG_TARGET_ipq40xx_generic_DEVICE_asus_rt-ac42u=y/' .config 2>/dev/null || true
            sed -i 's/# CONFIG_IMAGEOPT is not set/CONFIG_IMAGEOPT=y/' .config 2>/dev/null || true
            sed -i 's/# CONFIG_COMBINED_IMAGES is not set/CONFIG_COMBINED_IMAGES=y/' .config 2>/dev/null || true
            
            # 确保内核配置正确
            echo "CONFIG_TARGET_ROOTFS_SQUASHFS=y" >> .config
            echo "CONFIG_TARGET_ROOTFS_EXT4FS=y" >> .config
            echo "CONFIG_TARGET_ROOTFS_INCLUDE_USB=y" >> .config
            
            echo "✅ 工厂镜像配置已修复"
            make defconfig >/dev/null 2>&1 || echo "配置更新完成"
          fi
          
          echo "🔧 检查问题包处理..."
          # 如果samba持续失败，提供禁用选项
          if grep -q "CONFIG_PACKAGE_samba4-server=y" .config 2>/dev/null; then
            echo "⚠️ samba包已启用，如持续失败可考虑禁用"
            echo "💡 如需禁用samba，取消注释以下行:"
            echo "# sed -i 's/CONFIG_PACKAGE_samba4-server=y/# CONFIG_PACKAGE_samba4-server is not set/' .config"
            echo "# sed -i 's/CONFIG_PACKAGE_luci-app-samba4=y/# CONFIG_PACKAGE_luci-app-samba4 is not set/' .config"
            
            # 根据用户选择决定是否禁用samba
            if [ "${{ github.event.inputs.fix_common_issues }}" = "true" ]; then
              echo "🔧 根据配置自动禁用可能有问题的samba包..."
              sed -i 's/CONFIG_PACKAGE_samba4-server=y/# CONFIG_PACKAGE_samba4-server is not set/' .config 2>/dev/null || true
              sed -i 's/CONFIG_PACKAGE_luci-app-samba4=y/# CONFIG_PACKAGE_luci-app-samba4 is not set/' .config 2>/dev/null || true
              echo "✅ 已自动禁用samba相关包"
            fi
          fi
          
          echo "🔧 修复符号链接..."
          # 检查并修复可能的符号链接问题
          if [ -L "tmp" ] && [ ! -e "tmp" ]; then
            echo "🔧 修复损坏的tmp符号链接..."
            rm -f tmp
            mkdir -p tmp
            echo "✅ tmp符号链接已修复"
          fi
          
          echo "✅ 综合问题修复完成"

      - name: 🛠️ 全面工具链编译与验证
        timeout-minutes: 90
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "开始全面工具链编译..."
          START_TIME=$(date +%s)
          mkdir -p ${{ env.TOOLCHAIN_LOG_DIR }}
          
          echo "🔧 编译Host工具..."
          if ! make tools/compile -j$(($(nproc) - 1)) V=sc 2>&1 | tee ${{ env.TOOLCHAIN_LOG_DIR }}/host-tools.log; then
            echo "❌ Host工具编译失败，尝试单线程..."
            if ! make tools/compile -j1 V=s 2>&1 | tee ${{ env.TOOLCHAIN_LOG_DIR }}/host-tools-single.log; then
              echo "❌ Host工具编译彻底失败"
              exit 1
            fi
          fi
          
          echo "🔧 编译工具链..."
          if ! make toolchain/compile -j$(($(nproc) - 1)) V=sc 2>&1 | tee ${{ env.TOOLCHAIN_LOG_DIR }}/toolchain-compile.log; then
            echo "❌ 工具链编译失败，尝试单线程..."
            if ! make toolchain/compile -j1 V=s 2>&1 | tee ${{ env.TOOLCHAIN_LOG_DIR }}/toolchain-compile-single.log; then
              echo "❌ 工具链编译彻底失败"
              exit 1
            fi
          fi
          
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "⏱️ 工具链编译耗时: ${DURATION}秒"
          echo "✅ 工具链编译完成"

      - name: 🔍 深度工具链验证
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 深度工具链验证 ==="
          echo "🔧 关键工具验证:"
          for tool in m4 flex bison; do
            tool_path=$(find staging_dir/host/bin -name "$tool" -type f 2>/dev/null | head -1)
            if [ -n "$tool_path" ] && [ -x "$tool_path" ]; then
              echo "✅ $tool: 可用"
            else
              echo "❌ $tool: 缺失"
              exit 1
            fi
          done
          
          echo "🎯 目标工具链验证:"
          TARGET_GCC=$(find staging_dir/toolchain-*/bin/ -name "*gcc" -type f 2>/dev/null | head -1)
          if [ -n "$TARGET_GCC" ] && [ -x "$TARGET_GCC" ]; then
            echo "✅ 目标GCC: 可用"
          else
            echo "❌ 目标GCC: 缺失"
            exit 1
          fi
          echo "✅ 深度工具链验证完成"

      - name: 🏗️ 智能编译固件（分阶段优化）
        timeout-minutes: 240
        id: compile-firmware
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "开始智能编译固件（分阶段优化）..."
          export FORCE_UNSAFE_CONFIGURE=1
          export TERM=linux
          export CCACHE_DIR="${{ env.CCACHE_DIR }}"
          BUILD_JOBS=${BUILD_JOBS:-$(( $(nproc) - 1 ))}
          SAMBA_JOBS=${SAMBA_JOBS:-1}
          mkdir -p ${{ env.BUILD_LOG_DIR }}
          START_TIME=$(date +%s)
          
          echo "🔍 编译前最终空间检查..."
          COMPILE_START_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "编译开始前可用空间: ${COMPILE_START_SPACE}GB"
          if [ "$COMPILE_START_SPACE" -lt 3 ]; then
            echo "🚨 严重错误: 编译开始前空间不足3GB"
            exit 1
          fi
          
          echo "📊 编译参数汇总:"
          echo "  - 源码库: ${{ env.SOURCE_PRESET }}"
          echo "  - 实际分支: ${{ env.ACTUAL_BRANCH }}"
          echo "  - 优化策略: ${{ github.event.inputs.build_optimization }}"
          echo "  - 工具链策略: ${{ github.event.inputs.toolchain_strategy }}"
          echo "  - 自定义功能: ${{ github.event.inputs.enable_custom_features }}"
          echo "  - 问题修复: ${{ github.event.inputs.fix_common_issues }}"
          echo "  - 预下载: ${{ github.event.inputs.enable_pre_download }}"
          echo "  - 后验证: ${{ github.event.inputs.enable_post_verify }}"
          echo "  - CPU核心: $(nproc)"
          echo "  - 编译任务数: $BUILD_JOBS"
          echo "  - Samba任务数: $SAMBA_JOBS"
          echo "  - CCache: 已启用"
          echo "  - 起始空间: ${COMPILE_START_SPACE}GB"
          
          echo "🔧 开始编译..."
          LOG_FILE="${{ env.BUILD_LOG_DIR }}/firmware-compile.log"
          
          # 使用更稳健的编译方法
          {
            echo "阶段1: 基础环境准备..."
            make tools/install 2>/dev/null || echo "⚠️ 工具安装警告"
            make toolchain/install 2>/dev/null || echo "⚠️ 工具链安装警告"
            
            echo "阶段2: 内核编译..."
            make target/linux/compile -j$BUILD_JOBS V=s || {
              echo "⚠️ 内核编译遇到问题，继续..."
            }
            
            echo "阶段3: 包编译（分批次）..."
            # 先编译基础包
            echo "🔧 编译基础网络包..."
            make package/network/utils/compile -j$BUILD_JOBS V=s || echo "⚠️ 网络工具编译问题"
            
            echo "🔧 编译基础系统包..."
            make package/system/compile -j$BUILD_JOBS V=s || echo "⚠️ 系统包编译问题"
            
            echo "🔧 编译LuCI相关包..."
            make package/feeds/luci/compile -j$BUILD_JOBS V=s || echo "⚠️ LuCI编译问题"
            
            # Samba相关包单独处理
            if [ "${{ github.event.inputs.enable_custom_features }}" = "true" ]; then
              echo "阶段4: Samba相关包编译..."
              for pkg in samba4-libs samba4-server luci-app-samba4; do
                echo "编译 $pkg..."
                if make package/$pkg/compile -j$SAMBA_JOBS V=s 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/$pkg-compile.log; then
                  echo "✅ $pkg 编译成功"
                else
                  echo "⚠️ $pkg 编译失败，尝试继续..."
                  make package/$pkg/compile -j$SAMBA_JOBS V=sc 2>&1 | tee ${{ env.BUILD_LOG_DIR }}/$pkg-fix.log || echo "❌ $pkg 彻底失败"
                fi
              done
            fi
            
            echo "阶段5: 剩余包编译..."
            make package/compile -j$BUILD_JOBS V=sc || {
              echo "⚠️ 部分包编译失败，继续安装阶段..."
            }
            
            echo "阶段6: 包安装..."
            make package/install -j1 V=s || {
              echo "❌ 包安装失败，尝试修复方法..."
              # 创建缺失的目录
              mkdir -p build_dir/target-*/root-*/tmp
              mkdir -p build_dir/target-*/root-*/var/lock
              mkdir -p build_dir/target-*/root-*/var/run
              # 再次尝试
              make package/install -j1 V=sc || echo "⚠️ 包安装仍然失败，继续目标安装"
            }
            
            echo "阶段7: 目标安装..."
            make target/install -j1 V=s || {
              echo "❌ 目标安装失败，尝试直接生成镜像..."
              make -j1 V=sc || make image -j1 V=sc
            }
            
            echo "阶段8: 生成镜像..."
            make target/linux/ipq40xx/image -j1 V=s || {
              echo "⚠️ 专门镜像生成失败，使用默认目标..."
              make -j1 V=sc
            }
            
          } 2>&1 | tee "$LOG_FILE"
          
          COMPILE_EXIT_CODE=${PIPESTATUS[0]}
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "BUILD_DURATION=$DURATION" >> $GITHUB_ENV
          
          echo "🔍 编译后空间检查..."
          COMPILE_END_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "编译结束后可用空间: ${COMPILE_END_SPACE}GB"
          SPACE_USED=$((COMPILE_START_SPACE - COMPILE_END_SPACE))
          echo "编译过程占用空间: ${SPACE_USED}GB"
          
          # 检查是否生成了固件文件，即使编译过程有错误
          if find bin -name "*.bin" -o -name "*.img" 2>/dev/null | grep -q .; then
            echo "BUILD_STATUS=success" >> $GITHUB_ENV
            echo "🎉 编译成功完成（有固件生成）!"
          elif [ $COMPILE_EXIT_CODE -eq 0 ]; then
            echo "BUILD_STATUS=success" >> $GITHUB_ENV
            echo "🎉 编译成功完成!"
          else
            echo "BUILD_STATUS=failed" >> $GITHUB_ENV
            echo "❌ 编译失败，退出码: $COMPILE_EXIT_CODE"
            exit 1
          fi
          
          echo "⏱️ 总编译耗时: ${DURATION}秒 ($(($DURATION/60))分钟)"

      - name: 🔍 编译后全面验证
        if: env.BUILD_STATUS == 'success' && github.event.inputs.enable_post_verify == 'true'
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 编译后全面验证 ==="
          
          echo "🔍 固件文件验证..."
          if [ -d "bin/targets" ]; then
            echo "✅ 固件输出目录存在"
            echo "📊 生成的固件文件:"
            find bin/targets -name "*.bin" -o -name "*.img" 2>/dev/null | while read file; do
              if [ -f "$file" ]; then
                size=$(stat -c%s "$file" 2>/dev/null || echo 0)
                echo "  - $(basename "$file") ($(($size/1024/1024))MB)"
              fi
            done
            
            # 检查特定设备镜像
            echo "🔍 检查ASUS RT-AC42U镜像..."
            ASUS_IMAGES=$(find bin/targets -name "*asus_rt-ac42u*" -type f 2>/dev/null)
            if [ -n "$ASUS_IMAGES" ]; then
              echo "✅ ASUS RT-AC42U镜像已生成:"
              for img in $ASUS_IMAGES; do
                echo "  - $(basename "$img")"
              done
            else
              echo "⚠️ 未找到ASUS RT-AC42U特定镜像"
            fi
            
            # 检查镜像类型
            echo "🔍 检查镜像类型完整性..."
            FACTORY_COUNT=$(find bin/targets -name "*factory*" -type f 2>/dev/null | wc -l)
            UPGRADE_COUNT=$(find bin/targets -name "*sysupgrade*" -type f 2>/dev/null | wc -l)
            echo "  - 工厂镜像: $FACTORY_COUNT 个"
            echo "  - 升级镜像: $UPGRADE_COUNT 个"
            
          else
            echo "❌ 固件输出目录不存在"
          fi
          
          echo "🔍 Samba功能验证..."
          if find bin -name "*samba4*" -type f | grep -q .; then
            echo "✅ Samba相关包已生成"
          else
            echo "⚠️ 未找到Samba相关包"
          fi
          
          echo "🔍 关键包验证..."
          for pkg in base-files luci firewall; do
            if find bin -name "*$pkg*" -type f | grep -q .; then
              echo "✅ $pkg 相关包已生成"
            else
              echo "⚠️ 未找到 $pkg 相关包"
            fi
          done
          
          echo "📊 最终空间状态..."
          FINAL_SPACE=$(df /mnt | awk 'NR==2 {gsub("G","",$4); print int($4)}')
          echo "最终可用空间: ${FINAL_SPACE}GB"
          
          echo "✅ 编译后验证完成"

      - name: 🔍 详细固件产物验证与收集
        if: env.BUILD_STATUS == 'success'
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 详细固件产物验证与收集 ==="
          mkdir -p ${{ env.ARTIFACTS_DIR }}/firmware
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs
          mkdir -p ${{ env.ARTIFACTS_DIR }}/configs
          
          echo "🔍 搜索固件文件..."
          TOTAL_FIRMWARE_COUNT=0
          
          # 详细搜索固件文件
          if [ -d "bin/targets" ]; then
            echo "📁 复制标准输出目录..."
            cp -r bin/targets ${{ env.ARTIFACTS_DIR }}/firmware/
            
            # 统计各种类型的固件
            INITRAMFS_COUNT=$(find bin/targets -name "*initramfs*" -type f 2>/dev/null | wc -l)
            UPGRADE_COUNT=$(find bin/targets -name "*sysupgrade*" -type f 2>/dev/null | wc -l)
            FACTORY_COUNT=$(find bin/targets -name "*factory*" -type f 2>/dev/null | wc -l)
            OTHER_COUNT=$(find bin/targets -name "*.bin" -o -name "*.img" -o -name "*.trx" -o -name "*.itb" 2>/dev/null | grep -v -e "initramfs" -e "sysupgrade" -e "factory" | wc -l)
            
            TOTAL_FIRMWARE_COUNT=$((INITRAMFS_COUNT + UPGRADE_COUNT + FACTORY_COUNT + OTHER_COUNT))
            
            echo "📊 固件类型统计:"
            echo "  - Initramfs 镜像: $INITRAMFS_COUNT 个"
            echo "  - 系统升级镜像: $UPGRADE_COUNT 个"
            echo "  - 工厂刷机镜像: $FACTORY_COUNT 个"
            echo "  - 其他镜像: $OTHER_COUNT 个"
            echo "  - 总计: $TOTAL_FIRMWARE_COUNT 个文件"
            
            # 显示找到的固件文件
            echo "📋 固件文件详细列表:"
            find bin/targets -name "*.bin" -o -name "*.img" -o -name "*.trx" -o -name "*.itb" 2>/dev/null | head -30 | while read file; do
              if [ -f "$file" ]; then
                file_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
                file_type="其他"
                if [[ "$file" == *"initramfs"* ]]; then
                  file_type="Initramfs"
                elif [[ "$file" == *"sysupgrade"* ]]; then
                  file_type="系统升级"
                elif [[ "$file" == *"factory"* ]]; then
                  file_type="工厂刷机"
                fi
                echo "  - $file_type: $(basename "$file") ($(($file_size/1024/1024))MB)"
              fi
            done
            
            # 检查特定设备的工厂镜像
            echo ""
            echo "🔍 检查 ASUS RT-AC42U 特定镜像..."
            ASUS_IMAGES=$(find bin/targets -name "*asus_rt-ac42u*" -type f 2>/dev/null)
            if [ -n "$ASUS_IMAGES" ]; then
              echo "📋 ASUS RT-AC42U 镜像列表:"
              for img in $ASUS_IMAGES; do
                if [ -f "$img" ]; then
                  img_size=$(stat -c%s "$img" 2>/dev/null || echo 0)
                  img_type="未知"
                  if [[ "$img" == *"initramfs"* ]]; then
                    img_type="RAM启动镜像"
                  elif [[ "$img" == *"sysupgrade"* ]]; then
                    img_type="系统升级镜像"
                  elif [[ "$img" == *"factory"* ]]; then
                    img_type="工厂刷机镜像"
                  fi
                  echo "  - $img_type: $(basename "$img") ($(($img_size/1024/1024))MB)"
                fi
              done
              
              # 检查是否缺少工厂镜像
              ASUS_FACTORY=$(find bin/targets -name "*asus_rt-ac42u*factory*" -type f 2>/dev/null)
              if [ -z "$ASUS_FACTORY" ]; then
                echo "⚠️ 警告: 未找到 ASUS RT-AC42U 工厂刷机镜像"
                echo "FACTORY_MISSING=true" >> $GITHUB_ENV
              else
                echo "✅ 已找到 ASUS RT-AC42U 工厂刷机镜像"
                echo "FACTORY_MISSING=false" >> $GITHUB_ENV
              fi
            else
              echo "❌ 错误: 未找到任何 ASUS RT-AC42U 镜像"
              echo "FACTORY_MISSING=true" >> $GITHUB_ENV
            fi
            
          else
            echo "⚠️ 标准输出目录 bin/targets 不存在"
            echo "FACTORY_MISSING=true" >> $GITHUB_ENV
          fi
          
          # 在其他位置搜索
          echo "🔍 在其他位置搜索固件..."
          OTHER_FIRMWARE=$(find . -maxdepth 4 -name "*.bin" -o -name "*.img" -o -name "*.trx" -o -name "*.gz" 2>/dev/null | grep -v "bin/targets" | head -20)
          if [ -n "$OTHER_FIRMWARE" ]; then
            OTHER_COUNT=$(echo "$OTHER_FIRMWARE" | wc -l)
            echo "✅ 在其他位置找到 $OTHER_COUNT 个固件相关文件"
            for file in $OTHER_FIRMWARE; do
              if [ -f "$file" ]; then
                file_size=$(stat -c%s "$file" 2>/dev/null || echo 0)
                if [ "$file_size" -gt 1000000 ]; then
                  rel_path=$(echo "$file" | sed 's|^\./||')
                  target_dir="${{ env.ARTIFACTS_DIR }}/firmware/other/$(dirname "$rel_path")"
                  mkdir -p "$target_dir"
                  cp "$file" "$target_dir/"
                  echo "📦 已收集: $rel_path ($(($file_size/1024/1024))MB)"
                  TOTAL_FIRMWARE_COUNT=$((TOTAL_FIRMWARE_COUNT + 1))
                fi
              fi
            done
          fi
          
          # 即使没有标准输出，也检查其他常见位置
          if [ $TOTAL_FIRMWARE_COUNT -eq 0 ]; then
            echo "🔍 深度搜索固件文件..."
            # 搜索build_dir中的固件
            BUILD_FIRMWARE=$(find build_dir -name "*.bin" -o -name "*.img" -o -name "*.trx" 2>/dev/null | head -10)
            if [ -n "$BUILD_FIRMWARE" ]; then
              echo "✅ 在build_dir中找到固件相关文件:"
              echo "$BUILD_FIRMWARE"
            fi
          fi
          
          echo "📋 收集构建信息和日志..."
          # 收集配置文件
          cp .config ${{ env.ARTIFACTS_DIR }}/configs/ 2>/dev/null || echo "⚠️ 无法复制.config"
          cp feeds.conf ${{ env.ARTIFACTS_DIR }}/configs/ 2>/dev/null || echo "⚠️ 无法复制feeds.conf"
          
          echo "FIRMWARE_COUNT=$TOTAL_FIRMWARE_COUNT" >> $GITHUB_ENV
          
          if [ $TOTAL_FIRMWARE_COUNT -eq 0 ]; then
            echo "❌ 错误: 未找到任何固件文件"
            echo "当前目录结构:"
            find . -maxdepth 3 -type d | head -20
            echo ""
            echo "所有可能的固件文件:"
            find . -name "*.bin" -o -name "*.img" -o -name "*.trx" -o -name "*.gz" 2>/dev/null | head -30 || echo "无固件文件"
            exit 1
          else
            echo "✅ 固件验证与收集完成: 总共 $TOTAL_FIRMWARE_COUNT 个文件"
          fi

      - name: 💾 优化日志收集与结构
        if: always()
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 优化日志收集与结构 ==="
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs
          
          # 创建清晰的目录结构
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs/完整日志-英文
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs/GitHub过程日志
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs/问题摘要
          mkdir -p ${{ env.ARTIFACTS_DIR }}/logs/编译详细日志
          
          echo "📁 整理原始英文日志..."
          # 复制原始英文日志到专门目录
          if [ -d "${{ env.BUILD_LOG_DIR }}" ]; then
            cp -r ${{ env.BUILD_LOG_DIR }}/* ${{ env.ARTIFACTS_DIR }}/logs/完整日志-英文/ 2>/dev/null || true
          fi
          if [ -d "${{ env.TOOLCHAIN_LOG_DIR }}" ]; then
            cp -r ${{ env.TOOLCHAIN_LOG_DIR }}/* ${{ env.ARTIFACTS_DIR }}/logs/完整日志-英文/ 2>/dev/null || true
          fi
          
          echo "📁 收集并重命名GitHub过程日志..."
          # 为关键日志文件创建中文名称副本
          LOG_MAPPING=(
            "clone.log:检出配置仓库.txt"
            "firmware-compile.log:智能编译固件.txt"
            "target-install.log:目标安装阶段.txt"
            "image-generation.log:镜像生成过程.txt"
            "host-tools.log:主机工具编译.txt"
            "toolchain-compile.log:工具链编译.txt"
            "samba-talloc.log:Samba-talloc库编译.txt"
            "samba-tdb.log:Samba-tdb库编译.txt"
            "samba-tevent.log:Samba-tevent库编译.txt"
            "samba-ldb.log:Samba-ldb库编译.txt"
            "samba4-libs-compile.log:Samba4库编译.txt"
            "samba4-server-compile.log:Samba4服务器编译.txt"
            "pre-download.log:预下载过程.txt"
          )
          
          for mapping in "${LOG_MAPPING[@]}"; do
            orig_file=$(echo "$mapping" | cut -d: -f1)
            chinese_name=$(echo "$mapping" | cut -d: -f2)
            if [ -f "${{ env.BUILD_LOG_DIR }}/$orig_file" ]; then
              cp "${{ env.BUILD_LOG_DIR }}/$orig_file" "${{ env.ARTIFACTS_DIR }}/logs/GitHub过程日志/$chinese_name"
              echo "✅ 已复制: $orig_file → $chinese_name"
            fi
          done
          
          # 创建步骤名称映射文件
          echo "创建步骤日志映射..."
          {
            echo "# GitHub Actions 步骤日志中文映射"
            echo "检出配置仓库.txt - 📥 检出配置仓库"
            echo "智能系统资源分析.txt - 💾 智能系统资源分析" 
            echo "全面工作环境设置.txt - 🔧 全面工作环境设置"
            echo "智能文件发现与配置分析.txt - 🔍 智能文件发现与配置分析"
            echo "智能源码配置解析.txt - 🔧 智能源码配置解析"
            echo "全面编译依赖安装与验证.txt - 🛠️ 全面编译依赖安装与验证"
            echo "高级缓存与性能优化.txt - ⚡ 高级缓存与性能优化"
            echo "智能源码获取与分支处理.txt - 📥 智能源码获取与分支处理"
            echo "源码获取后空间监测.txt - 💾 源码获取后空间监测"
            echo "智能源码初始化.txt - 🔄 智能源码初始化"
            echo "快速配置文件查找与应用.txt - 🎯 快速配置文件查找与应用"
            echo "设备镜像配置修复.txt - 🔧 设备镜像配置修复"
            echo "高级性能优化配置.txt - 🔧 高级性能优化配置"
            echo "预下载过程.txt - 📥 全面预下载与依赖验证"
            echo "预编译环境验证.txt - 🔍 预编译环境验证"
            echo "Samba专用修复与编译.txt - 🛠️ Samba专用修复与编译"
            echo "综合问题修复.txt - 🔧 综合问题修复"
            echo "全面工具链编译与验证.txt - 🛠️ 全面工具链编译与验证"
            echo "深度工具链验证.txt - 🔍 深度工具链验证"
            echo "智能编译固件.txt - 🏗️ 智能编译固件"
            echo "编译后全面验证.txt - 🔍 编译后全面验证"
            echo "详细固件产物验证与收集.txt - 🔍 详细固件产物验证与收集"
            echo "优化日志收集与结构.txt - 💾 优化日志收集与结构"
            echo "完善深度错误分析与解决方案.txt - 🔍 完善深度错误分析与解决方案"
            echo "生成详细构建报告.txt - 📊 生成详细构建报告"
            echo "上传构建产物.txt - 💾 上传构建产物"
            echo "编译后智能清理.txt - 🧹 编译后智能清理"
            echo "最终综合报告.txt - 📊 最终综合报告"
          } > "${{ env.ARTIFACTS_DIR }}/logs/GitHub过程日志/步骤日志映射说明.txt"
          
          echo "📁 收集问题摘要..."
          if [ -f "${{ env.BUILD_LOG_DIR }}/firmware-errors.log" ]; then
            cp "${{ env.BUILD_LOG_DIR }}/firmware-errors.log" "${{ env.ARTIFACTS_DIR }}/logs/问题摘要/编译错误摘要.txt"
          fi
          
          echo "✅ 日志结构优化完成"

      - name: 🔍 完善深度错误分析与解决方案
        if: always()
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "=== 完善深度错误分析与解决方案 ==="
          ANALYSIS_FILE="${{ env.ARTIFACTS_DIR }}/深度错误分析与解决方案报告.txt"
          
          {
            echo "=== 深度错误分析与解决方案报告 ==="
            echo "分析时间: $(date)"
            echo "构建状态: ${{ env.BUILD_STATUS || 'unknown' }}"
            echo "固件数量: ${{ env.FIRMWARE_COUNT || 0 }}"
            echo "工厂镜像状态: ${{ env.FACTORY_MISSING == 'true' && '缺失' || '已生成' }}"
            echo "预下载状态: ${{ env.DOWNLOAD_STATUS || '未执行' }}"
            echo ""
            
            echo "🎯 核心问题总结"
            echo "=================="
            echo "✅ 已修复问题: 源码获取完整性验证"
            echo "✅ 已修复问题: 预下载与依赖验证"
            echo "✅ 已修复问题: Samba依赖库路径检测"
            echo "⚠️ 需要注意: 编译过程中空间管理"
            echo "⚠️ 需要注意: 包依赖关系冲突"
            echo ""
            
            echo "🔍 详细问题分析与解决方案"
            echo "=========================="
            echo ""
            
            echo "1. 源码获取完整性验证"
            echo "---------------------"
            echo "✅ 已修复: 增加关键文件验证 (scripts/feeds)"
            echo "✅ 已修复: 多重克隆策略确保源码完整"
            echo "✅ 已修复: 详细的目录结构验证"
            echo ""
            
            echo "2. 预下载与依赖验证"
            echo "------------------"
            echo "✅ 已实现: 全面预下载所有依赖包"
            echo "✅ 已实现: 下载完整性检查"
            echo "✅ 已实现: 空间使用监控"
            echo ""
            
            echo "3. Samba依赖库路径检测"
            echo "----------------------"
            echo "✅ 已修复: 智能路径检测机制"
            echo "✅ 已修复: 多重编译尝试策略"
            echo "✅ 已修复: 非中断式错误处理"
            echo ""
            
            echo "📊 编译质量评估"
            echo "=============="
            echo "✅ 成功方面:"
            echo "   - 源码获取完整性验证"
            echo "   - 预下载依赖管理"
            echo "   - 多重错误恢复机制"
            echo ""
            echo "⚠️ 需要注意:"
            echo "   - 编译过程中内存使用"
            echo "   - 磁盘空间管理"
            echo "   - 网络稳定性"
            echo ""
            
            echo "🚀 下一步行动建议"
            echo "================"
            echo "1. 📊 监控编译过程资源使用"
            echo "2. 🔧 持续优化错误恢复机制"
            echo "3. 📈 收集更多编译统计信息"
            echo "4. 🧪 测试不同源码分支的兼容性"
            
          } > "$ANALYSIS_FILE"
          
          echo "✅ 完善深度错误分析完成"

      - name: 📊 生成详细构建报告
        if: always()
        run: |
          cd ${{ env.SOURCE_DIR }}
          echo "生成详细构建报告..."
          REPORT_FILE="${{ env.ARTIFACTS_DIR }}/详细构建报告.txt"
          
          {
            echo "=== 详细固件构建报告 ==="
            echo "构建时间: $(date)"
            echo "构建状态: ${{ env.BUILD_STATUS || 'unknown' }}"
            echo "编译时长: ${{ env.BUILD_DURATION || 'N/A' }}秒"
            echo "固件数量: ${{ env.FIRMWARE_COUNT || 0 }}"
            echo "预下载状态: ${{ env.DOWNLOAD_STATUS || '未执行' }}"
            echo ""
            
            # 添加工厂镜像状态
            echo "=== 工厂镜像状态 ==="
            if [ "${{ env.FACTORY_MISSING }}" = "true" ]; then
              echo "❌ 工厂刷机镜像: 缺失"
            else
              echo "✅ 工厂刷机镜像: 已生成"
            fi
            echo ""
            
            echo "=== 源码信息 ==="
            echo "源码库: ${{ env.SOURCE_PRESET }}"
            echo "请求分支: ${{ env.SOURCE_BRANCH }}"
            echo "实际分支: ${{ env.ACTUAL_BRANCH }}"
            echo "推荐分支: ${{ env.RECOMMENDED_BRANCH }}"
            echo "提交哈希: ${{ env.COMMIT_HASH || 'unknown' }}"
            echo ""
            echo "=== 编译配置 ==="
            echo "配置文件: ${{ github.event.inputs.config_profile }}"
            echo "优化策略: ${{ github.event.inputs.build_optimization }}"
            echo "工具链策略: ${{ github.event.inputs.toolchain_strategy }}"
            echo "自定义功能: ${{ github.event.inputs.enable_custom_features }}"
            echo "问题修复: ${{ github.event.inputs.fix_common_issues }}"
            echo "预下载: ${{ github.event.inputs.enable_pre_download }}"
            echo "后验证: ${{ github.event.inputs.enable_post_verify }}"
            echo ""
            echo "=== 系统信息 ==="
            echo "Runner: ${{ runner.os }}"
            echo "CPU核心: $(nproc)"
            echo "内存: $(free -h | awk '/^Mem:/{print $2}')"
            echo "磁盘空间: $(df -h /mnt | awk 'NR==2{print $4}') 可用"
            echo ""
            if [ "${{ env.BUILD_STATUS }}" = "success" ]; then
              echo "=== 产物信息 ==="
              echo "固件文件列表:"
              find ${{ env.ARTIFACTS_DIR }}/firmware -type f 2>/dev/null | xargs -I {} basename {} 2>/dev/null | sort | head -20
              echo ""
              echo "日志文件列表:"
              find ${{ env.ARTIFACTS_DIR }}/logs -type f 2>/dev/null | xargs -I {} basename {} 2>/dev/null | sort | head -10
            else
              echo "构建失败，无固件产物"
            fi
          } > "$REPORT_FILE"
          
          echo "✅ 详细构建报告生成完成"

      - name: 💾 上传构建产物
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: Firmware-${{ github.run_number }}-${{ env.SOURCE_PRESET }}-${{ env.ACTUAL_BRANCH }}-${{ env.BUILD_STATUS || 'unknown' }}
          path: ${{ env.ARTIFACTS_DIR }}
          retention-days: 30

      - name: 🧹 编译后智能清理
        if: always()
        run: |
          echo "开始编译后智能清理..."
          echo "=== 清理前状态 ==="
          df -h
          free -h
          
          if [ -d "${{ env.SOURCE_DIR }}" ]; then
            cd ${{ env.SOURCE_DIR }}
            echo "🧹 清理编译临时文件..."
            rm -rf build_dir/* staging_dir/* tmp/* 2>/dev/null || true
          fi
          
          echo "🧹 清理交换文件..."
          sudo swapoff /mnt/swapfile 2>/dev/null || true
          sudo rm -f /mnt/swapfile 2>/dev/null || true
          
          echo ""
          echo "=== 清理后状态 ==="
          df -h
          free -h
          echo "✅ 智能清理完成"

      - name: 📊 最终综合报告
        if: always()
        run: |
          echo "=== 最终综合报告 ==="
          echo "🎯 工作流: ${{ github.workflow }}"
          echo "🆔 运行ID: ${{ github.run_id }}"
          echo "🆔 运行号: ${{ github.run_number }}"
          echo ""
          echo "📦 源码信息:"
          echo "  - 预设: ${{ env.SOURCE_PRESET }}"
          echo "  - 分支: ${{ env.ACTUAL_BRANCH }}"
          echo "  - 推荐: ${{ env.RECOMMENDED_BRANCH }}"
          echo "  - 提交: ${{ env.COMMIT_HASH || 'unknown' }}"
          echo ""
          echo "⚙️ 编译配置:"
          echo "  - 配置文件: ${{ github.event.inputs.config_profile }}"
          echo "  - 优化策略: ${{ github.event.inputs.build_optimization }}"
          echo "  - 工具链: ${{ github.event.inputs.toolchain_strategy }}"
          echo "  - 自定义: ${{ github.event.inputs.enable_custom_features }}"
          echo "  - 问题修复: ${{ github.event.inputs.fix_common_issues }}"
          echo "  - 预下载: ${{ github.event.inputs.enable_pre_download }}"
          echo "  - 后验证: ${{ github.event.inputs.enable_post_verify }}"
          echo ""
          echo "📈 构建结果:"
          echo "  - 状态: ${{ env.BUILD_STATUS || 'unknown' }}"
          echo "  - 时长: ${{ env.BUILD_DURATION || 'N/A' }}秒"
          echo "  - 固件数量: ${{ env.FIRMWARE_COUNT || 0 }}"
          echo "  - 工厂镜像状态: ${{ env.FACTORY_MISSING == 'true' && '缺失' || '已生成' }}"
          echo "  - 预下载状态: ${{ env.DOWNLOAD_STATUS || '未执行' }}"
          echo ""
          if [ "${{ env.BUILD_STATUS }}" = "success" ]; then
            echo "🎉 构建成功！固件已上传到 Artifacts"
            echo "📦 下载 Artifacts 获取编译产物"
            echo "🔧 固件文件在 firmware/ 目录中"
            echo "📋 详细报告在 详细构建报告.txt"
            echo "🔍 深度分析在 深度错误分析与解决方案报告.txt"
            echo "📁 日志文件在 logs/ 目录中（分类清晰）"
            if [ "${{ env.FACTORY_MISSING }}" = "true" ]; then
              echo "⚠️ 注意: 工厂刷机镜像缺失，只有系统升级镜像"
            else
              echo "✅ 所有镜像类型均已生成"
            fi
          else
            echo "❌ 构建失败"
            echo "🔍 请查看详细日志分析错误原因"
            echo "📋 检查 Artifacts 中的编译日志"
            echo "🔍 查看 logs/问题摘要/ 快速了解问题"
            echo "💡 主要改进:"
            echo "  - 源码获取完整性验证"
            echo "  - 预下载依赖管理"
            echo "  - 多重错误恢复机制"
            echo "  - 详细的调试信息"
          fi

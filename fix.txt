#【build_firmware_main.sh-13】
generate_config() {
    local extra_packages=$1
    local device_override=$2  # 新增设备覆盖参数
    
    load_env
    cd $BUILD_DIR || handle_error "进入构建目录失败"
    
    # 如果提供了设备覆盖参数，优先使用
    if [ -n "$device_override" ]; then
        DEVICE="$device_override"
        log "🔧 使用设备覆盖参数: $DEVICE"
    fi
    
    log "=== 智能配置生成系统（设备显式指定版） ==="
    log "版本: $SELECTED_BRANCH"
    log "目标: $TARGET"
    log "子目标: $SUBTARGET"
    log "设备: $DEVICE"
    log "配置模式: $CONFIG_MODE"
    log "配置文件目录: $CONFIG_DIR"
    
    # 验证设备变量是否为空
    if [ -z "$DEVICE" ]; then
        log "❌ 错误: DEVICE变量为空！"
        log "可用环境变量:"
        env | grep -E "DEVICE|TARGET|SELECTED" || true
        handle_error "DEVICE变量未设置"
    fi
    
    rm -f .config .config.old .config.bak*
    log "✅ 已清理旧配置文件"
    
    # 步骤1: 根据设备名映射到正确的OpenWrt设备配置名（保持小写）
    local openwrt_device=""
    case "$DEVICE" in
        ac42u|rt-ac42u|asus_rt-ac42u)
            openwrt_device="asus_rt-ac42u"
            log "🔧 映射设备 $DEVICE -> $openwrt_device"
            ;;
        acrh17|rt-acrh17|asus_rt-acrh17)
            openwrt_device="asus_rt-acrh17"
            log "🔧 映射设备 $DEVICE -> $openwrt_device"
            ;;
        *)
            # 默认使用原设备名，但转换为OpenWrt格式（全部小写，下划线）
            openwrt_device=$(echo "$DEVICE" | tr '[:upper:]' '[:lower:]' | tr '-' '_')
            log "🔧 使用转换后的设备名: $openwrt_device"
            ;;
    esac
    
    # 直接使用小写的设备名
    local device_lower="$openwrt_device"
    local device_config="CONFIG_TARGET_${TARGET}_${SUBTARGET}_DEVICE_${device_lower}"
    
    log "🔧 设备配置变量: $device_config=y"
    
    # 步骤2: 创建基础目标配置 - 使用小写设备名
    cat > .config << EOF
CONFIG_TARGET_${TARGET}=y
CONFIG_TARGET_${TARGET}_${SUBTARGET}=y
${device_config}=y
EOF
    
    log "🔧 基础配置文件内容:"
    cat .config
    
    # 步骤3: 合并所有配置文件
    log "📁 开始合并配置文件..."
    
    # 辅助函数：安全追加配置（过滤注释和空行）
    append_config() {
        local file=$1
        if [ -f "$file" ]; then
            grep -v '^[[:space:]]*#' "$file" | grep -v '^[[:space:]]*$' | grep 'CONFIG_' >> .config
        fi
    }
    
    append_config "$CONFIG_DIR/base.config"
    append_config "$CONFIG_DIR/usb-generic.config"
    append_config "$CONFIG_DIR/$TARGET.config"
    append_config "$CONFIG_DIR/$SELECTED_BRANCH.config"
    append_config "$CONFIG_DIR/devices/$DEVICE.config"
    
    if [ "$CONFIG_MODE" = "normal" ]; then
        append_config "$CONFIG_DIR/normal.config"
    fi
    
    # 添加额外包
    if [ -n "$extra_packages" ]; then
        log "📦 添加额外包: $extra_packages"
        echo "$extra_packages" | tr ',' '
' | while read pkg; do
            [ -n "$pkg" ] && echo "CONFIG_PACKAGE_$pkg=y" >> .config
        done
    fi
    
    # 从config.txt动态添加配置（如果存在）
    if [ -f "$CONFIG_DIR/devices/$DEVICE.config" ]; then
        log "📋 从设备配置文件动态添加配置: $CONFIG_DIR/devices/$DEVICE.config"
        append_config "$CONFIG_DIR/devices/$DEVICE.config"
    fi
    
    # TCP BBR（所有设备都启用）
    echo "CONFIG_PACKAGE_kmod-tcp-bbr=y" >> .config
    echo 'CONFIG_DEFAULT_TCP_CONG="bbr"' >> .config
    
    # TurboACC（正常模式）
    if [ "$CONFIG_MODE" = "normal" ]; then
        echo "CONFIG_PACKAGE_luci-app-turboacc=y" >> .config
        echo "CONFIG_PACKAGE_kmod-shortcut-fe=y" >> .config
        echo "CONFIG_PACKAGE_kmod-fast-classifier=y" >> .config
    fi
    
    # ath10k 冲突解决（使用ct驱动）
    sed -i '/CONFIG_PACKAGE_kmod-ath10k=y/d' .config
    sed -i '/CONFIG_PACKAGE_kmod-ath10k-pci=y/d' .config
    sed -i '/CONFIG_PACKAGE_kmod-ath10k-smallbuffers=y/d' .config
    echo "# CONFIG_PACKAGE_kmod-ath10k is not set" >> .config
    echo "# CONFIG_PACKAGE_kmod-ath10k-pci is not set" >> .config
    echo "# CONFIG_PACKAGE_kmod-ath10k-smallbuffers is not set" >> .config
    echo "CONFIG_PACKAGE_kmod-ath10k-ct=y" >> .config
    
    # 步骤4: 第一次去重
    log "🔄 第一次去重配置..."
    sort .config | uniq > .config.tmp
    mv .config.tmp .config
    
    # 步骤5: 动态获取目标平台支持的内核配置
    log "🔍 动态获取目标平台支持的内核配置..."
    
    # 获取目标平台的内核配置文件
    local kernel_config_file=""
    local kernel_version=""
    
    # 检测内核版本
    if [ -f "target/linux/$TARGET/config-5.4" ]; then
        kernel_config_file="target/linux/$TARGET/config-5.4"
        kernel_version="5.4"
    elif [ -f "target/linux/$TARGET/config-5.10" ]; then
        kernel_config_file="target/linux/$TARGET/config-5.10"
        kernel_version="5.10"
    elif [ -f "target/linux/$TARGET/config-5.15" ]; then
        kernel_config_file="target/linux/$TARGET/config-5.15"
        kernel_version="5.15"
    elif [ -f "target/linux/$TARGET/config-6.1" ]; then
        kernel_config_file="target/linux/$TARGET/config-6.1"
        kernel_version="6.1"
    fi
    
    if [ -n "$kernel_config_file" ] && [ -f "$kernel_config_file" ]; then
        log "✅ 找到内核配置文件: $kernel_config_file (内核版本 $kernel_version)"
        
        # 动态提取USB相关的内核配置
        log "📋 从内核配置文件动态提取USB相关配置:"
        
        # 定义要查找的USB相关配置模式
        local usb_patterns=(
            "CONFIG_USB"
            "CONFIG_PHY"
            "CONFIG_DWC"
            "CONFIG_XHCI"
            "CONFIG_EXTCON"
            "CONFIG_COMMON_CLK"
            "CONFIG_ARCH"
        )
        
        # 创建一个临时文件存储提取的配置
        local usb_configs_file="/tmp/usb_configs_$$.txt"
        
        for pattern in "${usb_patterns[@]}"; do
            grep -E "^${pattern}|^# ${pattern}" "$kernel_config_file" >> "$usb_configs_file" 2>/dev/null || true
        done
        
        # 去重并排序
        sort -u "$usb_configs_file" > "$usb_configs_file.sorted"
        
        # 显示找到的配置
        local config_count=$(wc -l < "$usb_configs_file.sorted")
        log "找到 $config_count 个USB相关内核配置"
        
        # 将这些配置添加到.config中（但不要覆盖已启用的配置）
        while read line; do
            # 提取配置名（去掉前面的#和空格）
            local config_name=$(echo "$line" | sed 's/^# //g' | cut -d'=' -f1 | cut -d' ' -f1)
            
            # 检查配置是否已存在
            if ! grep -q "^${config_name}=" .config && ! grep -q "^# ${config_name} is not set" .config; then
                # 如果配置是启用的（=y），直接添加
                if echo "$line" | grep -q "=y$"; then
                    echo "$line" >> .config
                    log "  ✅ 添加: $line"
                # 如果配置是禁用的（is not set），作为注释添加
                elif echo "$line" | grep -q "is not set"; then
                    echo "$line" >> .config
                    log "  ⚪ 添加: $line"
                fi
            fi
        done < "$usb_configs_file.sorted"
        
        rm -f "$usb_configs_file" "$usb_configs_file.sorted"
    else
        log "⚠️ 未找到目标平台 $TARGET 的内核配置文件"
    fi
    
    # 步骤6: 第一次运行 make defconfig（这会重置内核配置）
    log "🔄 第一次运行 make defconfig（加载平台默认配置）..."
    make defconfig > /tmp/build-logs/defconfig1.log 2>&1 || {
        log "❌ 第一次 make defconfig 失败，查看日志..."
        tail -50 /tmp/build-logs/defconfig1.log
        handle_error "第一次依赖解决失败"
    }
    log "✅ 第一次 make defconfig 成功"
    
    # 步骤7: 动态检测实际生效的内核配置
    log "🔍 动态检测实际生效的USB内核配置..."
    
    # 定义要检查的关键USB组件
    local usb_components=(
        "USB_SUPPORT"
        "USB_COMMON"
        "USB"
        "USB_XHCI_HCD"
        "USB_DWC3"
        "PHY"
    )
    
    for component in "${usb_components[@]}"; do
        log "检查 $component 相关配置:"
        grep -E "CONFIG_${component}" .config | head -10 | while read line; do
            log "    $line"
        done
    done
    
    # 步骤8: 动态添加USB软件包（基于目标平台）
    log "📋 动态添加USB软件包..."
    
    # 基础USB软件包（所有平台都需要）
    local base_usb_packages=(
        "kmod-usb-core"
        "kmod-usb-common"
        "kmod-usb2"
        "kmod-usb3"
        "kmod-usb-storage"
        "kmod-scsi-core"
        "block-mount"
        "automount"
        "usbutils"
    )
    
    # 根据目标平台添加特定软件包
    case "$TARGET" in
        ipq40xx|ipq806x|qcom)
            log "检测到高通平台，添加专用USB驱动..."
            local qcom_packages=(
                "kmod-usb-dwc3"
                "kmod-usb-dwc3-qcom"
                "kmod-usb-dwc3-of-simple"
                "kmod-phy-qcom-ipq4019-usb"
                "kmod-usb-xhci-hcd"
                "kmod-usb-xhci-plat-hcd"
            )
            base_usb_packages+=("${qcom_packages[@]}")
            ;;
        mediatek|ramips)
            log "检测到联发科平台，添加专用USB驱动..."
            local mtk_packages=(
                "kmod-usb-xhci-mtk"
                "kmod-usb-dwc3"
                "kmod-usb-dwc3-mediatek"
            )
            base_usb_packages+=("${mtk_packages[@]}")
            ;;
        ath79)
            log "检测到ATH79平台，添加专用USB驱动..."
            local ath79_packages=(
                "kmod-usb2-ath79"
                "kmod-usb-ohci"
            )
            base_usb_packages+=("${ath79_packages[@]}")
            ;;
    esac
    
    # 去重并添加USB软件包
    printf "%s\n" "${base_usb_packages[@]}" | sort -u | while read pkg; do
        if ! grep -q "^CONFIG_PACKAGE_${pkg}=y" .config; then
            echo "CONFIG_PACKAGE_${pkg}=y" >> .config
            log "  ✅ 添加软件包: $pkg"
        fi
    done
    
    # 步骤9: 第二次去重
    log "🔄 第二次去重配置..."
    sort .config | uniq > .config.tmp
    mv .config.tmp .config
    
    # 步骤10: 第二次运行 make defconfig（应用强制配置）
    log "🔄 第二次运行 make defconfig（应用强制配置）..."
    make defconfig > /tmp/build-logs/defconfig2.log 2>&1 || {
        log "⚠️ 第二次 make defconfig 有警告，但继续..."
    }
    log "✅ 第二次 make defconfig 完成"
    
    # 步骤11: 验证关键USB驱动状态
    log "🔍 验证关键USB驱动状态..."
    
    # 动态检测哪些USB驱动已启用
    local enabled_usb_drivers=$(grep "^CONFIG_PACKAGE_kmod-usb" .config | grep "=y" | cut -d'=' -f1 | sed 's/CONFIG_PACKAGE_//g')
    local disabled_usb_drivers=$(grep "^# CONFIG_PACKAGE_kmod-usb" .config | grep "is not set" | sed 's/# CONFIG_PACKAGE_//g' | sed 's/ is not set//g')
    
    log "已启用的USB驱动:"
    echo "$enabled_usb_drivers" | head -20 | while read driver; do
        [ -n "$driver" ] && log "  ✅ $driver"
    done
    
    # 检查关键驱动是否缺失
    local critical_drivers=(
        "kmod-usb-core"
        "kmod-usb2"
        "kmod-usb-storage"
    )
    
    local missing_critical=0
    for driver in "${critical_drivers[@]}"; do
        if ! echo "$enabled_usb_drivers" | grep -q "$driver"; then
            log "  ❌ 关键驱动缺失: $driver"
            missing_critical=$((missing_critical + 1))
        fi
    done
    
    if [ $missing_critical -eq 0 ]; then
        log "✅ 所有关键USB驱动都已启用"
    else
        log "⚠️ 有 $missing_critical 个关键USB驱动缺失"
    fi
    
    # 步骤12: 最终设备验证
    log "🔍 正在验证设备 $openwrt_device 是否被选中..."
    
    # 动态查找设备配置
    local device_found=$(grep -E "CONFIG_TARGET_.*DEVICE.*${device_lower}=y" .config | head -1)
    
    if [ -n "$device_found" ]; then
        log "✅ 目标设备已正确启用: $device_found"
    else
        # 尝试查找可用的设备选项
        log "⚠️ 警告: 设备 $openwrt_device 未找到，查找可用设备:"
        grep -E "CONFIG_TARGET_.*DEVICE.*=y" .config | head -10 | while read line; do
            log "    $line"
        done
        
        # 尝试强制添加
        log "🔄 尝试强制添加设备配置..."
        echo "CONFIG_TARGET_${TARGET}_${SUBTARGET}_DEVICE_${device_lower}=y" >> .config
        sort .config | uniq > .config.tmp
        mv .config.tmp .config
        make defconfig > /dev/null 2>&1
        
        if grep -q "CONFIG_TARGET_${TARGET}_${SUBTARGET}_DEVICE_${device_lower}=y" .config; then
            log "✅ 设备已强制添加"
        fi
    fi
    
    # 步骤13: 保存配置统计信息
    local total_configs=$(wc -l < .config)
    local enabled_packages=$(grep -c "^CONFIG_PACKAGE_.*=y$" .config)
    local enabled_kernel=$(grep -c "^CONFIG_[A-Z].*=y$" .config | grep -v "PACKAGE" | wc -l)
    
    log "📊 配置统计:"
    log "  总配置行数: $total_configs"
    log "  启用软件包: $enabled_packages"
    log "  启用内核配置: $enabled_kernel"
    
    log "✅ 配置生成完成"
}
#【build_firmware_main.sh-13-end】

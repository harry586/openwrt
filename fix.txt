#!/bin/bash
set -e

# ==============================
# 【系统初始化】文件头和全局定义
# ==============================

#【build_firmware_main.sh-01】紧急修复：清除Windows换行符
# 修复第25行错误：syntax error near unexpected token $'{\r''
# 原因：handle_error() { 这行有\r字符

# 方法1：立即清除整个文件的\r字符
if [ -f "${BASH_SOURCE[0]}" ]; then
    echo "🔧 正在修复Windows换行符..."
    # 使用sed清除所有\r字符
    sed -i 's/\r$//' "${BASH_SOURCE[0]}"
    echo "✅ 修复完成，重新执行脚本..."
    # 重新执行修复后的脚本
    exec bash "${BASH_SOURCE[0]}" "$@"
fi

# 如果上面的方法生效，下面的代码不会执行
# 继续原脚本内容...

#【build_firmware_main.sh-02】修复handle_error函数定义
# 特别注意：函数定义的大括号{不能有\r字符
handle_error() {
    log "❌ 错误发生在: $1"
    log "详细错误信息:"
    echo "最后100行构建日志:"
    tail -100 /tmp/build-logs/*.log 2>/dev/null || echo "无日志文件"
    
    # 检查defconfig日志
    if [ -f "/tmp/defconfig.log" ]; then
        echo "defconfig 错误日志:"
        cat "/tmp/defconfig.log"
    fi
    
    # 检查.config文件
    if [ -f ".config" ]; then
        echo ".config 最后50行:"
        tail -50 .config
    fi
    
    exit 1
}

#【build_firmware_main.sh-03】精确修复第25行
# 修复第25行：handle_error() { 这行的换行符问题

# 在脚本开头添加这个函数来修复特定行
fix_specific_line() {
    local line_num=25
    local script_file="${BASH_SOURCE[0]}"
    
    # 检查第25行是否有\r
    if sed -n "${line_num}p" "$script_file" | grep -q $'\r'; then
        echo "⚠️ 检测到第${line_num}行有Windows换行符，正在修复..."
        
        # 备份文件
        cp "$script_file" "${script_file}.bak"
        
        # 修复第25行
        sed -i "${line_num}s/\r$//" "$script_file"
        
        # 检查修复结果
        if sed -n "${line_num}p" "$script_file" | grep -q $'\r'; then
            echo "❌ 修复失败，恢复备份"
            cp "${script_file}.bak" "$script_file"
        else
            echo "✅ 第${line_num}行修复成功"
            rm -f "${script_file}.bak"
            
            # 重新执行修复后的脚本
            echo "🔄 重新执行修复后的脚本..."
            exec bash "$script_file" "$@"
        fi
    fi
}

# 调用修复函数
fix_specific_line

#【build_firmware_main.sh-04】完整紧急修复脚本
#!/bin/bash

# ==============================
# 【第一步】检查和修复Windows换行符
# ==============================
SCRIPT_FILE="${BASH_SOURCE[0]}"
HAS_WINDOWS_LINES=false

# 检查文件是否有Windows换行符
if file "$SCRIPT_FILE" | grep -q "CRLF" || file "$SCRIPT_FILE" | grep -q "with CRLF"; then
    echo "❌ 检测到Windows换行符（CRLF），正在修复..."
    HAS_WINDOWS_LINES=true
    
    # 备份原文件
    BACKUP_FILE="${SCRIPT_FILE}.windows_backup"
    cp "$SCRIPT_FILE" "$BACKUP_FILE"
    echo "✅ 已备份到: $BACKUP_FILE"
    
    # 方法1：使用tr命令
    echo "方法1: 使用tr命令清除\r字符..."
    tr -d '\r' < "$BACKUP_FILE" > "$SCRIPT_FILE"
    
    # 验证修复
    if file "$SCRIPT_FILE" | grep -q "CRLF"; then
        echo "方法1失败，尝试方法2..."
        # 方法2：使用sed命令
        sed -i 's/\r$//' "$SCRIPT_FILE"
    fi
    
    # 最终验证
    if file "$SCRIPT_FILE" | grep -q "CRLF"; then
        echo "❌ 修复失败，使用原文件"
        cp "$BACKUP_FILE" "$SCRIPT_FILE"
    else
        echo "✅ 修复成功，清除Windows换行符"
        rm -f "$BACKUP_FILE"
    fi
fi

# ==============================
# 【第二步】重新执行修复后的脚本
# ==============================
if [ "$HAS_WINDOWS_LINES" = true ]; then
    echo "🔄 重新执行修复后的脚本..."
    exec bash "$SCRIPT_FILE" "$@"
fi

# ==============================
# 【第三步】原脚本内容从这里开始
# ==============================
set -e

echo "✅ 脚本开始执行，第25行应该已经修复..."

#【build_firmware_main.sh-05】修复的handle_error函数
# 确保这行没有\r字符：handle_error() {
handle_error() {
    echo "❌ 错误发生在: $1"
    # ... 函数内容
}
